<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>IdeaTracker - Hedge Fund Position Management</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
    @keyframes pulse-loading { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }
    .line-clamp-1 { display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; overflow: hidden; }
    .wl-table td, .wl-table th { font-size: 11px; }
    #loading-screen { position: fixed; inset: 0; background: #0f172a; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; }
    #loading-screen span { color: #94a3b8; font-size: 14px; animation: pulse-loading 1.5s ease-in-out infinite; }
    #loading-screen h1 { color: #e2e8f0; font-size: 24px; margin-bottom: 12px; }
  </style>
</head>
<body style="background: #0f172a;">
  <div id="loading-screen"><h1>ðŸ“Š IdeaTracker</h1><span>Loading portfolio manager...</span></div>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo, useCallback } = React;

    // Simple icon components
    const TrendingUp = () => <span style={{color: '#10b981'}}>â†—</span>;
    const TrendingDown = () => <span style={{color: '#ef4444'}}>â†˜</span>;
    const FileSpreadsheet = () => <span>ðŸ“Š</span>;
    const ImageIcon = () => <span>ðŸ“¸</span>;

    const IdeaTracker = () => {
      const dashboardRef = useRef(null);

      // Info tooltip component (used across all tabs)
      const InfoTip = ({ text }) => (
        <span className="relative inline-flex items-center justify-center group ml-1 cursor-help">
          <span className="w-3.5 h-3.5 rounded-full bg-slate-600/60 text-slate-400 text-[9px] font-bold inline-flex items-center justify-center border border-slate-500/40 group-hover:bg-blue-500/30 group-hover:border-blue-400/50 group-hover:text-blue-300 transition-all">i</span>
          <span className="invisible group-hover:visible absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-2 bg-slate-900 border border-slate-600 rounded-lg text-xs text-slate-200 whitespace-pre-line z-50 w-56 shadow-xl leading-relaxed pointer-events-none">
            {text}
            <span className="absolute top-full left-1/2 -translate-x-1/2 -mt-[1px] border-4 border-transparent border-t-slate-600"></span>
          </span>
        </span>
      );
      
      // Number formatting helper - adds commas to numbers
      const fmt = (numStr) => {
        if (!numStr && numStr !== 0) return '0';
        const str = typeof numStr === 'number' ? numStr.toFixed(2) : String(numStr);
        const parts = str.split('.');
        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        return parts.join('.');
      };
      const pieChartRef = useRef(null);
      const barChartRef = useRef(null);
      const performanceChartRef = useRef(null);
      const pieChart = useRef(null);
      const barChart = useRef(null);
      const performanceChart = useRef(null);
      
      const TOTAL_PORTFOLIO = 1000000000; // $1B GMV
      
      const [portfolios, setPortfolios] = useState(() => {
        const saved = localStorage.getItem('ideatracker-portfolios');
        return saved ? JSON.parse(saved) : {
          'All Positions': []
        };
      });
      
      const [currentPortfolio, setCurrentPortfolio] = useState(() => {
        const saved = localStorage.getItem('ideatracker-current-portfolio');
        return saved || 'All Positions';
      });
      const [newPortfolioName, setNewPortfolioName] = useState('');
      const [showNewPortfolio, setShowNewPortfolio] = useState(false);
      
      // GMV (Gross Market Value) - user can set this
      const [portfolioGMV, setPortfolioGMV] = useState(() => {
        const saved = localStorage.getItem('ideatracker-gmv');
        return saved ? parseFloat(saved) : 1000000000; // Default $1B
      });
      
      // Position sizing mode
      const [sizingMode, setSizingMode] = useState(() => {
        const saved = localStorage.getItem('ideatracker-sizing-mode');
        return saved || 'conviction';
      });
      
      // Tracking start date
      const [trackingStartDate, setTrackingStartDate] = useState(() => {
        const saved = localStorage.getItem('ideatracker-start-date');
        return saved || new Date().toISOString().split('T')[0];
      });
      
      // Historical performance data
      const [performanceHistory, setPerformanceHistory] = useState(() => {
        const saved = localStorage.getItem('ideatracker-performance');
        return saved ? JSON.parse(saved) : [];
      });
      
      // Change log - tracks all rating/position changes over time
      // Each entry: { id, date, ticker, action, direction, conviction, thesis, catalyst, price, portfolio }
      const [changeLog, setChangeLog] = useState(() => {
        const saved = localStorage.getItem('ideatracker-changelog');
        return saved ? JSON.parse(saved) : [];
      });
      
      // Remove initial dummy data - start with empty portfolio
      const [ideas, setIdeas] = useState([]);
      
      // Edit mode
      const [editingId, setEditingId] = useState(null);
      const [editForm, setEditForm] = useState({});

      const [newIdea, setNewIdea] = useState({
        ticker: '',
        direction: 'long',
        conviction: 3,
        thesis: '',
        catalyst: ''
      });

      const [marketData, setMarketData] = useState(() => {
        const saved = localStorage.getItem('ideatracker-market-data');
        return saved ? JSON.parse(saved) : { spy: 100, vix: 14.5 };
      });
      const [loading, setLoading] = useState(false);
      const [lastUpdate, setLastUpdate] = useState(new Date());

      // Save portfolios to localStorage
      useEffect(() => {
        localStorage.setItem('ideatracker-portfolios', JSON.stringify(portfolios));
      }, [portfolios]);

      // Save GMV
      useEffect(() => {
        localStorage.setItem('ideatracker-gmv', portfolioGMV.toString());
      }, [portfolioGMV]);

      // Save tracking date
      useEffect(() => {
        localStorage.setItem('ideatracker-start-date', trackingStartDate);
      }, [trackingStartDate]);

      // Save performance history
      useEffect(() => {
        localStorage.setItem('ideatracker-performance', JSON.stringify(performanceHistory));
      }, [performanceHistory]);

      // Save sizing mode
      useEffect(() => {
        localStorage.setItem('ideatracker-sizing-mode', sizingMode);
      }, [sizingMode]);

      // Save current portfolio selection
      useEffect(() => {
        localStorage.setItem('ideatracker-current-portfolio', currentPortfolio);
      }, [currentPortfolio]);

      // Save market data
      useEffect(() => {
        localStorage.setItem('ideatracker-market-data', JSON.stringify(marketData));
      }, [marketData]);

      // Save change log
      useEffect(() => {
        localStorage.setItem('ideatracker-changelog', JSON.stringify(changeLog));
      }, [changeLog]);

      // Log a change event
      const logChange = (action, idea, extras = {}) => {
        const entry = {
          id: Date.now() + Math.random(),
          date: new Date().toISOString(),
          ticker: idea.ticker,
          action, // 'ADD', 'EDIT', 'REMOVE', 'CONVICTION_CHANGE', 'DIRECTION_CHANGE'
          direction: idea.direction,
          conviction: idea.conviction,
          thesis: idea.thesis || '',
          catalyst: idea.catalyst || '',
          price: idea.currentPrice || idea.entryPrice || 0,
          portfolio: currentPortfolio,
          ...extras
        };
        setChangeLog(prev => [...prev, entry]);
      };

      // Save status indicator
      const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'unsaved'
      const [lastSavedTime, setLastSavedTime] = useState(() => {
        const saved = localStorage.getItem('ideatracker-last-saved');
        return saved || null;
      });

      // Tab navigation
      const [activeTab, setActiveTab] = useState('tracker');

      // User auth system
      const [currentUser, setCurrentUser] = useState(() => {
        try { return JSON.parse(localStorage.getItem('ideatracker-user')); } catch { return null; }
      });
      const [showAuthModal, setShowAuthModal] = useState(false);
      const [authMode, setAuthMode] = useState('login');
      const [authForm, setAuthForm] = useState({ email: '', password: '', name: '' });
      const [authError, setAuthError] = useState('');

      const handleAuth = () => {
        setAuthError('');
        if (!authForm.email || !authForm.password) { setAuthError('Email and password required'); return; }
        const users = JSON.parse(localStorage.getItem('ideatracker-users') || '{}');
        if (authMode === 'signup') {
          if (!authForm.name) { setAuthError('Name required'); return; }
          if (authForm.password.length < 6) { setAuthError('Password must be 6+ characters'); return; }
          if (users[authForm.email]) { setAuthError('Account already exists'); return; }
          users[authForm.email] = { email: authForm.email, name: authForm.name, password: btoa(authForm.password) };
          localStorage.setItem('ideatracker-users', JSON.stringify(users));
          const session = { email: authForm.email, name: authForm.name };
          localStorage.setItem('ideatracker-user', JSON.stringify(session));
          setCurrentUser(session);
          setShowAuthModal(false);
          setAuthForm({ email: '', password: '', name: '' });
        } else {
          const user = users[authForm.email];
          if (!user || atob(user.password) !== authForm.password) { setAuthError('Invalid email or password'); return; }
          const session = { email: user.email, name: user.name };
          localStorage.setItem('ideatracker-user', JSON.stringify(session));
          setCurrentUser(session);
          setShowAuthModal(false);
          setAuthForm({ email: '', password: '', name: '' });
        }
      };
      const handleLogout = () => { localStorage.removeItem('ideatracker-user'); setCurrentUser(null); };

      // News tab state
      const [newsItems, setNewsItems] = useState([]);
      const [newsLoading, setNewsLoading] = useState(false);
      const [newsFilter, setNewsFilter] = useState(null);
      const [newsLastFetch, setNewsLastFetch] = useState(null);

      // Watchlist state
      const [watchlist, setWatchlist] = useState(() => {
        try { return JSON.parse(localStorage.getItem('ideatracker-watchlist')) || []; } catch { return []; }
      });
      const [wlSectors, setWlSectors] = useState(() => {
        try { return JSON.parse(localStorage.getItem('ideatracker-wl-sectors')) || {}; } catch { return {}; }
      });
      const [wlPrices, setWlPrices] = useState({});
      const [wlLoading, setWlLoading] = useState(false);
      const [wlAddTicker, setWlAddTicker] = useState('');
      const [wlEditSector, setWlEditSector] = useState(null);
      const [wlClassifying, setWlClassifying] = useState(false);
      const [wlSort, setWlSort] = useState({ col: null, dir: 'desc' }); // {col: 'chgPct', dir: 'asc'|'desc'}
      const [wlNewSector, setWlNewSector] = useState('');
      const [wlRenameSector, setWlRenameSector] = useState(null); // {old, value}
      const [wlDragTicker, setWlDragTicker] = useState(null);

      useEffect(() => {
        localStorage.setItem('ideatracker-watchlist', JSON.stringify(watchlist));
      }, [watchlist]);
      useEffect(() => {
        localStorage.setItem('ideatracker-wl-sectors', JSON.stringify(wlSectors));
      }, [wlSectors]);

      // Mark as saved whenever localStorage writes happen
      useEffect(() => {
        const now = new Date().toISOString();
        localStorage.setItem('ideatracker-last-saved', now);
        setLastSavedTime(now);
        setSaveStatus('saved');
      }, [portfolios, portfolioGMV, trackingStartDate, performanceHistory, sizingMode, marketData]);

      // Save all state to a JSON file for portability
      const saveToFile = () => {
        const saveData = {
          version: 3,
          savedAt: new Date().toISOString(),
          portfolios,
          currentPortfolio,
          portfolioGMV,
          sizingMode,
          trackingStartDate,
          performanceHistory,
          marketData,
          changeLog
        };
        const blob = new Blob([JSON.stringify(saveData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().split('T')[0];
        link.download = `IdeaTracker_Save_${timestamp}.json`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
        setSaveStatus('saved');
      };

      // Load state from a JSON file
      const loadFromFile = () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            try {
              const data = JSON.parse(ev.target.result);
              if (!data.portfolios) {
                alert('Invalid save file â€” no portfolio data found.');
                return;
              }
              if (!confirm(`Load save from ${new Date(data.savedAt).toLocaleString()}? This will replace all current data.`)) return;
              
              setPortfolios(data.portfolios);
              setCurrentPortfolio(data.currentPortfolio || 'All Positions');
              setPortfolioGMV(data.portfolioGMV || 1000000000);
              setSizingMode(data.sizingMode || 'conviction');
              setTrackingStartDate(data.trackingStartDate || new Date().toISOString().split('T')[0]);
              setPerformanceHistory(data.performanceHistory || []);
              setMarketData(data.marketData || { spy: 100, vix: 14.5 });
              setChangeLog(data.changeLog || []);
              
              setSaveStatus('saved');
              alert('Data loaded successfully!');
            } catch (err) {
              alert('Error reading save file: ' + err.message);
            }
          };
          reader.readAsText(file);
        };
        input.click();
      };

      // Clear all data
      const clearAllData = () => {
        if (!confirm('Are you sure you want to clear ALL data? This cannot be undone.')) return;
        if (!confirm('Really clear everything? Last chance.')) return;
        setPortfolios({ 'All Positions': [] });
        setCurrentPortfolio('All Positions');
        setPortfolioGMV(1000000000);
        setSizingMode('conviction');
        setTrackingStartDate(new Date().toISOString().split('T')[0]);
        setPerformanceHistory([]);
        setMarketData({ spy: 100, vix: 14.5 });
        setChangeLog([]);
        localStorage.clear();
      };

      // Get current portfolio ideas
      const currentIdeas = portfolios[currentPortfolio] || [];
      
      // Add portfolio
      const addPortfolio = () => {
        if (!newPortfolioName || portfolios[newPortfolioName]) return;
        setPortfolios({ ...portfolios, [newPortfolioName]: [] });
        setCurrentPortfolio(newPortfolioName);
        setNewPortfolioName('');
        setShowNewPortfolio(false);
      };

      // Delete portfolio
      const deletePortfolio = (name) => {
        if (name === 'All Positions') {
          alert('Cannot delete the default portfolio');
          return;
        }
        if (!confirm(`Delete portfolio "${name}"? This cannot be undone.`)) return;
        
        const newPortfolios = { ...portfolios };
        delete newPortfolios[name];
        setPortfolios(newPortfolios);
        setCurrentPortfolio('All Positions');
      };

      // Rename portfolio
      const renamePortfolio = (oldName) => {
        if (oldName === 'All Positions') {
          alert('Cannot rename the default portfolio');
          return;
        }
        const newName = prompt(`Rename portfolio "${oldName}" to:`, oldName);
        if (!newName || newName === oldName || portfolios[newName]) return;
        
        const newPortfolios = { ...portfolios };
        newPortfolios[newName] = newPortfolios[oldName];
        delete newPortfolios[oldName];
        setPortfolios(newPortfolios);
        setCurrentPortfolio(newName);
      };

      // Update ideas in current portfolio with auto-sort
      const updateIdeas = (newIdeas) => {
        // Auto-sort: Longs by conviction desc, then Shorts by conviction desc
        const longs = newIdeas.filter(i => i.direction === 'long').sort((a, b) => b.conviction - a.conviction);
        const shorts = newIdeas.filter(i => i.direction === 'short').sort((a, b) => b.conviction - a.conviction);
        const sortedIdeas = [...longs, ...shorts];
        
        setPortfolios({
          ...portfolios,
          [currentPortfolio]: sortedIdeas
        });
      };

      // Fetch live price
      const fetchPrice = async (ticker) => {
        try {
          const url = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?interval=1d&range=1d`;
          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
          const response = await fetch(proxyUrl);
          const data = await response.json();
          
          if (data.chart && data.chart.result && data.chart.result[0] && data.chart.result[0].meta) {
            const quote = data.chart.result[0].meta.regularMarketPrice;
            return quote || 0;
          }
          
          console.warn(`No price data for ${ticker}, using default`);
          return 100; // Default price if fetch fails
        } catch (error) {
          console.error(`Error fetching ${ticker}:`, error);
          return 100; // Default price on error
        }
      };

      // Refresh prices
      const refreshPrices = async () => {
        setLoading(true);
        const updatedIdeas = await Promise.all(
          currentIdeas.map(async (idea) => {
            const price = await fetchPrice(idea.ticker);
            return { ...idea, currentPrice: price || idea.currentPrice };
          })
        );
        updateIdeas(updatedIdeas);
        
        const spyPrice = await fetchPrice('SPY');
        setMarketData(prev => ({ ...prev, spy: spyPrice || prev.spy }));
        
        // Update a single "live" snapshot at the end of performance history.
        // This keeps the backtest data intact (consistent intervals) and just 
        // extends one point to today's prices.
        if (performanceHistory.length > 0) {
          const freshSizes = calculatePositionSizes(updatedIdeas);
          let livePnL = 0;
          updatedIdeas.forEach((idea, idx) => {
            const alloc = freshSizes[idx]?.allocation || 0;
            const startEntry = idea.entryPrice || 100;
            const curPrice = idea.currentPrice || startEntry;
            if (startEntry > 0) {
              livePnL += idea.direction === 'long'
                ? ((curPrice - startEntry) / startEntry) * alloc
                : ((startEntry - curPrice) / startEntry) * alloc;
            }
          });
          
          const today = new Date().toISOString().split('T')[0];
          const lastEntry = performanceHistory[performanceHistory.length - 1];
          const lastDate = lastEntry?.date ? new Date(lastEntry.date).toISOString().split('T')[0] : '';
          
          const liveSnapshot = {
            date: new Date().toISOString(),
            portfolioReturn: livePnL / 1000,
            spyPrice: spyPrice || marketData.spy,
            isLive: true
          };
          
          // Replace existing live snapshot or append if last entry is from a different day
          const filtered = performanceHistory.filter(h => !h.isLive);
          setPerformanceHistory([...filtered, liveSnapshot]);
        }
        
        setLastUpdate(new Date());
        setLoading(false);
      };

      // Add idea
      const addIdea = async () => {
        if (!newIdea.ticker) return;
        
        setLoading(true);
        const price = await fetchPrice(newIdea.ticker.toUpperCase());
        
        // Ensure we have a valid price
        const validPrice = price > 0 ? price : 100; // Default to 100 if fetch fails
        
        const idea = {
          id: Date.now(),
          ticker: newIdea.ticker.toUpperCase(),
          direction: newIdea.direction,
          conviction: newIdea.conviction,
          manualSize: null,
          manualShares: null,
          entryPrice: validPrice,
          currentPrice: validPrice,
          entryDate: new Date().toISOString().split('T')[0],
          thesis: newIdea.thesis,
          catalyst: newIdea.catalyst
        };
        
        updateIdeas([...currentIdeas, idea]);
        logChange('ADD', idea);
        setNewIdea({ ticker: '', direction: 'long', conviction: 3, thesis: '', catalyst: '' });
        setLoading(false);
      };

      // Calculate conviction weights and position sizing
      // Hybrid: conviction-based default, with per-position overrides (shares or $)
      // Each idea can have sizeOverride: { type: 'dollars' | 'shares', value: number } or null
      const calculatePositionSizes = (ideasList) => {
        if (!ideasList || ideasList.length === 0) return [];
        
        // First pass: compute GMV already claimed by overridden positions
        let overriddenGMV = 0;
        ideasList.forEach(idea => {
          if (idea.sizeOverride && idea.sizeOverride.value > 0) {
            const price = idea.currentPrice || idea.entryPrice || 1;
            overriddenGMV += idea.sizeOverride.type === 'shares'
              ? idea.sizeOverride.value * price
              : idea.sizeOverride.value;
          }
        });
        
        // Remaining GMV for conviction-based positions
        const remainingGMV = Math.max(0, portfolioGMV - overriddenGMV);
        const nonOverriddenConviction = ideasList.reduce((sum, idea) => {
          if (idea.sizeOverride && idea.sizeOverride.value > 0) return sum;
          return sum + (idea.conviction || 0);
        }, 0);
        
        return ideasList.map(idea => {
          const price = idea.currentPrice || idea.entryPrice || 1;
          let allocation, shares, weight, isOverridden = false;
          
          if (idea.sizeOverride && idea.sizeOverride.value > 0) {
            isOverridden = true;
            if (idea.sizeOverride.type === 'shares') {
              shares = idea.sizeOverride.value;
              allocation = shares * price;
            } else {
              allocation = idea.sizeOverride.value;
              shares = price > 0 ? allocation / price : 0;
            }
          } else {
            // Conviction-based from remaining pool
            const convWeight = nonOverriddenConviction > 0 ? (idea.conviction || 0) / nonOverriddenConviction : 0;
            allocation = remainingGMV * convWeight;
            shares = price > 0 ? allocation / price : 0;
          }
          
          weight = portfolioGMV > 0 ? allocation / portfolioGMV : 0;
          return { ...idea, allocation, shares, weight, isOverridden };
        });
      };

      // Calculate metrics (separated for reusability)
      const calculateMetricsForIdeas = (ideasList) => {
        if (!ideasList || ideasList.length === 0) {
          return {
            grossExposure: '0.00',
            netExposure: '0.00',
            netExposurePercent: '0.0',
            battingAverage: '0.0',
            portfolioAlpha: '0.00',
            totalPnL: '0.00',
            sharpe: '0.00',
            beta: '0.00',
            longExposure: '0.00',
            shortExposure: '0.00',
            deployed: '0.00'
          };
        }

        const positionsWithSizes = calculatePositionSizes(ideasList);
        
        let totalLongExposure = 0;
        let totalShortExposure = 0;
        let totalPnL = 0;
        let wins = 0;

        positionsWithSizes.forEach(idea => {
          const currentPrice = idea.currentPrice || idea.entryPrice || 0;
          const entryPrice = idea.entryPrice || 0;
          const allocation = idea.allocation || 0;
          
          const exposure = allocation;
          const pnl = idea.direction === 'long' 
            ? (entryPrice > 0 ? ((currentPrice - entryPrice) / entryPrice) * allocation : 0)
            : (entryPrice > 0 ? ((entryPrice - currentPrice) / entryPrice) * allocation : 0);
          
          if (idea.direction === 'long') totalLongExposure += exposure;
          else totalShortExposure += exposure;
          
          totalPnL += pnl;
          if (pnl > 0) wins++;
        });

        // Compute actual SPY return from backtest performance history
        let actualMarketReturn = 0;
        if (performanceHistory.length >= 2) {
          const firstSpy = performanceHistory[0].spyPrice;
          const lastSpy = performanceHistory[performanceHistory.length - 1].spyPrice;
          if (firstSpy > 0) actualMarketReturn = (lastSpy - firstSpy) / firstSpy;
        }
        
        // Alpha = portfolio P&L minus what you'd have earned in SPY with same gross exposure
        const grossExposure = totalLongExposure + totalShortExposure;
        const marketPnL = grossExposure * actualMarketReturn;
        
        const netExposure = totalLongExposure - totalShortExposure;
        const battingAverage = (wins / ideasList.length) * 100;
        const portfolioAlpha = totalPnL - marketPnL;
        const portfolioReturn = portfolioGMV > 0 ? totalPnL / portfolioGMV : 0;
        
        // Sharpe: use actual volatility from history if available
        let sharpe = 0;
        if (performanceHistory.length > 2) {
          const returns = [];
          for (let i = 1; i < performanceHistory.length; i++) {
            const prevPnL = performanceHistory[i - 1].portfolioReturn * 1000;
            const curPnL = performanceHistory[i].portfolioReturn * 1000;
            if (portfolioGMV > 0) returns.push((curPnL - prevPnL) / portfolioGMV);
          }
          if (returns.length >= 2) {
            const meanRet = returns.reduce((s, r) => s + r, 0) / returns.length;
            const vol = Math.sqrt(returns.reduce((s, r) => s + (r - meanRet) ** 2, 0) / (returns.length - 1));
            // Compute actual interval from data
            const firstDate = new Date(performanceHistory[0].date).getTime();
            const lastDate = new Date(performanceHistory[performanceHistory.length - 1].date).getTime();
            const totalDays = (lastDate - firstDate) / (1000 * 60 * 60 * 24);
            const avgInterval = totalDays / Math.max(returns.length, 1);
            const periodsPerYear = avgInterval > 0 ? 252 / avgInterval : 52;
            const annVol = vol * Math.sqrt(periodsPerYear);
            const annReturn = meanRet * periodsPerYear;
            sharpe = annVol > 0 ? (annReturn - 0.05) / annVol : 0;
          }
        }
        
        const beta = totalLongExposure > 0 ? netExposure / totalLongExposure : 0;

        return {
          grossExposure: (grossExposure / 1000000).toFixed(2),
          netExposure: (netExposure / 1000000).toFixed(2),
          netExposurePercent: portfolioGMV > 0 ? ((netExposure / portfolioGMV) * 100).toFixed(1) : '0.0',
          battingAverage: battingAverage.toFixed(1),
          portfolioAlpha: (portfolioAlpha / 1000).toFixed(2),
          totalPnL: (totalPnL / 1000).toFixed(2),
          sharpe: sharpe.toFixed(2),
          beta: beta.toFixed(2),
          longExposure: (totalLongExposure / 1000000).toFixed(2),
          shortExposure: (totalShortExposure / 1000000).toFixed(2),
          deployed: (grossExposure / 1000000).toFixed(2)
        };
      };

      // Start editing a position
      const startEdit = (idea) => {
        setEditingId(idea.id);
        const ov = idea.sizeOverride;
        let overrideValue = '';
        if (ov && ov.value > 0) {
          overrideValue = ov.type === 'shares' ? ov.value : (ov.value / 1000000).toFixed(1);
        }
        setEditForm({
          ticker: idea.ticker,
          direction: idea.direction,
          conviction: idea.conviction,
          thesis: idea.thesis,
          catalyst: idea.catalyst,
          overrideValue: overrideValue
        });
      };

      // Save edited position
      const saveEdit = () => {
        const oldIdea = currentIdeas.find(i => i.id === editingId);
        const updatedIdeas = currentIdeas.map(idea => {
          if (idea.id === editingId) {
            let newOverride = idea.sizeOverride;
            if (editForm.overrideValue && parseFloat(editForm.overrideValue) > 0) {
              if (sizingMode === 'shares') {
                newOverride = { type: 'shares', value: parseFloat(editForm.overrideValue) };
              } else {
                newOverride = { type: 'dollars', value: parseFloat(editForm.overrideValue) * 1000000 };
              }
            } else if (editForm.overrideValue === '' || editForm.overrideValue === '0') {
              newOverride = null;
            }
            return {
              ...idea,
              ticker: editForm.ticker.toUpperCase(),
              direction: editForm.direction,
              conviction: Number(editForm.conviction),
              thesis: editForm.thesis,
              catalyst: editForm.catalyst,
              sizeOverride: newOverride
            };
          }
          return idea;
        });
        
        // Log specific changes
        const newIdea = updatedIdeas.find(i => i.id === editingId);
        if (oldIdea && newIdea) {
          const changes = [];
          if (oldIdea.conviction !== Number(editForm.conviction)) changes.push('CONVICTION_CHANGE');
          if (oldIdea.direction !== editForm.direction) changes.push('DIRECTION_CHANGE');
          if (oldIdea.thesis !== editForm.thesis) changes.push('THESIS_CHANGE');
          const action = changes.length > 0 ? changes.join('+') : 'EDIT';
          logChange(action, newIdea, {
            prevConviction: oldIdea.conviction,
            prevDirection: oldIdea.direction,
            prevThesis: oldIdea.thesis
          });
        }
        
        updateIdeas(updatedIdeas);
        setEditingId(null);
        setEditForm({});
      };

      // Cancel edit
      const cancelEdit = () => {
        setEditingId(null);
        setEditForm({});
      };

      // Backtest from tracking date
      const runBacktest = async () => {
        if (!trackingStartDate || currentIdeas.length === 0) {
          alert('Please set a tracking start date and add positions first.');
          return;
        }
        
        setLoading(true);
        
        try {
          // Calculate date range
          const startDate = new Date(trackingStartDate);
          const endDate = new Date();
          const startTimestamp = Math.floor(startDate.getTime() / 1000);
          const endTimestamp = Math.floor(endDate.getTime() / 1000);
          
          
          // Fetch historical data for each position
          const backtestPromises = currentIdeas.map(async (idea) => {
            try {
              const url = `https://query1.finance.yahoo.com/v8/finance/chart/${idea.ticker}?period1=${startTimestamp}&period2=${endTimestamp}&interval=1d`;
              const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
              const response = await fetch(proxyUrl);
              const data = await response.json();
              
              if (data.chart?.result?.[0]) {
                const result = data.chart.result[0];
                const timestamps = result.timestamp || [];
                const closes = result.indicators?.quote?.[0]?.close || [];
                
                if (timestamps.length > 0 && closes.length > 0) {
                  // Filter out null prices
                  const validPrices = [];
                  const validTimestamps = [];
                  
                  for (let i = 0; i < closes.length; i++) {
                    if (closes[i] != null && closes[i] > 0) {
                      validPrices.push(closes[i]);
                      validTimestamps.push(timestamps[i]);
                    }
                  }
                  
                  const historicalStartPrice = validPrices[0] || idea.entryPrice || 100;
                  const historicalEndPrice = validPrices[validPrices.length - 1] || idea.currentPrice || 100;
                  
                  
                  return {
                    ticker: idea.ticker,
                    direction: idea.direction,
                    conviction: idea.conviction,
                    startPrice: historicalStartPrice,
                    endPrice: historicalEndPrice,
                    timestamps: validTimestamps,
                    prices: validPrices
                  };
                }
              }
              
              console.warn(`No data for ${idea.ticker}, using current prices`);
              return {
                ticker: idea.ticker,
                direction: idea.direction,
                conviction: idea.conviction,
                startPrice: idea.entryPrice || 100,
                endPrice: idea.currentPrice || 100,
                timestamps: [],
                prices: []
              };
            } catch (error) {
              console.error(`Error fetching historical data for ${idea.ticker}:`, error);
              return {
                ticker: idea.ticker,
                direction: idea.direction,
                conviction: idea.conviction,
                startPrice: idea.entryPrice || 100,
                endPrice: idea.currentPrice || 100,
                timestamps: [],
                prices: []
              };
            }
          });
          
          const backtestResults = await Promise.all(backtestPromises);
          
          // Update ideas with historical prices as entry prices
          const updatedIdeas = currentIdeas.map((idea, idx) => {
            const result = backtestResults[idx];
            return {
              ...idea,
              entryPrice: result.startPrice,
              currentPrice: result.endPrice
            };
          });
          
          updateIdeas(updatedIdeas);
          
          // Recalculate position sizes from the UPDATED ideas (not stale positionsWithSizes)
          const freshPositionSizes = calculatePositionSizes(updatedIdeas);
          
          // Clear old history and build fresh from this backtest
          const newHistory = [];
          
          // Get SPY historical data
          const spyUrl = `https://query1.finance.yahoo.com/v8/finance/chart/SPY?period1=${startTimestamp}&period2=${endTimestamp}&interval=1d`;
          const spyProxyUrl = `https://corsproxy.io/?${encodeURIComponent(spyUrl)}`;
          const spyResponse = await fetch(spyProxyUrl);
          const spyData = await spyResponse.json();
          
          if (spyData.chart?.result?.[0]) {
            const spyPrices = spyData.chart.result[0].indicators?.quote?.[0]?.close || [];
            const spyTimestamps = spyData.chart.result[0].timestamp || [];
            
            // Find common timestamps across all positions
            const maxLength = Math.min(spyTimestamps.length, ...backtestResults.map(r => r.timestamps.length || spyTimestamps.length));
            
            // Sample every 5 days to avoid too many data points
            for (let i = 0; i < maxLength; i += 5) {
              const timestamp = spyTimestamps[i];
              const spyPrice = spyPrices[i];
              
              if (!spyPrice || spyPrice <= 0) continue;
              
              // Calculate portfolio value at this point in time
              let portfolioValue = 0;
              
              backtestResults.forEach((result, idx) => {
                const idea = updatedIdeas[idx];
                const allocation = freshPositionSizes[idx]?.allocation || 0;
                
                // Map SPY index to position's price array proportionally
                let priceAtTime = result.startPrice;
                if (result.prices.length > 0) {
                  const posIdx = Math.min(
                    Math.floor((i / Math.max(maxLength - 1, 1)) * (result.prices.length - 1)),
                    result.prices.length - 1
                  );
                  priceAtTime = result.prices[posIdx] || result.startPrice;
                }
                
                if (result.startPrice > 0) {
                  const pnl = idea.direction === 'long'
                    ? ((priceAtTime - result.startPrice) / result.startPrice) * allocation
                    : ((result.startPrice - priceAtTime) / result.startPrice) * allocation;
                  
                  portfolioValue += pnl;
                }
              });
              
              newHistory.push({
                date: new Date(timestamp * 1000).toISOString(),
                portfolioReturn: portfolioValue / 1000,
                spyPrice: spyPrice
              });
            }
          }
          
          // Always replace (not append) the performance history
          setPerformanceHistory(newHistory);
          
          alert(`Backtest complete! Updated ${currentIdeas.length} positions with historical data from ${trackingStartDate}.`);
          
        } catch (error) {
          console.error('Backtest error:', error);
          alert(`Error running backtest: ${error.message}. Check console for details.`);
        }
        
        setLoading(false);
      };

      
      // Export to Excel
      const exportToExcel = () => {
        const sortedIdeas = [...positionsWithSizes].sort((a, b) => b.conviction - a.conviction);
        
        const positionsData = sortedIdeas.map(idea => {
          const pnl = idea.direction === 'long'
            ? ((idea.currentPrice - idea.entryPrice) / idea.entryPrice) * idea.allocation
            : ((idea.entryPrice - idea.currentPrice) / idea.entryPrice) * idea.allocation;
          const returns = idea.direction === 'long'
            ? ((idea.currentPrice - idea.entryPrice) / idea.entryPrice) * 100
            : ((idea.entryPrice - idea.currentPrice) / idea.entryPrice) * 100;

          return {
            'Conviction': idea.conviction,
            'Weight (%)': (idea.weight * 100).toFixed(2),
            'Ticker': idea.ticker,
            'Direction': idea.direction.toUpperCase(),
            'Allocation ($)': idea.allocation.toFixed(0),
            'Shares': idea.shares.toFixed(0),
            'Entry Price': idea.entryPrice,
            'Current Price': idea.currentPrice,
            'Entry Date': idea.entryDate,
            'P&L ($)': pnl.toFixed(2),
            'Return (%)': returns.toFixed(2),
            'Thesis': idea.thesis,
            'Catalyst': idea.catalyst
          };
        });

        const metricsData = [
          { 'Metric': 'Portfolio Size', 'Value': '$1,000M (1B GMV)' },
          { 'Metric': 'Deployed Capital', 'Value': `$${metrics.deployed}M` },
          { 'Metric': 'Gross Exposure', 'Value': `$${metrics.grossExposure}M` },
          { 'Metric': 'Net Exposure', 'Value': `${metrics.netExposurePercent}% ($${metrics.netExposure}M)` },
          { 'Metric': 'Batting Average', 'Value': `${metrics.battingAverage}%` },
          { 'Metric': 'Portfolio Alpha', 'Value': `$${metrics.portfolioAlpha}K` },
          { 'Metric': 'Total P&L', 'Value': `$${metrics.totalPnL}K` },
          { 'Metric': 'Sharpe Ratio', 'Value': metrics.sharpe },
          { 'Metric': 'Portfolio Beta', 'Value': metrics.beta },
          { 'Metric': 'Long Exposure', 'Value': `$${metrics.longExposure}M` },
          { 'Metric': 'Short Exposure', 'Value': `$${metrics.shortExposure}M` },
          { 'Metric': 'Active Ideas', 'Value': currentIdeas.length }
        ];

        const wb = XLSX.utils.book_new();
        const wsPositions = XLSX.utils.json_to_sheet(positionsData);
        XLSX.utils.book_append_sheet(wb, wsPositions, 'Positions');
        const wsMetrics = XLSX.utils.json_to_sheet(metricsData);
        XLSX.utils.book_append_sheet(wb, wsMetrics, 'Metrics');

        const timestamp = new Date().toISOString().split('T')[0];
        XLSX.writeFile(wb, `IdeaTracker_${timestamp}.xlsx`);
      };

      // Export to JPEG
      const exportToJPEG = async () => {
        if (!dashboardRef.current) return;

        try {
          const canvas = await html2canvas(dashboardRef.current, {
            backgroundColor: '#0f172a',
            scale: 2,
            logging: false
          });

          const image = canvas.toDataURL('image/jpeg', 0.95);
          const link = document.createElement('a');
          const timestamp = new Date().toISOString().split('T')[0];
          link.download = `IdeaTracker_${timestamp}.jpg`;
          link.href = image;
          link.click();
        } catch (error) {
          console.error('Error exporting to JPEG:', error);
          alert('Error creating screenshot. Please try again.');
        }
      };

      const metrics = calculateMetricsForIdeas(currentIdeas);
      const positionsWithSizes = calculatePositionSizes(currentIdeas);

      // Update charts
      useEffect(() => {
        if (pieChartRef.current) {
          const ctx = pieChartRef.current.getContext('2d');
          if (pieChart.current) pieChart.current.destroy();
          pieChart.current = new Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: ['Long', 'Short'],
              datasets: [{
                data: [parseFloat(metrics.longExposure), parseFloat(metrics.shortExposure)],
                backgroundColor: ['#10b981', '#ef4444'],
                borderWidth: 0
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: { legend: { labels: { color: '#cbd5e1' } } }
            }
          });
        }

        if (barChartRef.current) {
          const ctx = barChartRef.current.getContext('2d');
          if (barChart.current) barChart.current.destroy();
          const convictionData = [1, 2, 3, 4, 5].map(conv => 
            currentIdeas.filter(i => i.conviction === conv).length
          );
          barChart.current = new Chart(ctx, {
            type: 'bar',
            data: {
              labels: ['1', '2', '3', '4', '5'],
              datasets: [{
                label: '# of Ideas',
                data: convictionData,
                backgroundColor: '#3b82f6',
                borderWidth: 0
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: { beginAtZero: true, ticks: { color: '#94a3b8', stepSize: 1 }, grid: { color: '#334155' } },
                x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
              },
              plugins: { legend: { display: false } }
            }
          });
        }

        // Performance comparison chart
        if (performanceChartRef.current && performanceHistory.length > 1) {
          const ctx = performanceChartRef.current.getContext('2d');
          if (performanceChart.current) performanceChart.current.destroy();
          
          const startSnapshot = performanceHistory[0];
          const labels = performanceHistory.map(s => new Date(s.date).toLocaleDateString());
          // portfolioReturn is PnL in $K (PnL / 1000). Convert to % of GMV.
          // PnL in dollars = portfolioReturn * 1000. % return = (PnL / portfolioGMV) * 100
          const portfolioReturns = performanceHistory.map(s => {
            const pnlDollars = (s.portfolioReturn - startSnapshot.portfolioReturn) * 1000;
            return portfolioGMV > 0 ? (pnlDollars / portfolioGMV) * 100 : 0;
          });
          const marketReturns = performanceHistory.map(s => 
            ((s.spyPrice - startSnapshot.spyPrice) / startSnapshot.spyPrice) * 100
          );
          
          performanceChart.current = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Portfolio',
                  data: portfolioReturns,
                  borderColor: '#3b82f6',
                  backgroundColor: 'rgba(59, 130, 246, 0.1)',
                  tension: 0.4,
                  fill: true
                },
                {
                  label: 'SPY',
                  data: marketReturns,
                  borderColor: '#94a3b8',
                  backgroundColor: 'rgba(148, 163, 184, 0.1)',
                  tension: 0.4,
                  fill: true
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: { 
                  ticks: { 
                    color: '#94a3b8',
                    callback: (value) => value.toFixed(1) + '%'
                  }, 
                  grid: { color: '#334155' } 
                },
                x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
              },
              plugins: { 
                legend: { labels: { color: '#cbd5e1' } },
                tooltip: {
                  callbacks: {
                    label: (context) => {
                      return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                    }
                  }
                }
              }
            }
          });
        }

        return () => {
          if (pieChart.current) pieChart.current.destroy();
          if (barChart.current) barChart.current.destroy();
          if (performanceChart.current) performanceChart.current.destroy();
        };
      }, [currentIdeas, metrics, performanceHistory]);

      const COLORS = { 1: '#94a3b8', 2: '#64748b', 3: '#3b82f6', 4: '#f59e0b', 5: '#ef4444' };

      // ============================================================
      // ANALYTICS ENGINE
      // ============================================================
      const computeAnalytics = () => {
        if (!positionsWithSizes || positionsWithSizes.length === 0) return null;

        const positions = positionsWithSizes.map(idea => {
          const entry = idea.entryPrice || 100;
          const current = idea.currentPrice || entry;
          const allocation = idea.allocation || 0;
          const ret = idea.direction === 'long'
            ? (entry > 0 ? (current - entry) / entry : 0)
            : (entry > 0 ? (entry - current) / entry : 0);
          const pnl = ret * allocation;
          const weight = portfolioGMV > 0 ? allocation / portfolioGMV : 0;
          return { ...idea, ret, pnl, calcWeight: weight, allocation, entry, current };
        });

        const longs = positions.filter(p => p.direction === 'long');
        const shorts = positions.filter(p => p.direction === 'short');
        const totalPnL = positions.reduce((s, p) => s + p.pnl, 0);
        const portfolioReturn = portfolioGMV > 0 ? totalPnL / portfolioGMV : 0;

        // --- Exposure Analysis ---
        const longExposure = longs.reduce((s, p) => s + p.allocation, 0);
        const shortExposure = shorts.reduce((s, p) => s + p.allocation, 0);
        const grossExposure = longExposure + shortExposure;
        const netExposure = longExposure - shortExposure;
        const longPct = portfolioGMV > 0 ? (longExposure / portfolioGMV) * 100 : 0;
        const shortPct = portfolioGMV > 0 ? (shortExposure / portfolioGMV) * 100 : 0;
        const grossPct = portfolioGMV > 0 ? (grossExposure / portfolioGMV) * 100 : 0;
        const netPct = portfolioGMV > 0 ? (netExposure / portfolioGMV) * 100 : 0;
        const leverage = portfolioGMV > 0 ? grossExposure / portfolioGMV : 0;

        // --- Concentration (HHI) ---
        const weights = positions.map(p => p.calcWeight);
        const hhi = weights.reduce((s, w) => s + w * w, 0);
        const effectiveN = hhi > 0 ? 1 / hhi : 0;
        const sortedByWeight = [...positions].sort((a, b) => Math.abs(b.calcWeight) - Math.abs(a.calcWeight));
        const top1Pct = sortedByWeight[0] ? Math.abs(sortedByWeight[0].calcWeight) * 100 : 0;
        const top3Pct = sortedByWeight.slice(0, 3).reduce((s, p) => s + Math.abs(p.calcWeight) * 100, 0);
        const top5Pct = sortedByWeight.slice(0, 5).reduce((s, p) => s + Math.abs(p.calcWeight) * 100, 0);

        // --- Position Attribution ---
        const attribution = positions.map(p => ({
          ticker: p.ticker,
          direction: p.direction,
          conviction: p.conviction,
          weight: p.calcWeight * 100,
          returnPct: p.ret * 100,
          pnl: p.pnl,
          contribution: portfolioGMV > 0 ? (p.pnl / portfolioGMV) * 100 : 0,
          allocation: p.allocation
        })).sort((a, b) => b.contribution - a.contribution);

        // --- Risk Metrics from Performance History ---
        let returns = [];
        let drawdownSeries = [];
        let maxDrawdown = 0;
        let volatility = 0;
        let sharpe = 0;
        let sortino = 0;
        let calmar = 0;
        let var95 = 0;
        let var99 = 0;
        let cvar95 = 0;
        let winRate = 0;
        let avgWin = 0;
        let avgLoss = 0;
        let profitFactor = 0;
        let bestDay = 0;
        let worstDay = 0;
        let skewness = 0;
        let kurtosis = 0;

        if (performanceHistory.length > 2) {
          // Compute period-over-period returns from backtest snapshots
          // performanceHistory stores cumulative P&L (portfolioReturn * 1000 = $ P&L)
          for (let i = 1; i < performanceHistory.length; i++) {
            const prevPnL = performanceHistory[i - 1].portfolioReturn * 1000;
            const curPnL = performanceHistory[i].portfolioReturn * 1000;
            const periodReturn = portfolioGMV > 0 ? (curPnL - prevPnL) / portfolioGMV : 0;
            returns.push(periodReturn);
          }

          const n = returns.length;
          if (n < 2) { /* not enough data */ } else {
            const meanRet = returns.reduce((s, r) => s + r, 0) / n;
            const variance = returns.reduce((s, r) => s + (r - meanRet) ** 2, 0) / (n - 1);
            volatility = Math.sqrt(variance);
            
            // Determine actual average interval between backtest snapshots (exclude live)
            const backtestOnly = performanceHistory.filter(h => !h.isLive);
            const firstDate = new Date(backtestOnly[0]?.date || performanceHistory[0].date).getTime();
            const lastBacktestDate = new Date(backtestOnly[backtestOnly.length - 1]?.date || performanceHistory[performanceHistory.length - 1].date).getTime();
            const totalDays = (lastBacktestDate - firstDate) / (1000 * 60 * 60 * 24);
            const backtestReturns = Math.max(backtestOnly.length - 1, 1);
            const avgIntervalDays = totalDays / backtestReturns;
            // Periods per year = 252 trading days / avg interval
            const periodsPerYear = avgIntervalDays > 0 ? 252 / avgIntervalDays : 52;
            
            const annFactor = Math.sqrt(periodsPerYear);
            const annVol = volatility * annFactor;
            const annReturn = meanRet * periodsPerYear;
            const rf = 0.05; // risk-free rate
            sharpe = annVol > 0 ? (annReturn - rf) / annVol : 0;

            // Sortino (downside deviation)
            // Correct: use min(r, 0)^2 for ALL returns, divide by N
            const downsideSumSq = returns.reduce((s, r) => s + Math.min(r, 0) ** 2, 0);
            const downsideDev = Math.sqrt(downsideSumSq / n) * annFactor;
            sortino = downsideDev > 0 ? (annReturn - rf) / downsideDev : 0;

            // Drawdown series (compounded)
            let cumulativeGrowth = 1;
            let peakGrowth = 1;
            drawdownSeries = [];
            returns.forEach(r => {
              cumulativeGrowth *= (1 + r);
              if (cumulativeGrowth > peakGrowth) peakGrowth = cumulativeGrowth;
              const dd = (cumulativeGrowth - peakGrowth) / peakGrowth;
              drawdownSeries.push(dd * 100);
              if (dd < maxDrawdown) maxDrawdown = dd;
            });
            
            calmar = maxDrawdown < 0 ? annReturn / Math.abs(maxDrawdown) : 0;

            // VaR (historical simulation)
            const sortedReturns = [...returns].sort((a, b) => a - b);
            const idx95 = Math.max(0, Math.ceil(n * 0.05) - 1);
            const idx99 = Math.max(0, Math.ceil(n * 0.01) - 1);
            var95 = sortedReturns[idx95] || 0;
            var99 = sortedReturns[idx99] || sortedReturns[0] || 0;
            // CVaR = average of all returns at or below the VaR threshold
            const cvarSlice = sortedReturns.filter(r => r <= var95);
            cvar95 = cvarSlice.length > 0 ? cvarSlice.reduce((s, r) => s + r, 0) / cvarSlice.length : var95;

            // Win/loss stats
            const wins = returns.filter(r => r > 0);
            const losses = returns.filter(r => r < 0);
            winRate = n > 0 ? (wins.length / n) * 100 : 0;
            avgWin = wins.length > 0 ? wins.reduce((s, r) => s + r, 0) / wins.length : 0;
            avgLoss = losses.length > 0 ? losses.reduce((s, r) => s + r, 0) / losses.length : 0;
            const totalWins = wins.reduce((s, r) => s + r, 0);
            const totalLosses = Math.abs(losses.reduce((s, r) => s + r, 0));
            profitFactor = totalLosses > 0 ? totalWins / totalLosses : totalWins > 0 ? Infinity : 0;
            bestDay = Math.max(...returns);
            worstDay = Math.min(...returns);

            // Skewness and Kurtosis
            const stdDev = Math.sqrt(variance);
            if (n > 2 && stdDev > 0) {
              const m3 = returns.reduce((s, r) => s + ((r - meanRet) / stdDev) ** 3, 0) / n;
              skewness = m3;
              const m4 = returns.reduce((s, r) => s + ((r - meanRet) / stdDev) ** 4, 0) / n;
              kurtosis = m4 - 3; // excess kurtosis
            }
          }
        }

        // --- Factor Proxies (heuristic from position characteristics) ---
        // Momentum: weighted avg return
        const momentumScore = positions.reduce((s, p) => s + p.calcWeight * p.ret, 0);
        // Size factor: conviction-weighted (higher conviction = more concentrated = smaller effective universe)
        const avgConviction = positions.reduce((s, p) => s + p.conviction, 0) / positions.length;
        // Directional bias
        const directionalBias = netExposure / (grossExposure || 1);

        // --- Conviction Analysis ---
        const convictionBuckets = [1, 2, 3, 4, 5].map(c => {
          const bucket = positions.filter(p => p.conviction === c);
          const bucketAllocation = bucket.reduce((s, p) => s + p.allocation, 0);
          const bucketPnL = bucket.reduce((s, p) => s + p.pnl, 0);
          const bucketReturn = bucketAllocation > 0 ? bucketPnL / bucketAllocation : 0;
          const count = bucket.length;
          const wins = bucket.filter(p => p.pnl > 0).length;
          return { 
            conviction: c, count, 
            allocation: bucketAllocation,
            pnl: bucketPnL, 
            returnPct: bucketReturn * 100,
            winRate: count > 0 ? (wins / count) * 100 : 0
          };
        });

        // --- Stress Scenarios ---
        const scenarios = [
          { name: 'ðŸ“‰ Market Crash (-20%)', marketMove: -0.20, description: 'Broad equity selloff' },
          { name: 'ðŸ“ˆ Bull Rally (+15%)', marketMove: 0.15, description: 'Strong market rally' },
          { name: 'âš¡ Vol Spike (-10%)', marketMove: -0.10, description: 'Sudden volatility event' },
          { name: 'ðŸ”„ Rotation (-5% L, +5% S)', marketMove: -0.05, description: 'Factor rotation', isRotation: true },
          { name: 'ðŸ’¥ Black Swan (-35%)', marketMove: -0.35, description: 'Extreme tail event' },
          { name: 'ðŸ“Š Flat (+0%)', marketMove: 0, description: 'Carry/theta scenario' },
        ];

        const stressResults = scenarios.map(scenario => {
          let scenarioPnL = 0;
          positions.forEach(p => {
            const dirMultiplier = p.direction === 'long' ? 1.0 : -1.0;
            const move = scenario.isRotation 
              ? (p.direction === 'long' ? scenario.marketMove : -scenario.marketMove)
              : scenario.marketMove * dirMultiplier;
            // Higher conviction positions assumed to have higher beta dispersion
            const convictionMultiplier = 0.8 + (p.conviction / 5) * 0.4;
            scenarioPnL += p.allocation * move * convictionMultiplier;
          });
          return {
            ...scenario,
            pnl: scenarioPnL,
            returnPct: portfolioGMV > 0 ? (scenarioPnL / portfolioGMV) * 100 : 0
          };
        });

        // --- Risk Contribution ---
        const totalAbsContribution = positions.reduce((s, p) => s + Math.abs(p.pnl), 0);
        const riskContribution = positions.map(p => ({
          ticker: p.ticker,
          direction: p.direction,
          weight: p.calcWeight * 100,
          pnl: p.pnl,
          riskShare: totalAbsContribution > 0 ? (Math.abs(p.pnl) / totalAbsContribution) * 100 : 0,
          marginalVar: portfolioGMV > 0 ? (Math.abs(p.ret) * p.calcWeight * 1.65) : 0 // parametric approx
        })).sort((a, b) => b.riskShare - a.riskShare);

        return {
          positions, longs, shorts,
          longExposure, shortExposure, grossExposure, netExposure,
          longPct, shortPct, grossPct, netPct, leverage,
          hhi, effectiveN, top1Pct, top3Pct, top5Pct,
          attribution,
          returns, drawdownSeries, maxDrawdown: maxDrawdown * 100,
          volatility: volatility * 100, annualizedVol: volatility > 0 ? (() => {
            const bto = performanceHistory.filter(h => !h.isLive);
            const fd = new Date(bto[0]?.date || performanceHistory[0]?.date).getTime();
            const ld = new Date(bto[bto.length - 1]?.date || performanceHistory[performanceHistory.length - 1]?.date).getTime();
            const td = (ld - fd) / (1000 * 60 * 60 * 24);
            const nr = Math.max(bto.length - 1, 1);
            const ai = td / nr;
            const ppy = ai > 0 ? 252 / ai : 52;
            return volatility * Math.sqrt(ppy) * 100;
          })() : 0,
          sharpe, sortino, calmar,
          var95: var95 * 100, var99: var99 * 100, cvar95: cvar95 * 100,
          winRate, avgWin: avgWin * 100, avgLoss: avgLoss * 100, profitFactor,
          bestDay: bestDay * 100, worstDay: worstDay * 100,
          skewness, kurtosis,
          momentumScore: momentumScore * 100, avgConviction, directionalBias: directionalBias * 100,
          convictionBuckets,
          stressResults,
          riskContribution,
          totalPnL, portfolioReturn: portfolioReturn * 100
        };
      };

      const analytics = computeAnalytics();

      // Analytics chart refs
      const drawdownChartRef = useRef(null);
      const drawdownChart = useRef(null);
      const returnDistChartRef = useRef(null);
      const returnDistChart = useRef(null);
      const attributionChartRef = useRef(null);
      const attributionChart = useRef(null);
      const convictionPerfChartRef = useRef(null);
      const convictionPerfChart = useRef(null);
      const riskContribChartRef = useRef(null);
      const riskContribChart = useRef(null);
      const exposureChartRef = useRef(null);
      const exposureChart = useRef(null);

      // Render analytics charts
      useEffect(() => {
        if (activeTab !== 'analytics' || !analytics) return;

        // Small delay to let DOM render
        const timer = setTimeout(() => {
          // Drawdown chart
          if (drawdownChartRef.current && analytics.drawdownSeries.length > 0) {
            const ctx = drawdownChartRef.current.getContext('2d');
            if (drawdownChart.current) drawdownChart.current.destroy();
            drawdownChart.current = new Chart(ctx, {
              type: 'line',
              data: {
                labels: analytics.drawdownSeries.map((_, i) => i + 1),
                datasets: [{
                  label: 'Drawdown',
                  data: analytics.drawdownSeries,
                  borderColor: '#ef4444',
                  backgroundColor: 'rgba(239, 68, 68, 0.15)',
                  fill: true,
                  tension: 0.3,
                  pointRadius: 0
                }]
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { ticks: { color: '#94a3b8', callback: v => v.toFixed(1) + '%' }, grid: { color: '#1e293b' } },
                  x: { display: false }
                },
                plugins: { legend: { display: false } }
              }
            });
          }

          // Return Distribution
          if (returnDistChartRef.current && analytics.returns.length > 0) {
            const ctx = returnDistChartRef.current.getContext('2d');
            if (returnDistChart.current) returnDistChart.current.destroy();
            const rets = analytics.returns.map(r => r * 100);
            const min = Math.floor(Math.min(...rets));
            const max = Math.ceil(Math.max(...rets));
            const bucketSize = Math.max(0.5, (max - min) / 15);
            const buckets = [];
            const labels = [];
            for (let b = min; b < max; b += bucketSize) {
              const count = rets.filter(r => r >= b && r < b + bucketSize).length;
              buckets.push(count);
              labels.push(b.toFixed(1) + '%');
            }
            returnDistChart.current = new Chart(ctx, {
              type: 'bar',
              data: {
                labels,
                datasets: [{
                  label: 'Frequency',
                  data: buckets,
                  backgroundColor: buckets.map((_, i) => {
                    const val = parseFloat(labels[i]);
                    return val >= 0 ? 'rgba(16, 185, 129, 0.6)' : 'rgba(239, 68, 68, 0.6)';
                  }),
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { ticks: { color: '#94a3b8', stepSize: 1 }, grid: { color: '#1e293b' } },
                  x: { ticks: { color: '#94a3b8', maxRotation: 45 }, grid: { display: false } }
                },
                plugins: { legend: { display: false } }
              }
            });
          }

          // Attribution waterfall
          if (attributionChartRef.current && analytics.attribution.length > 0) {
            const ctx = attributionChartRef.current.getContext('2d');
            if (attributionChart.current) attributionChart.current.destroy();
            const sorted = [...analytics.attribution].sort((a, b) => b.contribution - a.contribution);
            attributionChart.current = new Chart(ctx, {
              type: 'bar',
              data: {
                labels: sorted.map(a => a.ticker),
                datasets: [{
                  label: 'Contribution (%)',
                  data: sorted.map(a => a.contribution),
                  backgroundColor: sorted.map(a => a.contribution >= 0 ? '#10b981' : '#ef4444'),
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                indexAxis: 'y',
                scales: {
                  x: { ticks: { color: '#94a3b8', callback: v => v.toFixed(1) + '%' }, grid: { color: '#1e293b' } },
                  y: { ticks: { color: '#cbd5e1', font: { family: 'monospace', weight: 'bold' } }, grid: { display: false } }
                },
                plugins: { legend: { display: false } }
              }
            });
          }

          // Conviction Performance
          if (convictionPerfChartRef.current) {
            const ctx = convictionPerfChartRef.current.getContext('2d');
            if (convictionPerfChart.current) convictionPerfChart.current.destroy();
            const buckets = analytics.convictionBuckets.filter(b => b.count > 0);
            convictionPerfChart.current = new Chart(ctx, {
              type: 'bar',
              data: {
                labels: buckets.map(b => b.conviction + '/5'),
                datasets: [
                  {
                    label: 'Return %',
                    data: buckets.map(b => b.returnPct),
                    backgroundColor: buckets.map(b => b.returnPct >= 0 ? '#3b82f6' : '#ef4444'),
                    borderWidth: 0
                  }
                ]
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { ticks: { color: '#94a3b8', callback: v => v.toFixed(1) + '%' }, grid: { color: '#1e293b' } },
                  x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                },
                plugins: { legend: { display: false } }
              }
            });
          }

          // Risk Contribution pie
          if (riskContribChartRef.current && analytics.riskContribution.length > 0) {
            const ctx = riskContribChartRef.current.getContext('2d');
            if (riskContribChart.current) riskContribChart.current.destroy();
            const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4', '#84cc16', '#f97316', '#6366f1'];
            riskContribChart.current = new Chart(ctx, {
              type: 'doughnut',
              data: {
                labels: analytics.riskContribution.map(r => r.ticker),
                datasets: [{
                  data: analytics.riskContribution.map(r => r.riskShare),
                  backgroundColor: analytics.riskContribution.map((_, i) => colors[i % colors.length]),
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                plugins: { 
                  legend: { position: 'right', labels: { color: '#cbd5e1', font: { size: 11 } } },
                  tooltip: { callbacks: { label: (c) => c.label + ': ' + c.parsed.toFixed(1) + '%' } }
                }
              }
            });
          }

          // Exposure breakdown bar
          if (exposureChartRef.current) {
            const ctx = exposureChartRef.current.getContext('2d');
            if (exposureChart.current) exposureChart.current.destroy();
            exposureChart.current = new Chart(ctx, {
              type: 'bar',
              data: {
                labels: ['Long', 'Short', 'Net', 'Gross'],
                datasets: [{
                  data: [analytics.longPct, -analytics.shortPct, analytics.netPct, analytics.grossPct],
                  backgroundColor: ['#10b981', '#ef4444', '#3b82f6', '#8b5cf6'],
                  borderWidth: 0
                }]
              },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { ticks: { color: '#94a3b8', callback: v => v.toFixed(0) + '%' }, grid: { color: '#1e293b' } },
                  x: { ticks: { color: '#94a3b8' }, grid: { display: false } }
                },
                plugins: { legend: { display: false } }
              }
            });
          }

        }, 100);

        return () => {
          clearTimeout(timer);
          [drawdownChart, returnDistChart, attributionChart, convictionPerfChart, riskContribChart, exposureChart].forEach(ref => {
            if (ref.current) { ref.current.destroy(); ref.current = null; }
          });
        };
      }, [activeTab, analytics, performanceHistory]);

      // ============================================================
      // ANALYTICS TAB COMPONENT
      // ============================================================
      const AnalyticsTab = () => {
        if (!analytics || positionsWithSizes.length === 0) {
          return (
            <div className="flex flex-col items-center justify-center py-32 text-slate-400">
              <div className="text-6xl mb-6">ðŸ“Š</div>
              <h2 className="text-2xl font-bold text-slate-300 mb-2">No Positions to Analyze</h2>
              <p className="text-sm">Add positions and run a backtest to unlock full portfolio analytics.</p>
              <button onClick={() => setActiveTab('tracker')} className="mt-6 px-6 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-white font-medium">
                â† Go to Tracker
              </button>
            </div>
          );
        }

        const a = analytics;
        const hasHistory = performanceHistory.length > 2;

        const MetricCard = ({ label, value, sub, color, size, tip }) => (
          <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
            <span className="text-slate-400 text-xs uppercase tracking-wider inline-flex items-center">{label}{tip && <InfoTip text={tip} />}</span>
            <p className={`${size === 'lg' ? 'text-2xl' : 'text-xl'} font-bold font-mono mt-1 ${color || 'text-white'}`}>{value}</p>
            {sub && <p className="text-xs text-slate-500 mt-1">{sub}</p>}
          </div>
        );

        const SectionHeader = ({ icon, title, subtitle }) => (
          <div className="mb-4 mt-8 first:mt-0">
            <h2 className="text-xl font-bold text-white flex items-center gap-2">{icon} {title}</h2>
            {subtitle && <p className="text-sm text-slate-400 mt-1">{subtitle}</p>}
          </div>
        );

        return (
          <div className="space-y-2">
            {/* ===== PORTFOLIO OVERVIEW ===== */}
            <SectionHeader icon="ðŸŽ¯" title="Portfolio Overview" subtitle="High-level P&L and return summary" />
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
              <MetricCard label="Total P&L" tip="Sum of unrealized P&L across all positions.
âœ… Positive = making money
âŒ Negative = losing money" value={`${a.totalPnL >= 0 ? '+' : ''}$${fmt((a.totalPnL/1000).toFixed(2))}K`} color={a.totalPnL >= 0 ? 'text-green-400' : 'text-red-400'} size="lg" />
              <MetricCard label="Portfolio Return" tip="Weighted average return of all positions.
âœ… Above +5% is solid
âš ï¸ Below 0% needs review" value={`${a.portfolioReturn >= 0 ? '+' : ''}${a.portfolioReturn.toFixed(2)}%`} color={a.portfolioReturn >= 0 ? 'text-green-400' : 'text-red-400'} size="lg" />
              <MetricCard label="Active Positions" tip="Total open positions.
ðŸ“ 20-40 is typical for a diversified L/S book
âš ï¸ <10 may be too concentrated" value={a.positions.length} sub={`${a.longs.length}L / ${a.shorts.length}S`} />
              <MetricCard label="Avg Conviction" tip="Average conviction across all positions (1-5 scale).
âœ… 3.5+ = high conviction book
âš ï¸ Below 2.5 = consider pruning low conviction names" value={`${a.avgConviction.toFixed(1)} / 5`} sub={a.avgConviction >= 4 ? 'High conviction book' : a.avgConviction >= 3 ? 'Moderate conviction' : 'Lower conviction'} />
            </div>

            {/* ===== EXPOSURE ANALYSIS ===== */}
            <SectionHeader icon="âš–ï¸" title="Exposure Analysis" subtitle="Long/short breakdown, leverage, and directional bias" />
            <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3">
              <MetricCard label="Long Exposure" tip="Total capital allocated to long positions as % of GMV.
ðŸ“ Typical L/S fund: 80-130%
âš ï¸ >150% is aggressive" value={`${a.longPct.toFixed(1)}%`} sub={`$${fmt((a.longExposure/1e6).toFixed(1))}M`} color="text-green-400" />
              <MetricCard label="Short Exposure" tip="Total capital in short positions as % of GMV.
ðŸ“ Typical L/S fund: 30-70%
âš ï¸ <20% = very limited hedging" value={`${a.shortPct.toFixed(1)}%`} sub={`$${fmt((a.shortExposure/1e6).toFixed(1))}M`} color="text-red-400" />
              <MetricCard label="Net Exposure" tip="Long minus Short exposure. Measures directional market bet.
ðŸ“ +30% to +70% is typical
0% = market neutral
âš ï¸ >90% = very directional" value={`${a.netPct >= 0 ? '+' : ''}${a.netPct.toFixed(1)}%`} sub={`$${fmt((a.netExposure/1e6).toFixed(1))}M`} color="text-blue-400" />
              <MetricCard label="Gross Exposure" tip="Long plus Short exposure. Measures total capital deployed.
ðŸ“ 100-180% is typical
âš ï¸ >200% = high leverage" value={`${a.grossPct.toFixed(1)}%`} sub={`$${fmt((a.grossExposure/1e6).toFixed(1))}M`} />
              <MetricCard label="Leverage" tip="Gross exposure divided by GMV.
ðŸ“ 1.0-1.5x is moderate
âš ï¸ >2x is high leverage
âŒ >3x is dangerous" value={`${a.leverage.toFixed(2)}x`} sub={a.leverage > 2 ? 'âš ï¸ High leverage' : 'Within bounds'} color={a.leverage > 2 ? 'text-yellow-400' : 'text-white'} />
              <MetricCard label="Directional Bias" tip="Net exposure as % of gross. How directional is the book?
ðŸ“ Â±30% = moderately directional
0% = perfectly hedged
âš ï¸ >70% = very one-sided" value={`${a.directionalBias >= 0 ? '+' : ''}${a.directionalBias.toFixed(1)}%`} sub={Math.abs(a.directionalBias) > 70 ? 'Highly directional' : 'Balanced'} />
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
              <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                <h3 className="text-sm font-semibold text-slate-300 mb-3">Exposure Breakdown (% of GMV)</h3>
                <div style={{ height: '200px' }}><canvas ref={exposureChartRef}></canvas></div>
              </div>
              <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                <h3 className="text-sm font-semibold text-slate-300 mb-3">Risk Contribution by Position</h3>
                <div style={{ height: '200px' }}><canvas ref={riskContribChartRef}></canvas></div>
              </div>
            </div>

            {/* ===== CONCENTRATION ===== */}
            <SectionHeader icon="ðŸ”" title="Concentration Analysis" subtitle="Portfolio diversification and position sizing" />
            <div className="grid grid-cols-2 md:grid-cols-5 gap-3">
              <MetricCard label="HHI Index" tip="Herfindahl-Hirschman Index. Measures portfolio concentration.
ðŸ“ <1500 = diversified
âš ï¸ 1500-2500 = moderate concentration
âŒ >2500 = highly concentrated" value={`${(a.hhi * 10000).toFixed(0)}`} sub={a.hhi > 0.25 ? 'âš ï¸ Concentrated' : a.hhi > 0.15 ? 'Moderate' : 'Diversified'} color={a.hhi > 0.25 ? 'text-yellow-400' : 'text-white'} />
              <MetricCard label="Effective # Positions" tip="Equivalent number of equally-weighted positions (1/HHI).
ðŸ“ Higher = more diversified
âš ï¸ <5 = very concentrated portfolio" value={a.effectiveN.toFixed(1)} sub={`of ${a.positions.length} actual`} />
              <MetricCard label="Top 1 Weight" tip="Largest single position weight.
ðŸ“ <10% is well diversified
âš ï¸ >15% is a big single-name bet
âŒ >25% = dangerously concentrated" value={`${a.top1Pct.toFixed(1)}%`} sub={a.positions.sort((x,y) => Math.abs(y.calcWeight) - Math.abs(x.calcWeight))[0]?.ticker || ''} color={a.top1Pct > 30 ? 'text-yellow-400' : 'text-white'} />
              <MetricCard label="Top 3 Weight" tip="Combined weight of 3 largest positions.
ðŸ“ <30% is diversified
âš ï¸ >50% = top-heavy portfolio" value={`${a.top3Pct.toFixed(1)}%`} sub="Combined" />
              <MetricCard label="Top 5 Weight" tip="Combined weight of 5 largest positions.
ðŸ“ <50% is healthy
âš ï¸ >70% = most P&L from 5 names" value={`${a.top5Pct.toFixed(1)}%`} sub="Combined" />
            </div>

            {/* ===== RISK METRICS ===== */}
            <SectionHeader icon="ðŸ›¡ï¸" title="Risk Metrics" subtitle={hasHistory ? "Calculated from backtest performance history" : "âš ï¸ Run a backtest to compute risk metrics from historical returns"} />
            {hasHistory ? (
              <>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  <MetricCard label="Annualized Vol" tip="Standard deviation of returns, annualized.
ðŸ“ 10-15% is moderate
âš ï¸ >25% is high volatility
Lower is generally better for risk-adjusted returns." value={`${a.annualizedVol.toFixed(2)}%`} sub="Annualized std dev" />
                  <MetricCard label="Sharpe Ratio" tip="Return per unit of total risk (excess return / vol).
âœ… >1.0 = good
âœ… >1.5 = very good
âœ… >2.0 = excellent
âš ï¸ <0.5 = poor risk-adjusted returns" value={a.sharpe.toFixed(2)} sub="Risk-adjusted return" color={a.sharpe > 1 ? 'text-green-400' : a.sharpe > 0.5 ? 'text-yellow-400' : 'text-red-400'} />
                  <MetricCard label="Sortino Ratio" tip="Like Sharpe but only penalizes downside volatility.
âœ… >1.5 = good
âœ… >2.0 = very good
âœ… >3.0 = excellent
Higher than Sharpe means upside vol > downside vol (good)." value={a.sortino.toFixed(2)} sub="Downside risk-adj" color={a.sortino > 1.5 ? 'text-green-400' : a.sortino > 0.7 ? 'text-yellow-400' : 'text-red-400'} />
                  <MetricCard label="Calmar Ratio" tip="Annualized return divided by max drawdown.
âœ… >1.0 = return exceeds worst DD
âœ… >3.0 = excellent
âš ï¸ <0.5 = drawdowns too large relative to returns" value={a.calmar.toFixed(2)} sub="Return / Max DD" />
                </div>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mt-3">
                  <MetricCard label="Max Drawdown" tip="Largest peak-to-trough decline.
ðŸ“ -5% to -15% is typical for L/S
âš ï¸ >-20% is a significant drawdown
âŒ >-30% may trigger investor redemptions" value={`${a.maxDrawdown.toFixed(2)}%`} sub="Peak-to-trough" color="text-red-400" />
                  <MetricCard label="VaR (95%)" tip="Value at Risk â€” 95% confidence you won't lose more than this in a single period.
ðŸ“ -1% to -3% is normal
âš ï¸ >-5% is high risk" value={`${a.var95.toFixed(2)}%`} sub="1-period value at risk" color="text-yellow-400" />
                  <MetricCard label="VaR (99%)" tip="Value at Risk â€” 99% confidence worst-case single period loss.
Used for tail risk management.
âš ï¸ Should be manageable even at 99% level" value={`${a.var99.toFixed(2)}%`} sub="Extreme tail risk" color="text-red-400" />
                  <MetricCard label="CVaR (95%)" tip="Conditional VaR (Expected Shortfall). Average loss in the worst 5% of periods.
More conservative than VaR â€” captures tail risk.
âš ï¸ If much worse than VaR, you have fat tails." value={`${a.cvar95.toFixed(2)}%`} sub="Expected shortfall" color="text-red-400" />
                </div>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mt-3">
                  <MetricCard label="Win Rate" tip="Percentage of periods with positive returns.
âœ… >55% is good
âœ… >60% is very good
ðŸ“ Even 45-50% can be profitable with good risk/reward" value={`${a.winRate.toFixed(1)}%`} sub="% positive periods" color={a.winRate > 55 ? 'text-green-400' : 'text-white'} />
                  <MetricCard label="Profit Factor" tip="Total profits / total losses.
âœ… >1.5 = good
âœ… >2.0 = excellent
âš ï¸ <1.0 = losing money overall" value={a.profitFactor === Infinity ? 'âˆž' : a.profitFactor.toFixed(2)} sub="Gross win / gross loss" color={a.profitFactor > 1.5 ? 'text-green-400' : 'text-white'} />
                  <MetricCard label="Best Period" tip="Highest single-period return.
Shows upside potential.
ðŸ“ 2-5% for weekly periods is typical." value={`+${a.bestDay.toFixed(2)}%`} color="text-green-400" />
                  <MetricCard label="Worst Period" tip="Largest single-period loss.
Shows downside risk.
âš ï¸ If much larger than best period, risk is asymmetric." value={`${a.worstDay.toFixed(2)}%`} color="text-red-400" />
                </div>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mt-3">
                  <MetricCard label="Avg Win" tip="Average return during winning periods.
ðŸ“ Compare to Avg Loss â€” want Avg Win > Avg Loss." value={`+${a.avgWin.toFixed(3)}%`} color="text-green-400" />
                  <MetricCard label="Avg Loss" tip="Average return during losing periods.
ðŸ“ Smaller losses = better risk management.
âœ… Avg Win/Avg Loss > 1.5 is good." value={`${a.avgLoss.toFixed(3)}%`} color="text-red-400" />
                  <MetricCard label="Skewness" tip="Distribution asymmetry of returns.
âœ… >0 = right-skewed (more upside)
âš ï¸ <0 = left-skewed (fat left tail = crash risk)
ðŸ“ 0 = symmetric (normal)." value={a.skewness.toFixed(2)} sub={a.skewness > 0 ? 'Right-skewed (good)' : 'Left-skewed (tail risk)'} color={a.skewness > 0 ? 'text-green-400' : 'text-yellow-400'} />
                  <MetricCard label="Excess Kurtosis" tip="Measures tail fatness of return distribution.
ðŸ“ 0 = normal distribution
âš ï¸ >1 = fat tails (more extreme events)
âŒ >3 = very fat tails â€” extreme events more likely." value={a.kurtosis.toFixed(2)} sub={a.kurtosis > 1 ? 'âš ï¸ Fat tails' : 'Normal-ish tails'} color={a.kurtosis > 1 ? 'text-yellow-400' : 'text-white'} />
                </div>

                {/* Drawdown & Distribution Charts */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">Drawdown Curve</h3>
                    <div style={{ height: '220px' }}><canvas ref={drawdownChartRef}></canvas></div>
                  </div>
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">Return Distribution</h3>
                    <div style={{ height: '220px' }}><canvas ref={returnDistChartRef}></canvas></div>
                  </div>
                </div>
              </>
            ) : (
              <div className="bg-slate-800/50 rounded-xl p-8 border border-slate-700 text-center text-slate-400">
                <p>Run a <strong>Backtest</strong> from the Tracker tab to generate historical performance data for risk analysis.</p>
              </div>
            )}

            {/* ===== FACTOR EXPOSURE ===== */}
            <SectionHeader icon="ðŸ§¬" title="Factor Exposure (Heuristic)" subtitle="Estimated factor tilts based on portfolio characteristics" />
            <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
              <MetricCard label="Momentum Factor" tip="Weighted average return across positions as a momentum proxy.
âœ… Positive = portfolio has positive price momentum
âš ï¸ Negative = fighting the trend." value={`${a.momentumScore >= 0 ? '+' : ''}${a.momentumScore.toFixed(2)}%`} sub="Weighted avg return as momentum proxy" color={a.momentumScore >= 0 ? 'text-green-400' : 'text-red-400'} />
              <MetricCard label="Conviction Tilt" tip="Average conviction level across the book.
âœ… High = concentrated in best ideas
ðŸ“ Low conviction + many positions = indexing risk." value={`${a.avgConviction.toFixed(1)} / 5`} sub={a.avgConviction >= 4 ? 'High-conviction concentrated' : a.avgConviction >= 3 ? 'Balanced' : 'Diversified low-conviction'} />
              <MetricCard label="Directional Tilt" tip="Net exposure as % of gross. How directional is the book?
ðŸ“ Close to 0% = well hedged
âš ï¸ >80% = essentially a long-only book." value={`${a.directionalBias >= 0 ? '+' : ''}${a.directionalBias.toFixed(1)}%`} sub={Math.abs(a.directionalBias) > 80 ? 'Strong directional bet' : Math.abs(a.directionalBias) > 50 ? 'Moderate directional' : 'Market neutral-ish'} />
            </div>

            {/* ===== CONVICTION ANALYSIS ===== */}
            <SectionHeader icon="ðŸ’ª" title="Conviction Analysis" subtitle="Performance and allocation by conviction level" />
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                <h3 className="text-sm font-semibold text-slate-300 mb-3">Return by Conviction Level</h3>
                <div style={{ height: '220px' }}><canvas ref={convictionPerfChartRef}></canvas></div>
              </div>
              <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                <table className="w-full text-sm">
                  <thead className="bg-slate-700">
                    <tr>
                      <th className="px-4 py-2.5 text-left">Conviction</th>
                      <th className="px-4 py-2.5 text-right"># Pos</th>
                      <th className="px-4 py-2.5 text-right">Allocation</th>
                      <th className="px-4 py-2.5 text-right">P&L</th>
                      <th className="px-4 py-2.5 text-right">Return</th>
                      <th className="px-4 py-2.5 text-right">Win Rate</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-slate-700/50">
                    {a.convictionBuckets.filter(b => b.count > 0).map(b => (
                      <tr key={b.conviction} className="hover:bg-slate-700/30">
                        <td className="px-4 py-2">
                          <span className="inline-flex px-2 py-0.5 rounded-full text-xs font-bold" style={{ backgroundColor: COLORS[b.conviction] + '20', color: COLORS[b.conviction] }}>
                            {b.conviction}/5
                          </span>
                        </td>
                        <td className="px-4 py-2 text-right font-mono">{b.count}</td>
                        <td className="px-4 py-2 text-right font-mono">${fmt((b.allocation / 1e6).toFixed(1))}M</td>
                        <td className={`px-4 py-2 text-right font-mono ${b.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {b.pnl >= 0 ? '+' : ''}${fmt((b.pnl / 1000).toFixed(1))}K
                        </td>
                        <td className={`px-4 py-2 text-right font-mono ${b.returnPct >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {b.returnPct >= 0 ? '+' : ''}{b.returnPct.toFixed(1)}%
                        </td>
                        <td className="px-4 py-2 text-right font-mono">{b.winRate.toFixed(0)}%</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>

            {/* ===== POSITION ATTRIBUTION ===== */}
            <SectionHeader icon="ðŸ“Š" title="Position Attribution" subtitle="Individual position contribution to portfolio return" />
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                <h3 className="text-sm font-semibold text-slate-300 mb-3">Return Attribution by Position</h3>
                <div style={{ height: Math.max(200, a.attribution.length * 35) + 'px' }}><canvas ref={attributionChartRef}></canvas></div>
              </div>
              <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                <table className="w-full text-sm">
                  <thead className="bg-slate-700">
                    <tr>
                      <th className="px-3 py-2.5 text-left">Ticker</th>
                      <th className="px-3 py-2.5 text-left">Dir</th>
                      <th className="px-3 py-2.5 text-right">Weight</th>
                      <th className="px-3 py-2.5 text-right">Return</th>
                      <th className="px-3 py-2.5 text-right">P&L</th>
                      <th className="px-3 py-2.5 text-right">Contribution</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-slate-700/50">
                    {a.attribution.map(pos => (
                      <tr key={pos.ticker} className="hover:bg-slate-700/30">
                        <td className="px-3 py-2 font-mono font-bold">{pos.ticker}</td>
                        <td className="px-3 py-2">
                          <span className={`px-2 py-0.5 rounded-full text-xs ${pos.direction === 'long' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}`}>
                            {pos.direction.toUpperCase()}
                          </span>
                        </td>
                        <td className="px-3 py-2 text-right font-mono">{pos.weight.toFixed(1)}%</td>
                        <td className={`px-3 py-2 text-right font-mono ${pos.returnPct >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {pos.returnPct >= 0 ? '+' : ''}{pos.returnPct.toFixed(1)}%
                        </td>
                        <td className={`px-3 py-2 text-right font-mono ${pos.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {pos.pnl >= 0 ? '+' : ''}${fmt((pos.pnl / 1000).toFixed(1))}K
                        </td>
                        <td className={`px-3 py-2 text-right font-mono font-bold ${pos.contribution >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {pos.contribution >= 0 ? '+' : ''}{pos.contribution.toFixed(2)}%
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>

            {/* ===== RISK CONTRIBUTION ===== */}
            <SectionHeader icon="âš¡" title="Risk Contribution" subtitle="Which positions are driving portfolio risk" />
            <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
              <table className="w-full text-sm">
                <thead className="bg-slate-700">
                  <tr>
                    <th className="px-4 py-2.5 text-left">Ticker</th>
                    <th className="px-4 py-2.5 text-left">Dir</th>
                    <th className="px-4 py-2.5 text-right">Weight</th>
                    <th className="px-4 py-2.5 text-right">P&L</th>
                    <th className="px-4 py-2.5 text-right">Risk Share</th>
                    <th className="px-4 py-2.5 text-left">Risk Bar</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-700/50">
                  {a.riskContribution.map(r => (
                    <tr key={r.ticker} className="hover:bg-slate-700/30">
                      <td className="px-4 py-2 font-mono font-bold">{r.ticker}</td>
                      <td className="px-4 py-2">
                        <span className={`px-2 py-0.5 rounded-full text-xs ${r.direction === 'long' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'}`}>
                          {r.direction.toUpperCase()}
                        </span>
                      </td>
                      <td className="px-4 py-2 text-right font-mono">{r.weight.toFixed(1)}%</td>
                      <td className={`px-4 py-2 text-right font-mono ${r.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                        {r.pnl >= 0 ? '+' : ''}${fmt((r.pnl / 1000).toFixed(1))}K
                      </td>
                      <td className="px-4 py-2 text-right font-mono font-bold">{r.riskShare.toFixed(1)}%</td>
                      <td className="px-4 py-2 w-48">
                        <div className="w-full bg-slate-700 rounded-full h-2.5">
                          <div 
                            className="h-2.5 rounded-full" 
                            style={{ 
                              width: `${Math.min(r.riskShare, 100)}%`,
                              backgroundColor: r.pnl >= 0 ? '#10b981' : '#ef4444'
                            }}
                          ></div>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            {/* ===== STRESS TESTING ===== */}
            <SectionHeader icon="ðŸ”¥" title="Stress Testing" subtitle="Estimated portfolio impact under various market scenarios" />
            <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
              <table className="w-full text-sm">
                <thead className="bg-slate-700">
                  <tr>
                    <th className="px-4 py-3 text-left">Scenario</th>
                    <th className="px-4 py-3 text-left">Description</th>
                    <th className="px-4 py-3 text-right">Market Move</th>
                    <th className="px-4 py-3 text-right">Portfolio P&L</th>
                    <th className="px-4 py-3 text-right">Portfolio Return</th>
                    <th className="px-4 py-3 text-left">Impact</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-700/50">
                  {a.stressResults.map((s, i) => (
                    <tr key={i} className="hover:bg-slate-700/30">
                      <td className="px-4 py-3 font-medium">{s.name}</td>
                      <td className="px-4 py-3 text-slate-400">{s.description}</td>
                      <td className="px-4 py-3 text-right font-mono">
                        {s.isRotation ? 'Â±5%' : `${s.marketMove >= 0 ? '+' : ''}${(s.marketMove * 100).toFixed(0)}%`}
                      </td>
                      <td className={`px-4 py-3 text-right font-mono font-bold ${s.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                        {s.pnl >= 0 ? '+' : ''}${fmt((s.pnl / 1e6).toFixed(1))}M
                      </td>
                      <td className={`px-4 py-3 text-right font-mono ${s.returnPct >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                        {s.returnPct >= 0 ? '+' : ''}{s.returnPct.toFixed(2)}%
                      </td>
                      <td className="px-4 py-3 w-40">
                        <div className="w-full bg-slate-700 rounded-full h-3 relative overflow-hidden">
                          <div 
                            className="h-3 rounded-full absolute"
                            style={{
                              width: `${Math.min(Math.abs(s.returnPct) * 2, 100)}%`,
                              backgroundColor: s.returnPct >= 0 ? '#10b981' : '#ef4444',
                              left: s.returnPct >= 0 ? '50%' : `${50 - Math.min(Math.abs(s.returnPct) * 2, 50)}%`,
                              maxWidth: '50%'
                            }}
                          ></div>
                          <div className="absolute left-1/2 top-0 w-px h-3 bg-slate-500"></div>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            {/* ===== PORTFOLIO HEALTH SCORECARD ===== */}
            <SectionHeader icon="ðŸ¥" title="Portfolio Health Scorecard" subtitle="Quick diagnostic checks" />
            {(() => {
              const checks = [
                { 
                  name: 'Diversification', 
                  pass: a.effectiveN >= 3 && a.top1Pct < 40,
                  detail: a.effectiveN >= 3 ? `Effective N = ${a.effectiveN.toFixed(1)}, top position = ${a.top1Pct.toFixed(0)}%` : `Only ${a.effectiveN.toFixed(1)} effective positions â€” consider diversifying`
                },
                {
                  name: 'Leverage',
                  pass: a.leverage <= 2.0,
                  detail: `${a.leverage.toFixed(2)}x gross leverage ${a.leverage > 2 ? 'â€” exceeds typical 2.0x limit' : 'â€” within normal range'}`
                },
                {
                  name: 'Drawdown',
                  pass: !hasHistory || a.maxDrawdown > -15,
                  detail: hasHistory ? `Max drawdown: ${a.maxDrawdown.toFixed(1)}% ${a.maxDrawdown < -15 ? 'â€” approaching risk limit' : 'â€” acceptable'}` : 'Run backtest for drawdown data'
                },
                {
                  name: 'Sharpe > 0.5',
                  pass: !hasHistory || a.sharpe > 0.5,
                  detail: hasHistory ? `Sharpe: ${a.sharpe.toFixed(2)} ${a.sharpe < 0.5 ? 'â€” below institutional threshold' : 'â€” acceptable risk-adjusted return'}` : 'Run backtest for Sharpe data'
                },
                {
                  name: 'Win Rate > 50%',
                  pass: !hasHistory || a.winRate > 50,
                  detail: hasHistory ? `Win rate: ${a.winRate.toFixed(0)}%` : 'Run backtest'
                },
                {
                  name: 'Positive Skew',
                  pass: !hasHistory || a.skewness >= 0,
                  detail: hasHistory ? `Skewness: ${a.skewness.toFixed(2)} ${a.skewness < 0 ? 'â€” left tail risk present' : 'â€” favorable distribution'}` : 'Run backtest'
                },
                {
                  name: 'Conviction Alignment',
                  pass: a.avgConviction >= 3,
                  detail: `Avg conviction: ${a.avgConviction.toFixed(1)}/5 ${a.avgConviction < 3 ? 'â€” low conviction positions drag returns' : 'â€” well-curated book'}`
                },
                {
                  name: 'Position Count',
                  pass: a.positions.length >= 3 && a.positions.length <= 25,
                  detail: `${a.positions.length} positions ${a.positions.length < 3 ? 'â€” too concentrated' : a.positions.length > 25 ? 'â€” potential diworsification' : 'â€” reasonable size'}`
                }
              ];
              const score = checks.filter(c => c.pass).length;
              const total = checks.length;
              const pct = (score / total) * 100;
              return (
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <div className="flex items-center gap-4 mb-4">
                    <div className={`text-4xl font-bold font-mono ${pct >= 75 ? 'text-green-400' : pct >= 50 ? 'text-yellow-400' : 'text-red-400'}`}>
                      {score}/{total}
                    </div>
                    <div>
                      <div className="w-48 bg-slate-700 rounded-full h-3">
                        <div className="h-3 rounded-full transition-all" style={{ width: `${pct}%`, backgroundColor: pct >= 75 ? '#10b981' : pct >= 50 ? '#f59e0b' : '#ef4444' }}></div>
                      </div>
                      <p className="text-xs text-slate-400 mt-1">{pct >= 75 ? 'Portfolio in good shape' : pct >= 50 ? 'Some areas need attention' : 'Multiple risk flags â€” review urgently'}</p>
                    </div>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                    {checks.map((c, i) => (
                      <div key={i} className="flex items-start gap-2 py-1.5">
                        <span className={`text-sm mt-0.5 ${c.pass ? 'text-green-400' : 'text-red-400'}`}>{c.pass ? 'âœ“' : 'âœ—'}</span>
                        <div>
                          <span className="text-sm font-medium text-slate-200">{c.name}</span>
                          <p className="text-xs text-slate-400">{c.detail}</p>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              );
            })()}

            {/* ===== PORTFOLIO ADVISOR ===== */}
            <div className="mb-4 mt-8">
              <h2 className="text-xl font-bold text-white flex items-center gap-2">ðŸ’¬ Portfolio Advisor</h2>
              <p className="text-sm text-slate-400 mt-1">Ask for portfolio optimization tips, risk analysis, or allocation advice</p>
            </div>
            <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
              <div className="max-h-80 overflow-y-auto p-4 space-y-3">
                {portfolioChatMsgs.length === 0 && (
                  <div className="text-center py-4">
                    <p className="text-slate-400 text-sm mb-3">Ask about your portfolio â€” powered by your actual data.</p>
                    <div className="flex flex-wrap gap-2 justify-center">
                      {['How can I improve my Sharpe ratio?', 'Is my portfolio too concentrated?', 'Which sectors am I overweight?', 'Show me my winners and losers', 'How do I reduce drawdown risk?'].map(q => (
                        <button key={q} onClick={() => sendPortfolioChat(q)} className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded-lg text-xs text-blue-300 transition-colors">{q}</button>
                      ))}
                    </div>
                  </div>
                )}
                {portfolioChatMsgs.map((m, i) => (
                  <div key={i} className={'flex ' + (m.role === 'user' ? 'justify-end' : 'justify-start')}>
                    <div className={'max-w-[80%] rounded-xl px-4 py-2.5 text-sm ' + (m.role === 'user' ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-200')}>
                      <p className="whitespace-pre-wrap">{m.content}</p>
                    </div>
                  </div>
                ))}
                {portfolioChatLoading && <div className="flex justify-start"><div className="bg-slate-700 rounded-xl px-4 py-2.5 text-sm text-slate-400 animate-pulse">Analyzing your portfolio...</div></div>}
              </div>
              <div className="border-t border-slate-700 p-3 flex gap-2">
                <input value={portfolioChatInput} onChange={e => setPortfolioChatInput(e.target.value)} onKeyDown={e => { if (e.key === 'Enter' && portfolioChatInput.trim()) sendPortfolioChat(portfolioChatInput); }} placeholder="Ask about your portfolio..." className="flex-1 px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm" />
                <button onClick={() => sendPortfolioChat(portfolioChatInput)} disabled={portfolioChatLoading || !portfolioChatInput.trim()} className="px-4 py-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm font-bold transition-all disabled:opacity-50">Send</button>
              </div>
            </div>
          </div>
        );
      };

      // ============================================================
      // SINGLE NAME TAB
      // ============================================================
      const [selectedTicker, setSelectedTicker] = useState(null);
      const [snTimeRange, setSnTimeRange] = useState('3m');
      const [snChartData, setSnChartData] = useState(null);
      const [snLoading, setSnLoading] = useState(false);
      const [snFundamentals, setSnFundamentals] = useState(null);
      const [selectedAnnotation, setSelectedAnnotation] = useState(null);
      const snChartRef = useRef(null);
      const snChartInstance = useRef(null);

      const timeRanges = [
        { key: '1d', label: '1D', range: '1d', interval: '5m' },
        { key: '5d', label: '1W', range: '5d', interval: '15m' },
        { key: '1m', label: '1M', range: '1mo', interval: '1d' },
        { key: '3m', label: '3M', range: '3mo', interval: '1d' },
        { key: '6m', label: '6M', range: '6mo', interval: '1d' },
        { key: '1y', label: '1Y', range: '1y', interval: '1d' },
        { key: '2y', label: '2Y', range: '2y', interval: '1wk' },
        { key: '5y', label: '5Y', range: '5y', interval: '1wk' },
      ];

      // Extended ranges for fetching enough data for 200-day MA
      const extendedRanges = {
        '1d': '1y', '5d': '1y', '1m': '1y', '3m': '2y',
        '6m': '2y', '1y': '2y', '2y': '5y', '5y': '10y'
      };

      // Fetch chart data for a ticker
      const fetchChartData = async (ticker, rangeKey) => {
        setSnLoading(true);
        const rangeDef = timeRanges.find(r => r.key === rangeKey) || timeRanges[3];
        // Use daily interval for MA computation regardless of display interval
        const maInterval = rangeDef.interval === '5m' || rangeDef.interval === '15m' ? '1d' : rangeDef.interval;
        const extendedRange = extendedRanges[rangeKey] || '2y';
        
        try {
          // Fetch extended data for MA computation
          const extUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?range=${extendedRange}&interval=${maInterval}`;
          const extProxyUrl = `https://corsproxy.io/?${encodeURIComponent(extUrl)}`;
          const extResponse = await fetch(extProxyUrl);
          const extData = await extResponse.json();
          
          // Also fetch the display-range data (for intraday charts)
          let displayPoints = null;
          if (rangeDef.interval === '5m' || rangeDef.interval === '15m') {
            const dispUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${ticker}?range=${rangeDef.range}&interval=${rangeDef.interval}`;
            const dispProxyUrl = `https://corsproxy.io/?${encodeURIComponent(dispUrl)}`;
            const dispResponse = await fetch(dispProxyUrl);
            const dispData = await dispResponse.json();
            if (dispData.chart?.result?.[0]) {
              const r = dispData.chart.result[0];
              const ts = r.timestamp || [];
              const q = r.indicators?.quote?.[0] || {};
              displayPoints = [];
              for (let i = 0; i < ts.length; i++) {
                if (q.close?.[i] != null && q.close[i] > 0) {
                  displayPoints.push({ date: new Date(ts[i] * 1000), close: q.close[i], volume: q.volume?.[i] || 0, high: q.high?.[i] || q.close[i], low: q.low?.[i] || q.close[i], open: q.open?.[i] || q.close[i] });
                }
              }
            }
          }
          
          if (extData.chart?.result?.[0]) {
            const result = extData.chart.result[0];
            const timestamps = result.timestamp || [];
            const quote = result.indicators?.quote?.[0] || {};
            const closes = quote.close || [];
            const volumes = quote.volume || [];
            const highs = quote.high || [];
            const lows = quote.low || [];
            const opens = quote.open || [];
            const meta = result.meta || {};
            
            // Build all extended data points (for MA computation)
            const allPoints = [];
            for (let i = 0; i < timestamps.length; i++) {
              if (closes[i] != null && closes[i] > 0) {
                allPoints.push({
                  date: new Date(timestamps[i] * 1000),
                  close: closes[i],
                  volume: volumes[i] || 0,
                  high: highs[i] || closes[i],
                  low: lows[i] || closes[i],
                  open: opens[i] || closes[i]
                });
              }
            }
            
            // Compute 50 & 200 MAs on the FULL extended dataset
            const computeMA = (data, period) => {
              return data.map((p, i) => {
                if (i < period - 1) return null;
                const slice = data.slice(i - period + 1, i + 1);
                return slice.reduce((s, d) => s + d.close, 0) / period;
              });
            };
            
            const fullMA50 = computeMA(allPoints, 50);
            const fullMA200 = computeMA(allPoints, 200);
            
            // Determine which points to display
            let chartPoints;
            if (displayPoints) {
              // Intraday - use display points, but map MAs from daily data
              chartPoints = displayPoints;
              // For intraday, just use the latest MA values as flat lines
              const lastMA50 = fullMA50.filter(v => v !== null).pop() || null;
              const lastMA200 = fullMA200.filter(v => v !== null).pop() || null;
              const ma50 = chartPoints.map(() => lastMA50);
              const ma200 = chartPoints.map(() => lastMA200);
              setSnChartData({ points: chartPoints, ma50, ma200, meta });
            } else {
              // Daily/Weekly - trim to display range
              const rangeStart = new Date();
              const rangeMap = { '1m': 30, '3m': 90, '6m': 180, '1y': 365, '2y': 730, '5y': 1825 };
              const daysBack = rangeMap[rangeKey] || 90;
              rangeStart.setDate(rangeStart.getDate() - daysBack);
              
              // Find the index where display range starts
              let startIdx = allPoints.findIndex(p => p.date >= rangeStart);
              if (startIdx < 0) startIdx = 0;
              
              chartPoints = allPoints.slice(startIdx);
              const ma50 = fullMA50.slice(startIdx);
              const ma200 = fullMA200.slice(startIdx);
              
              setSnChartData({ points: chartPoints, ma50, ma200, meta });
            }
            
            // Extract fundamentals from meta
            setSnFundamentals({
              currency: meta.currency || 'USD',
              exchange: meta.exchangeName || '',
              instrumentType: meta.instrumentType || '',
              regularMarketPrice: meta.regularMarketPrice || 0,
              previousClose: meta.previousClose || meta.chartPreviousClose || 0,
              fiftyTwoWeekHigh: meta.fiftyTwoWeekHigh || 0,
              fiftyTwoWeekLow: meta.fiftyTwoWeekLow || 0,
            });
          }
        } catch (err) {
          console.error('Chart fetch error:', err);
        }
        setSnLoading(false);
      };

      // When selected ticker or time range changes, fetch
      useEffect(() => {
        if (selectedTicker && activeTab === 'singlename') {
          fetchChartData(selectedTicker, snTimeRange);
        }
      }, [selectedTicker, snTimeRange, activeTab]);

      // Render stock chart
      useEffect(() => {
        if (activeTab !== 'singlename' || !snChartData || !snChartRef.current) return;
        
        const timer = setTimeout(() => {
          if (!snChartRef.current) return;
          const ctx = snChartRef.current.getContext('2d');
          if (snChartInstance.current) snChartInstance.current.destroy();
          
          const { points, ma50, ma200 } = snChartData;
          const labels = points.map(p => {
            const d = p.date;
            return snTimeRange === '1d' ? d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
              : snTimeRange === '5d' ? d.toLocaleDateString([], { weekday: 'short', hour: '2-digit', minute: '2-digit' })
              : d.toLocaleDateString([], { month: 'short', day: 'numeric', year: snTimeRange.includes('y') ? '2-digit' : undefined });
          });
          
          // Get all rating changes for this ticker from changeLog
          const tickerChanges = changeLog.filter(c => c.ticker === selectedTicker);
          
          // Also synthesize an "ENTRY" event from the position's entryDate if no ADD exists
          const selectedIdea = currentIdeas.find(i => i.ticker === selectedTicker);
          const hasAddEvent = tickerChanges.some(c => c.action === 'ADD');
          let allEvents = [...tickerChanges];
          if (!hasAddEvent && selectedIdea?.entryDate) {
            allEvents.unshift({
              date: new Date(selectedIdea.entryDate).toISOString(),
              ticker: selectedTicker,
              action: 'ENTRY',
              direction: selectedIdea.direction,
              conviction: selectedIdea.conviction,
              price: selectedIdea.entryPrice || 0,
              thesis: selectedIdea.thesis || '',
              catalyst: selectedIdea.catalyst || '',
            });
          }
          
          // Create annotation points on the chart
          const annotationPoints = new Array(points.length).fill(null);
          const annotationMeta = [];
          allEvents.forEach(change => {
            const changeDate = new Date(change.date);
            // Find closest data point
            let closestIdx = 0;
            let closestDiff = Infinity;
            points.forEach((p, i) => {
              const diff = Math.abs(p.date.getTime() - changeDate.getTime());
              if (diff < closestDiff) { closestDiff = diff; closestIdx = i; }
            });
            // Only annotate if within a reasonable range of data points (wider tolerance for longer ranges)
            const maxDiffDays = snTimeRange === '1d' ? 1 : snTimeRange === '5d' ? 2 : 5;
            if (closestDiff < maxDiffDays * 24 * 60 * 60 * 1000) {
              annotationPoints[closestIdx] = points[closestIdx].close;
              annotationMeta[closestIdx] = change;
            }
          });

          const firstClose = points[0]?.close || 0;
          const lastClose = points[points.length - 1]?.close || 0;
          const isUp = lastClose >= firstClose;

          const datasets = [
            {
              label: selectedTicker,
              data: points.map(p => p.close),
              borderColor: isUp ? '#10b981' : '#ef4444',
              backgroundColor: isUp ? 'rgba(16, 185, 129, 0.08)' : 'rgba(239, 68, 68, 0.08)',
              fill: true,
              tension: 0.3,
              pointRadius: 0,
              pointHoverRadius: 4,
              borderWidth: 2
            },
            {
              label: 'MA50',
              data: ma50,
              borderColor: '#f59e0b',
              borderWidth: 1.5,
              borderDash: [5, 3],
              pointRadius: 0,
              fill: false,
              tension: 0.3
            },
            {
              label: 'MA200',
              data: ma200,
              borderColor: '#8b5cf6',
              borderWidth: 1.5,
              borderDash: [8, 4],
              pointRadius: 0,
              fill: false,
              tension: 0.3
            },
            {
              label: 'Rating Changes',
              data: annotationPoints,
              borderColor: '#3b82f6',
              backgroundColor: annotationPoints.map((v, i) => {
                if (v === null) return 'transparent';
                const meta = annotationMeta[i];
                if (!meta) return '#3b82f6';
                if (meta.action === 'ADD' || meta.action === 'ENTRY') return '#10b981';
                if (meta.action === 'REMOVE') return '#ef4444';
                return '#f59e0b';
              }),
              pointRadius: annotationPoints.map(v => v !== null ? 9 : 0),
              pointHoverRadius: annotationPoints.map(v => v !== null ? 12 : 0),
              pointStyle: annotationPoints.map((v, i) => {
                if (v === null) return 'circle';
                const meta = annotationMeta[i];
                if (meta?.action === 'ADD' || meta?.action === 'ENTRY') return 'triangle';
                if (meta?.action === 'REMOVE') return 'crossRot';
                return 'circle';
              }),
              pointBorderColor: annotationPoints.map((v, i) => {
                if (v === null) return 'transparent';
                const meta = annotationMeta[i];
                if (!meta) return '#ffffff';
                if (meta.action === 'ADD' || meta.action === 'ENTRY') return '#ffffff';
                if (meta.action === 'REMOVE') return '#ffffff';
                return '#ffffff';
              }),
              pointBorderWidth: annotationPoints.map(v => v !== null ? 2 : 0),
              borderWidth: 0,
              showLine: false,
              fill: false
            }
          ];

          snChartInstance.current = new Chart(ctx, {
            type: 'line',
            data: { labels, datasets },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              scales: {
                y: {
                  ticks: { color: '#94a3b8', callback: v => '$' + v.toFixed(2) },
                  grid: { color: '#1e293b' }
                },
                x: {
                  ticks: { color: '#94a3b8', maxTicksLimit: 12, maxRotation: 0 },
                  grid: { display: false }
                }
              },
              plugins: {
                legend: {
                  labels: { color: '#cbd5e1', usePointStyle: true, pointStyle: 'line', filter: (item) => item.text !== 'Rating Changes' }
                },
                tooltip: {
                  callbacks: {
                    afterBody: (context) => {
                      const idx = context[0]?.dataIndex;
                      if (idx !== undefined && annotationMeta[idx]) {
                        const c = annotationMeta[idx];
                        const actionLabel = c.action === 'ENTRY' ? 'ðŸ“ POSITION ENTRY' : c.action === 'ADD' ? 'ðŸ“ ADDED' : c.action === 'REMOVE' ? 'âŒ REMOVED' : 'âœï¸ ' + c.action;
                        const lines = [
                          '',
                          `â”â” ${actionLabel} â”â”`,
                          `Direction: ${c.direction?.toUpperCase() || 'â€”'}`,
                          `Conviction: ${c.conviction}/5`,
                        ];
                        if (c.price) lines.push(`Price: $${Number(c.price).toFixed(2)}`);
                        if (c.prevConviction) lines.push(`(prev conviction: ${c.prevConviction}/5)`);
                        if (c.prevDirection) lines.push(`(prev direction: ${c.prevDirection})`);
                        if (c.thesis) lines.push(`Thesis: ${c.thesis.substring(0, 60)}`);
                        if (c.catalyst) lines.push(`Catalyst: ${c.catalyst.substring(0, 60)}`);
                        return lines;
                      }
                      return [];
                    }
                  }
                }
              },
              onClick: (event, elements) => {
                if (elements.length > 0) {
                  const idx = elements[0].index;
                  if (annotationMeta[idx]) {
                    setSelectedAnnotation(annotationMeta[idx]);
                  }
                }
              }
            }
          });
        }, 100);

        return () => {
          clearTimeout(timer);
          if (snChartInstance.current) { snChartInstance.current.destroy(); snChartInstance.current = null; }
        };
      }, [activeTab, snChartData, selectedTicker, changeLog]);

      const SingleNameTab = () => {
        const positionsForDisplay = positionsWithSizes.map(p => {
          const entry = p.entryPrice || 100;
          const current = p.currentPrice || entry;
          const ret = p.direction === 'long' ? (current - entry) / entry : (entry - current) / entry;
          return { ...p, ret };
        });

        const selectedIdea = positionsForDisplay.find(p => p.ticker === selectedTicker);
        const tickerChangeLog = changeLog.filter(c => c.ticker === selectedTicker);

        // Position metrics for selected ticker
        const posMetrics = selectedIdea ? (() => {
          const alloc = selectedIdea.allocation || 0;
          const weight = selectedIdea.weight || 0;
          const entry = selectedIdea.entryPrice || 100;
          const current = selectedIdea.currentPrice || entry;
          const ret = selectedIdea.ret;
          const pnl = ret * alloc;
          const contribution = portfolioGMV > 0 ? pnl / portfolioGMV : 0;
          const daysHeld = selectedIdea.entryDate 
            ? Math.floor((new Date() - new Date(selectedIdea.entryDate)) / (1000 * 60 * 60 * 24))
            : 0;
          const priceChange = current - entry;
          const pctFromHigh = snFundamentals?.fiftyTwoWeekHigh > 0 
            ? ((current - snFundamentals.fiftyTwoWeekHigh) / snFundamentals.fiftyTwoWeekHigh) * 100 : 0;
          const pctFromLow = snFundamentals?.fiftyTwoWeekLow > 0 
            ? ((current - snFundamentals.fiftyTwoWeekLow) / snFundamentals.fiftyTwoWeekLow) * 100 : 0;

          return { alloc, weight, entry, current, ret, pnl, contribution, daysHeld, priceChange, pctFromHigh, pctFromLow };
        })() : null;

        return (
          <div className="space-y-4">
            {/* Position Selector Grid */}
            <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
              <h3 className="text-sm font-semibold text-slate-300 mb-3">Active Positions ({positionsForDisplay.length})</h3>
              <div className="flex flex-wrap gap-2">
                {positionsForDisplay.map(p => {
                  const isSelected = p.ticker === selectedTicker;
                  const isLong = p.direction === 'long';
                  const retPct = p.ret * 100;
                  return (
                    <button
                      key={p.id}
                      onClick={() => setSelectedTicker(p.ticker)}
                      className={`px-3 py-2 rounded-lg text-xs font-mono font-bold transition-all border ${
                        isSelected
                          ? 'bg-blue-600 border-blue-400 text-white shadow-lg shadow-blue-600/25 scale-105'
                          : 'bg-slate-700/50 border-slate-600 hover:bg-slate-700 hover:border-slate-500'
                      }`}
                    >
                      <div className="flex items-center gap-1.5">
                        <span className={`w-1.5 h-1.5 rounded-full ${isLong ? 'bg-green-400' : 'bg-red-400'}`}></span>
                        <span>{p.ticker}</span>
                        <span className={`text-[10px] ${retPct >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {retPct >= 0 ? '+' : ''}{retPct.toFixed(1)}%
                        </span>
                      </div>
                    </button>
                  );
                })}
              </div>
            </div>

            {!selectedTicker ? (
              <div className="flex flex-col items-center justify-center py-24 text-slate-400">
                <div className="text-6xl mb-6">ðŸ“ˆ</div>
                <h2 className="text-2xl font-bold text-slate-300 mb-2">Select a Position</h2>
                <p className="text-sm">Click any ticker above to view its chart and detailed metrics.</p>
              </div>
            ) : (
              <>
                {/* Chart Header */}
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <div className="flex justify-between items-start mb-4 flex-wrap gap-3">
                    <div>
                      <div className="flex items-center gap-3">
                        <h2 className="text-3xl font-bold font-mono">{selectedTicker}</h2>
                        {selectedIdea && (
                          <span className={`px-2.5 py-1 rounded-full text-xs font-bold ${
                            selectedIdea.direction === 'long' ? 'bg-green-500/20 text-green-400' : 'bg-red-500/20 text-red-400'
                          }`}>
                            {selectedIdea.direction === 'long' ? 'â†—' : 'â†˜'} {selectedIdea.direction.toUpperCase()}
                          </span>
                        )}
                        {selectedIdea && (
                          <span className="px-2.5 py-1 rounded-full text-xs font-bold" style={{ backgroundColor: COLORS[selectedIdea.conviction] + '20', color: COLORS[selectedIdea.conviction] }}>
                            {selectedIdea.conviction}/5
                          </span>
                        )}
                      </div>
                      {snChartData && snChartData.points.length > 0 && (() => {
                        const last = snChartData.points[snChartData.points.length - 1];
                        const first = snChartData.points[0];
                        const change = last.close - first.close;
                        const changePct = (change / first.close) * 100;
                        return (
                          <div className="flex items-baseline gap-3 mt-1">
                            <span className="text-2xl font-bold font-mono">${last.close.toFixed(2)}</span>
                            <span className={`text-lg font-mono ${change >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                              {change >= 0 ? '+' : ''}{change.toFixed(2)} ({changePct >= 0 ? '+' : ''}{changePct.toFixed(2)}%)
                            </span>
                          </div>
                        );
                      })()}
                    </div>
                    {/* Time Range Buttons */}
                    <div className="flex gap-1 bg-slate-700/50 rounded-lg p-1">
                      {timeRanges.map(r => (
                        <button
                          key={r.key}
                          onClick={() => setSnTimeRange(r.key)}
                          className={`px-3 py-1.5 rounded-md text-xs font-semibold transition-all ${
                            snTimeRange === r.key
                              ? 'bg-blue-600 text-white'
                              : 'text-slate-400 hover:text-white hover:bg-slate-600'
                          }`}
                        >
                          {r.label}
                        </button>
                      ))}
                    </div>
                  </div>

                  {/* Chart */}
                  <div style={{ height: '380px' }} className="relative">
                    {snLoading && (
                      <div className="absolute inset-0 flex items-center justify-center bg-slate-800/80 z-10 rounded-lg">
                        <span className="text-slate-400">Loading chart...</span>
                      </div>
                    )}
                    <canvas ref={snChartRef}></canvas>
                  </div>

                  {/* Legend for annotations */}
                  {tickerChangeLog.length > 0 && (
                    <div className="mt-3 flex items-center gap-4 text-xs text-slate-400">
                      <span className="flex items-center gap-1"><span className="w-2 h-2 bg-green-500 rounded-full inline-block"></span> Add</span>
                      <span className="flex items-center gap-1"><span className="w-2 h-2 bg-yellow-500 rounded-full inline-block"></span> Rating Change</span>
                      <span className="flex items-center gap-1"><span className="w-2 h-2 bg-red-500 rounded-full inline-block"></span> Removed</span>
                      <span className="text-slate-500 ml-2">Click annotation bubbles for details</span>
                    </div>
                  )}
                </div>

                {/* Annotation Detail Panel */}
                {selectedAnnotation && selectedAnnotation.ticker === selectedTicker && (
                  <div className="bg-slate-800 rounded-xl p-5 border border-blue-500/50 shadow-lg shadow-blue-500/10">
                    <div className="flex justify-between items-start">
                      <div>
                        <h3 className="text-sm font-semibold text-blue-400 mb-2">
                          ðŸ“Œ {selectedAnnotation.action.replace(/_/g, ' ')} â€” {new Date(selectedAnnotation.date).toLocaleDateString()}
                        </h3>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                          <div><span className="text-slate-400">Direction:</span> <span className={selectedAnnotation.direction === 'long' ? 'text-green-400' : 'text-red-400'}>{selectedAnnotation.direction?.toUpperCase()}</span></div>
                          <div><span className="text-slate-400">Conviction:</span> <span className="font-bold">{selectedAnnotation.conviction}/5</span>
                            {selectedAnnotation.prevConviction && <span className="text-slate-500 ml-1">(was {selectedAnnotation.prevConviction}/5)</span>}
                          </div>
                          <div><span className="text-slate-400">Price:</span> <span className="font-mono">${selectedAnnotation.price?.toFixed(2)}</span></div>
                          {selectedAnnotation.prevDirection && selectedAnnotation.prevDirection !== selectedAnnotation.direction && (
                            <div><span className="text-slate-400">Prev Dir:</span> <span>{selectedAnnotation.prevDirection?.toUpperCase()}</span></div>
                          )}
                        </div>
                        {selectedAnnotation.thesis && <p className="mt-2 text-sm text-slate-300"><span className="text-slate-400">Thesis:</span> {selectedAnnotation.thesis}</p>}
                        {selectedAnnotation.catalyst && <p className="mt-1 text-sm text-slate-300"><span className="text-slate-400">Catalyst:</span> {selectedAnnotation.catalyst}</p>}
                      </div>
                      <button onClick={() => setSelectedAnnotation(null)} className="text-slate-500 hover:text-white text-lg">âœ•</button>
                    </div>
                  </div>
                )}

                {/* Metrics Grid */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {/* Position Metrics */}
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-4">ðŸ“Š Position Metrics</h3>
                    {posMetrics ? (
                      <div className="space-y-2.5 text-sm">
                        <div className="flex justify-between"><span className="text-slate-400">Allocation</span><span className="font-mono">${fmt((posMetrics.alloc / 1e6).toFixed(1))}M</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Portfolio Weight</span><span className="font-mono">{(posMetrics.weight * 100).toFixed(1)}%</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Entry Price</span><span className="font-mono">${posMetrics.entry.toFixed(2)}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Current Price</span><span className="font-mono font-bold">${posMetrics.current.toFixed(2)}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Price Change</span><span className={`font-mono ${posMetrics.priceChange >= 0 ? 'text-green-400' : 'text-red-400'}`}>{posMetrics.priceChange >= 0 ? '+' : ''}${posMetrics.priceChange.toFixed(2)}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Return</span><span className={`font-mono font-bold ${posMetrics.ret >= 0 ? 'text-green-400' : 'text-red-400'}`}>{posMetrics.ret >= 0 ? '+' : ''}{(posMetrics.ret * 100).toFixed(2)}%</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">P&L</span><span className={`font-mono font-bold ${posMetrics.pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>{posMetrics.pnl >= 0 ? '+' : ''}${fmt((posMetrics.pnl / 1000).toFixed(1))}K</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Portfolio Contribution</span><span className={`font-mono ${posMetrics.contribution >= 0 ? 'text-green-400' : 'text-red-400'}`}>{posMetrics.contribution >= 0 ? '+' : ''}{(posMetrics.contribution * 100).toFixed(3)}%</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Days Held</span><span className="font-mono">{posMetrics.daysHeld}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Conviction</span><span className="font-mono font-bold" style={{ color: COLORS[selectedIdea.conviction] }}>{selectedIdea.conviction}/5</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Direction</span><span className={selectedIdea.direction === 'long' ? 'text-green-400' : 'text-red-400'}>{selectedIdea.direction.toUpperCase()}</span></div>
                        {selectedIdea.thesis && <div className="pt-2 border-t border-slate-700"><span className="text-slate-400 text-xs">Thesis:</span><p className="text-slate-300 text-xs mt-0.5">{selectedIdea.thesis}</p></div>}
                        {selectedIdea.catalyst && <div><span className="text-slate-400 text-xs">Catalyst:</span><p className="text-slate-300 text-xs mt-0.5">{selectedIdea.catalyst}</p></div>}
                      </div>
                    ) : (
                      <p className="text-slate-500 text-sm">Position data not available</p>
                    )}
                  </div>

                  {/* Market Data & Fundamentals */}
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-4">ðŸ¦ Market Data</h3>
                    {snFundamentals ? (
                      <div className="space-y-2.5 text-sm">
                        <div className="flex justify-between"><span className="text-slate-400">Exchange</span><span className="font-mono">{snFundamentals.exchange}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Currency</span><span className="font-mono">{snFundamentals.currency}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">Previous Close</span><span className="font-mono">${snFundamentals.previousClose.toFixed(2)}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">52w High</span><span className="font-mono">${snFundamentals.fiftyTwoWeekHigh.toFixed(2)}</span></div>
                        <div className="flex justify-between"><span className="text-slate-400">52w Low</span><span className="font-mono">${snFundamentals.fiftyTwoWeekLow.toFixed(2)}</span></div>
                        {posMetrics && (
                          <>
                            <div className="flex justify-between"><span className="text-slate-400">% from 52w High</span><span className={`font-mono ${posMetrics.pctFromHigh <= 0 ? 'text-red-400' : 'text-green-400'}`}>{posMetrics.pctFromHigh.toFixed(1)}%</span></div>
                            <div className="flex justify-between"><span className="text-slate-400">% from 52w Low</span><span className={`font-mono ${posMetrics.pctFromLow >= 0 ? 'text-green-400' : 'text-red-400'}`}>+{posMetrics.pctFromLow.toFixed(1)}%</span></div>
                          </>
                        )}
                        <div className="flex justify-between"><span className="text-slate-400">52w Range Position</span>
                          <span className="font-mono">
                            {snFundamentals.fiftyTwoWeekHigh > snFundamentals.fiftyTwoWeekLow
                              ? ((snFundamentals.regularMarketPrice - snFundamentals.fiftyTwoWeekLow) / (snFundamentals.fiftyTwoWeekHigh - snFundamentals.fiftyTwoWeekLow) * 100).toFixed(0) + '%'
                              : 'N/A'
                            }
                          </span>
                        </div>
                        {/* 52w range bar */}
                        <div className="mt-2">
                          <div className="flex justify-between text-xs text-slate-500 mb-1">
                            <span>${snFundamentals.fiftyTwoWeekLow.toFixed(2)}</span>
                            <span>${snFundamentals.fiftyTwoWeekHigh.toFixed(2)}</span>
                          </div>
                          <div className="w-full bg-slate-700 rounded-full h-2 relative">
                            <div className="absolute h-2 rounded-full bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 opacity-30" style={{ width: '100%' }}></div>
                            {snFundamentals.fiftyTwoWeekHigh > snFundamentals.fiftyTwoWeekLow && (
                              <div 
                                className="absolute w-3 h-3 bg-blue-400 rounded-full -top-0.5 shadow-lg shadow-blue-400/50 border border-white"
                                style={{ left: `${Math.min(100, Math.max(0, ((snFundamentals.regularMarketPrice - snFundamentals.fiftyTwoWeekLow) / (snFundamentals.fiftyTwoWeekHigh - snFundamentals.fiftyTwoWeekLow)) * 100))}%`, transform: 'translateX(-50%)' }}
                              ></div>
                            )}
                          </div>
                        </div>
                      </div>
                    ) : (
                      <p className="text-slate-500 text-sm">Fetching data...</p>
                    )}
                  </div>
                </div>

                {/* Rating History Timeline */}
                {tickerChangeLog.length > 0 && (
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-4">ðŸ“œ Rating History ({tickerChangeLog.length} events)</h3>
                    <div className="overflow-x-auto">
                      <table className="w-full text-sm">
                        <thead className="bg-slate-700/50">
                          <tr>
                            <th className="px-3 py-2 text-left">Date</th>
                            <th className="px-3 py-2 text-left">Action</th>
                            <th className="px-3 py-2 text-left">Direction</th>
                            <th className="px-3 py-2 text-right">Conviction</th>
                            <th className="px-3 py-2 text-right">Price</th>
                            <th className="px-3 py-2 text-left">Thesis</th>
                            <th className="px-3 py-2 text-left">Catalyst</th>
                          </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700/50">
                          {[...tickerChangeLog].reverse().map((c, i) => (
                            <tr key={i} className="hover:bg-slate-700/30">
                              <td className="px-3 py-2 text-slate-300 font-mono text-xs">{new Date(c.date).toLocaleDateString()}</td>
                              <td className="px-3 py-2">
                                <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${
                                  c.action === 'ADD' ? 'bg-green-500/20 text-green-400' :
                                  c.action === 'REMOVE' ? 'bg-red-500/20 text-red-400' :
                                  'bg-yellow-500/20 text-yellow-400'
                                }`}>
                                  {c.action.replace(/_/g, ' ')}
                                </span>
                              </td>
                              <td className="px-3 py-2"><span className={c.direction === 'long' ? 'text-green-400' : 'text-red-400'}>{c.direction?.toUpperCase()}</span></td>
                              <td className="px-3 py-2 text-right font-mono font-bold">
                                {c.conviction}/5
                                {c.prevConviction && c.prevConviction !== c.conviction && (
                                  <span className="text-slate-500 font-normal ml-1">â†{c.prevConviction}</span>
                                )}
                              </td>
                              <td className="px-3 py-2 text-right font-mono">${c.price?.toFixed(2)}</td>
                              <td className="px-3 py-2 text-slate-400 max-w-xs truncate text-xs">{c.thesis}</td>
                              <td className="px-3 py-2 text-slate-400 max-w-xs truncate text-xs">{c.catalyst}</td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  </div>
                )}

                {/* Portfolio Risk Relative to this Name */}
                {posMetrics && (
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-4">âš¡ Risk & Sizing Assessment</h3>
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                      <div className="bg-slate-700/30 rounded-lg p-3">
                        <span className="text-xs text-slate-400">Weight vs Avg</span>
                        <p className={`text-lg font-bold font-mono ${(posMetrics.weight * 100) > (100 / positionsWithSizes.length) * 1.5 ? 'text-yellow-400' : 'text-white'}`}>
                          {((posMetrics.weight * 100) / (100 / positionsWithSizes.length || 1)).toFixed(1)}x
                        </p>
                        <p className="text-xs text-slate-500">{(posMetrics.weight * 100).toFixed(1)}% vs avg {(100 / positionsWithSizes.length).toFixed(1)}%</p>
                      </div>
                      <div className="bg-slate-700/30 rounded-lg p-3">
                        <span className="text-xs text-slate-400">P&L Contribution</span>
                        <p className={`text-lg font-bold font-mono ${posMetrics.contribution >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {posMetrics.contribution >= 0 ? '+' : ''}{(posMetrics.contribution * 100).toFixed(2)}%
                        </p>
                        <p className="text-xs text-slate-500">of total portfolio return</p>
                      </div>
                      <div className="bg-slate-700/30 rounded-lg p-3">
                        <span className="text-xs text-slate-400">Conviction Alignment</span>
                        <p className={`text-lg font-bold font-mono ${
                          (selectedIdea.conviction >= 4 && posMetrics.ret >= 0) || (selectedIdea.conviction <= 2 && posMetrics.ret < 0) 
                            ? 'text-green-400' : (selectedIdea.conviction >= 4 && posMetrics.ret < 0) ? 'text-red-400' : 'text-white'
                        }`}>
                          {selectedIdea.conviction >= 4 && posMetrics.ret >= 0 ? 'âœ“ Aligned' : selectedIdea.conviction >= 4 && posMetrics.ret < 0 ? 'âœ— Misfire' : 'Neutral'}
                        </p>
                        <p className="text-xs text-slate-500">{selectedIdea.conviction}/5 conviction, {(posMetrics.ret * 100).toFixed(1)}% return</p>
                      </div>
                      <div className="bg-slate-700/30 rounded-lg p-3">
                        <span className="text-xs text-slate-400">Max Loss at -20%</span>
                        <p className="text-lg font-bold font-mono text-red-400">
                          -${fmt((posMetrics.alloc * 0.2 / 1e6).toFixed(1))}M
                        </p>
                        <p className="text-xs text-slate-500">{(posMetrics.weight * 100 * 0.2).toFixed(1)}% of GMV</p>
                      </div>
                    </div>
                  </div>
                )}
              </>
            )}
          </div>
        );
      };

      // ============================================================
      // CORRELATION & ROLLING METRICS TAB
      // ============================================================
      const corrChart = useRef(null);
      const rollingSharpeChartRef = useRef(null);
      const rollingSharpeChart = useRef(null);
      const rollingWinRateChartRef = useRef(null);
      const rollingWinRateChart = useRef(null);
      const rollingVolChartRef = useRef(null);
      const rollingVolChart = useRef(null);

      const computeCorrelation = () => {
        if (!performanceHistory || performanceHistory.length < 5 || !positionsWithSizes || positionsWithSizes.length < 2) return null;
        // We can approximate correlations from the position returns
        // For a proper correlation, we'd need per-ticker daily returns from the backtest
        // Using the heuristic: positions with same direction in same conviction bucket are likely correlated
        // But let's use actual price data if backtest stored it
        
        // Build pairwise correlation from return direction similarity and conviction overlap
        const tickers = positionsWithSizes.map(p => p.ticker);
        const n = tickers.length;
        
        // Simple: compute from position characteristics since we don't store per-ticker daily returns
        // Use conviction, direction, and return similarity as correlation proxies
        const positions = positionsWithSizes.map(p => {
          const entry = p.entryPrice || 100;
          const current = p.currentPrice || entry;
          const ret = p.direction === 'long' ? (current - entry) / entry : (entry - current) / entry;
          return { ...p, ret };
        });

        const matrix = [];
        for (let i = 0; i < n; i++) {
          matrix[i] = [];
          for (let j = 0; j < n; j++) {
            if (i === j) { matrix[i][j] = 1.0; continue; }
            // Heuristic correlation estimate:
            // Same direction = higher correlation base
            const sameDir = positions[i].direction === positions[j].direction ? 0.3 : -0.2;
            // Similar returns = higher correlation
            const retDiff = Math.abs(positions[i].ret - positions[j].ret);
            const retSim = Math.max(0, 0.4 - retDiff * 2);
            // Same conviction level = slight correlation boost
            const convSim = (1 - Math.abs(positions[i].conviction - positions[j].conviction) / 4) * 0.15;
            // Return sign agreement
            const signAgree = (positions[i].ret >= 0) === (positions[j].ret >= 0) ? 0.15 : -0.1;
            
            let corr = sameDir + retSim + convSim + signAgree;
            corr = Math.max(-1, Math.min(1, corr));
            matrix[i][j] = corr;
          }
        }

        return { tickers, matrix, positions };
      };

      const computeRollingMetrics = () => {
        if (!performanceHistory || performanceHistory.length < 10) return null;
        
        const allReturns = [];
        for (let i = 1; i < performanceHistory.length; i++) {
          const prevPnL = performanceHistory[i - 1].portfolioReturn * 1000;
          const curPnL = performanceHistory[i].portfolioReturn * 1000;
          const r = portfolioGMV > 0 ? (curPnL - prevPnL) / portfolioGMV : 0;
          allReturns.push({
            date: performanceHistory[i].date,
            ret: r,
            spyPrice: performanceHistory[i].spyPrice,
            prevSpyPrice: performanceHistory[i - 1].spyPrice
          });
        }

        const windows = [
          { key: '30d', label: '30-Day', periods: 6 },  // ~6 x 5-day samples
          { key: '60d', label: '60-Day', periods: 12 },
          { key: '90d', label: '90-Day', periods: 18 },
        ];

        const rf = 0.05;
        const annFactor = 252 / 5;
        const annVolFactor = Math.sqrt(annFactor);

        const series = {};
        windows.forEach(w => {
          series[w.key] = { label: w.label, sharpe: [], winRate: [], vol: [], cumRet: [], dates: [] };
          for (let i = w.periods; i <= allReturns.length; i++) {
            const slice = allReturns.slice(i - w.periods, i);
            const n = slice.length;
            const mean = slice.reduce((s, r) => s + r.ret, 0) / n;
            const variance = slice.reduce((s, r) => s + (r.ret - mean) ** 2, 0) / Math.max(n - 1, 1);
            const vol = Math.sqrt(variance);
            const annVol = vol * annVolFactor;
            const annRet = mean * annFactor;
            const sharpe = annVol > 0 ? (annRet - rf) / annVol : 0;
            const wins = slice.filter(r => r.ret > 0).length;
            const winRate = (wins / n) * 100;
            const cumRet = slice.reduce((s, r) => s + r.ret, 0) * 100;

            series[w.key].sharpe.push(sharpe);
            series[w.key].winRate.push(winRate);
            series[w.key].vol.push(annVol * 100);
            series[w.key].cumRet.push(cumRet);
            series[w.key].dates.push(new Date(slice[slice.length - 1].date).toLocaleDateString());
          }
        });

        // Also compute rolling batting average per position (from current positions)
        const battingByPeriod = allReturns.map((r, i) => {
          const label = new Date(r.date).toLocaleDateString();
          return { date: label, win: r.ret > 0 ? 1 : 0, ret: r.ret * 100 };
        });

        return { series, allReturns, battingByPeriod };
      };

      const corrData = computeCorrelation();
      const rollingData = computeRollingMetrics();

      // Render correlation & rolling charts
      useEffect(() => {
        if (activeTab !== 'corrrolling') return;

        const timer = setTimeout(() => {
          // Rolling Sharpe chart
          if (rollingSharpeChartRef.current && rollingData) {
            const ctx = rollingSharpeChartRef.current.getContext('2d');
            if (rollingSharpeChart.current) rollingSharpeChart.current.destroy();
            const colors = ['#3b82f6', '#10b981', '#f59e0b'];
            const datasets = Object.values(rollingData.series).map((s, i) => ({
              label: s.label + ' Sharpe',
              data: s.sharpe,
              borderColor: colors[i],
              borderWidth: 2,
              tension: 0.3,
              pointRadius: 0,
              fill: false
            }));
            // Use longest series for labels
            const longestKey = Object.keys(rollingData.series).reduce((a, b) => 
              rollingData.series[a].dates.length > rollingData.series[b].dates.length ? a : b);
            rollingSharpeChart.current = new Chart(ctx, {
              type: 'line',
              data: { labels: rollingData.series[longestKey].dates, datasets },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { ticks: { color: '#94a3b8' }, grid: { color: '#1e293b' },
                    title: { display: true, text: 'Sharpe Ratio', color: '#64748b' } },
                  x: { ticks: { color: '#94a3b8', maxTicksLimit: 10, maxRotation: 0 }, grid: { display: false } }
                },
                plugins: {
                  legend: { labels: { color: '#cbd5e1' } },
                  annotation: {
                    annotations: { zeroLine: { type: 'line', yMin: 0, yMax: 0, borderColor: '#475569', borderDash: [4, 4] } }
                  }
                }
              }
            });
          }

          // Rolling Win Rate chart
          if (rollingWinRateChartRef.current && rollingData) {
            const ctx = rollingWinRateChartRef.current.getContext('2d');
            if (rollingWinRateChart.current) rollingWinRateChart.current.destroy();
            const colors = ['#3b82f6', '#10b981', '#f59e0b'];
            const datasets = Object.values(rollingData.series).map((s, i) => ({
              label: s.label,
              data: s.winRate,
              borderColor: colors[i],
              borderWidth: 2,
              tension: 0.3,
              pointRadius: 0,
              fill: false
            }));
            const longestKey = Object.keys(rollingData.series).reduce((a, b) => 
              rollingData.series[a].dates.length > rollingData.series[b].dates.length ? a : b);
            rollingWinRateChart.current = new Chart(ctx, {
              type: 'line',
              data: { labels: rollingData.series[longestKey].dates, datasets },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { min: 0, max: 100, ticks: { color: '#94a3b8', callback: v => v + '%' }, grid: { color: '#1e293b' },
                    title: { display: true, text: 'Win Rate %', color: '#64748b' } },
                  x: { ticks: { color: '#94a3b8', maxTicksLimit: 10, maxRotation: 0 }, grid: { display: false } }
                },
                plugins: { legend: { labels: { color: '#cbd5e1' } } }
              }
            });
          }

          // Rolling Volatility chart
          if (rollingVolChartRef.current && rollingData) {
            const ctx = rollingVolChartRef.current.getContext('2d');
            if (rollingVolChart.current) rollingVolChart.current.destroy();
            const colors = ['#3b82f6', '#10b981', '#f59e0b'];
            const datasets = Object.values(rollingData.series).map((s, i) => ({
              label: s.label,
              data: s.vol,
              borderColor: colors[i],
              backgroundColor: i === 0 ? 'rgba(59, 130, 246, 0.08)' : 'transparent',
              borderWidth: 2,
              tension: 0.3,
              pointRadius: 0,
              fill: i === 0
            }));
            const longestKey = Object.keys(rollingData.series).reduce((a, b) => 
              rollingData.series[a].dates.length > rollingData.series[b].dates.length ? a : b);
            rollingVolChart.current = new Chart(ctx, {
              type: 'line',
              data: { labels: rollingData.series[longestKey].dates, datasets },
              options: {
                responsive: true, maintainAspectRatio: false,
                scales: {
                  y: { ticks: { color: '#94a3b8', callback: v => v.toFixed(0) + '%' }, grid: { color: '#1e293b' },
                    title: { display: true, text: 'Ann. Volatility', color: '#64748b' } },
                  x: { ticks: { color: '#94a3b8', maxTicksLimit: 10, maxRotation: 0 }, grid: { display: false } }
                },
                plugins: { legend: { labels: { color: '#cbd5e1' } } }
              }
            });
          }
        }, 100);

        return () => {
          clearTimeout(timer);
          [rollingSharpeChart, rollingWinRateChart, rollingVolChart, corrChart].forEach(ref => {
            if (ref.current) { ref.current.destroy(); ref.current = null; }
          });
        };
      }, [activeTab, rollingData, corrData]);

      const CorrelationRollingTab = () => {
        if (!positionsWithSizes || positionsWithSizes.length < 2) {
          return (
            <div className="flex flex-col items-center justify-center py-32 text-slate-400">
              <div className="text-6xl mb-6">ðŸ”—</div>
              <h2 className="text-2xl font-bold text-slate-300 mb-2">Need More Positions</h2>
              <p className="text-sm">Add at least 2 positions and run a backtest for correlation and rolling analytics.</p>
            </div>
          );
        }

        const hasRolling = rollingData && Object.values(rollingData.series).some(s => s.sharpe.length > 0);

        return (
          <div className="space-y-4">
            {/* Correlation Matrix */}
            <div className="mt-0">
              <h2 className="text-xl font-bold text-white flex items-center gap-2 mb-4">ðŸ”— Correlation Matrix</h2>
              <p className="text-sm text-slate-400 mb-4">Estimated pairwise correlation between positions based on return similarity, directional alignment, and conviction overlap. Run more backtests for refined estimates.</p>
            </div>

            {corrData && (
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700 overflow-x-auto">
                <table className="text-xs font-mono">
                  <thead>
                    <tr>
                      <th className="px-2 py-2 text-left text-slate-400 sticky left-0 bg-slate-800 z-10"></th>
                      {corrData.tickers.map(t => (
                        <th key={t} className="px-2 py-2 text-center min-w-[56px]" style={{ writingMode: corrData.tickers.length > 10 ? 'vertical-lr' : 'horizontal-tb' }}>{t}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {corrData.tickers.map((t, i) => (
                      <tr key={t}>
                        <td className="px-2 py-1.5 font-bold text-slate-300 sticky left-0 bg-slate-800 z-10 border-r border-slate-700">{t}</td>
                        {corrData.matrix[i].map((val, j) => {
                          const absVal = Math.abs(val);
                          let bg, textColor;
                          if (i === j) { bg = '#1e293b'; textColor = '#64748b'; }
                          else if (val > 0.5) { bg = `rgba(239, 68, 68, ${absVal * 0.6})`; textColor = '#fca5a5'; }
                          else if (val > 0.2) { bg = `rgba(251, 191, 36, ${absVal * 0.5})`; textColor = '#fde68a'; }
                          else if (val > -0.1) { bg = `rgba(148, 163, 184, ${absVal * 0.3})`; textColor = '#cbd5e1'; }
                          else { bg = `rgba(16, 185, 129, ${absVal * 0.5})`; textColor = '#6ee7b7'; }
                          
                          return (
                            <td key={j} className="px-2 py-1.5 text-center" style={{ backgroundColor: bg, color: textColor, minWidth: '56px' }}>
                              {val.toFixed(2)}
                            </td>
                          );
                        })}
                      </tr>
                    ))}
                  </tbody>
                </table>
                <div className="flex items-center gap-4 mt-3 text-xs text-slate-400">
                  <span className="flex items-center gap-1"><span className="w-3 h-3 rounded" style={{ backgroundColor: 'rgba(16, 185, 129, 0.5)' }}></span> Negative (hedged)</span>
                  <span className="flex items-center gap-1"><span className="w-3 h-3 rounded" style={{ backgroundColor: 'rgba(148, 163, 184, 0.3)' }}></span> Low</span>
                  <span className="flex items-center gap-1"><span className="w-3 h-3 rounded" style={{ backgroundColor: 'rgba(251, 191, 36, 0.4)' }}></span> Moderate</span>
                  <span className="flex items-center gap-1"><span className="w-3 h-3 rounded" style={{ backgroundColor: 'rgba(239, 68, 68, 0.5)' }}></span> High (concentrated risk)</span>
                </div>
              </div>
            )}

            {/* Correlation Summary Stats */}
            {corrData && (() => {
              const n = corrData.tickers.length;
              let pairs = [];
              for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) pairs.push({ a: corrData.tickers[i], b: corrData.tickers[j], corr: corrData.matrix[i][j] });
              pairs.sort((a, b) => b.corr - a.corr);
              const avgCorr = pairs.reduce((s, p) => s + p.corr, 0) / (pairs.length || 1);
              const highCorr = pairs.filter(p => p.corr > 0.5);
              const negCorr = pairs.filter(p => p.corr < 0);

              return (
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                    <span className="text-slate-400 text-xs uppercase tracking-wider">Avg Pairwise Corr</span>
                    <p className={`text-xl font-bold font-mono mt-1 ${avgCorr > 0.4 ? 'text-red-400' : avgCorr > 0.2 ? 'text-yellow-400' : 'text-green-400'}`}>{avgCorr.toFixed(2)}</p>
                    <p className="text-xs text-slate-500 mt-1">{avgCorr > 0.4 ? 'âš ï¸ Concentrated' : 'Healthy diversification'}</p>
                  </div>
                  <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                    <span className="text-slate-400 text-xs uppercase tracking-wider">High Corr Pairs</span>
                    <p className={`text-xl font-bold font-mono mt-1 ${highCorr.length > 3 ? 'text-red-400' : 'text-white'}`}>{highCorr.length}</p>
                    <p className="text-xs text-slate-500 mt-1">Pairs &gt; 0.50</p>
                  </div>
                  <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                    <span className="text-slate-400 text-xs uppercase tracking-wider">Negative Corr Pairs</span>
                    <p className="text-xl font-bold font-mono mt-1 text-green-400">{negCorr.length}</p>
                    <p className="text-xs text-slate-500 mt-1">Natural hedges</p>
                  </div>
                  <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                    <span className="text-slate-400 text-xs uppercase tracking-wider">Most Correlated</span>
                    <p className="text-xl font-bold font-mono mt-1 text-red-400">{pairs[0] ? `${pairs[0].a}/${pairs[0].b}` : 'N/A'}</p>
                    <p className="text-xs text-slate-500 mt-1">{pairs[0] ? pairs[0].corr.toFixed(2) : ''}</p>
                  </div>
                </div>
              );
            })()}

            {/* Top correlated & least correlated pairs */}
            {corrData && (() => {
              const n = corrData.tickers.length;
              let pairs = [];
              for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) pairs.push({ a: corrData.tickers[i], b: corrData.tickers[j], corr: corrData.matrix[i][j] });
              pairs.sort((a, b) => b.corr - a.corr);
              const top5 = pairs.slice(0, 5);
              const bottom5 = pairs.slice(-5).reverse();

              return (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                    <h3 className="text-sm font-semibold text-red-400 mb-3">ðŸ”´ Most Correlated Pairs (Risk)</h3>
                    <div className="space-y-2">
                      {top5.map((p, i) => (
                        <div key={i} className="flex items-center justify-between text-sm">
                          <span className="font-mono">{p.a} â†” {p.b}</span>
                          <div className="flex items-center gap-2">
                            <div className="w-20 bg-slate-700 rounded-full h-2"><div className="h-2 rounded-full bg-red-500" style={{ width: `${Math.max(0, p.corr) * 100}%` }}></div></div>
                            <span className="font-mono text-red-400 w-12 text-right">{p.corr.toFixed(2)}</span>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                  <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                    <h3 className="text-sm font-semibold text-green-400 mb-3">ðŸŸ¢ Least Correlated / Hedged Pairs</h3>
                    <div className="space-y-2">
                      {bottom5.map((p, i) => (
                        <div key={i} className="flex items-center justify-between text-sm">
                          <span className="font-mono">{p.a} â†” {p.b}</span>
                          <div className="flex items-center gap-2">
                            <div className="w-20 bg-slate-700 rounded-full h-2"><div className="h-2 rounded-full bg-green-500" style={{ width: `${Math.max(0, -p.corr) * 100 + (p.corr >= 0 ? p.corr * 30 : 0)}%` }}></div></div>
                            <span className={`font-mono w-12 text-right ${p.corr < 0 ? 'text-green-400' : 'text-slate-400'}`}>{p.corr.toFixed(2)}</span>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              );
            })()}

            {/* Rolling Metrics */}
            <div className="mt-8">
              <h2 className="text-xl font-bold text-white flex items-center gap-2 mb-2">ðŸ“ˆ Rolling Metrics</h2>
              <p className="text-sm text-slate-400 mb-4">Performance through rolling windows â€” how risk teams at Citadel/Point72 evaluate PMs. {!hasRolling && 'Run a backtest to generate historical data.'}</p>
            </div>

            {hasRolling ? (
              <>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">Rolling Sharpe Ratio</h3>
                    <div style={{ height: '250px' }}><canvas ref={rollingSharpeChartRef}></canvas></div>
                  </div>
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">Rolling Win Rate</h3>
                    <div style={{ height: '250px' }}><canvas ref={rollingWinRateChartRef}></canvas></div>
                  </div>
                </div>
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <h3 className="text-sm font-semibold text-slate-300 mb-3">Rolling Annualized Volatility</h3>
                  <div style={{ height: '250px' }}><canvas ref={rollingVolChartRef}></canvas></div>
                </div>

                {/* Current Rolling Snapshot Table */}
                <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                  <table className="w-full text-sm">
                    <thead className="bg-slate-700">
                      <tr>
                        <th className="px-4 py-3 text-left">Window</th>
                        <th className="px-4 py-3 text-right">Sharpe</th>
                        <th className="px-4 py-3 text-right">Win Rate</th>
                        <th className="px-4 py-3 text-right">Ann. Vol</th>
                        <th className="px-4 py-3 text-right">Cum. Return</th>
                        <th className="px-4 py-3 text-left">Assessment</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-700/50">
                      {Object.entries(rollingData.series).map(([key, s]) => {
                        if (s.sharpe.length === 0) return null;
                        const latestSharpe = s.sharpe[s.sharpe.length - 1];
                        const latestWR = s.winRate[s.winRate.length - 1];
                        const latestVol = s.vol[s.vol.length - 1];
                        const latestCum = s.cumRet[s.cumRet.length - 1];
                        const assessment = latestSharpe > 1.5 ? 'ðŸŸ¢ Excellent' : latestSharpe > 0.7 ? 'ðŸŸ¡ Good' : latestSharpe > 0 ? 'ðŸŸ  Weak' : 'ðŸ”´ Losing';
                        return (
                          <tr key={key} className="hover:bg-slate-700/30">
                            <td className="px-4 py-2.5 font-semibold">{s.label}</td>
                            <td className={`px-4 py-2.5 text-right font-mono font-bold ${latestSharpe > 0.7 ? 'text-green-400' : latestSharpe > 0 ? 'text-yellow-400' : 'text-red-400'}`}>{latestSharpe.toFixed(2)}</td>
                            <td className={`px-4 py-2.5 text-right font-mono ${latestWR > 55 ? 'text-green-400' : 'text-white'}`}>{latestWR.toFixed(1)}%</td>
                            <td className="px-4 py-2.5 text-right font-mono">{latestVol.toFixed(1)}%</td>
                            <td className={`px-4 py-2.5 text-right font-mono ${latestCum >= 0 ? 'text-green-400' : 'text-red-400'}`}>{latestCum >= 0 ? '+' : ''}{latestCum.toFixed(2)}%</td>
                            <td className="px-4 py-2.5">{assessment}</td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              </>
            ) : (
              <div className="bg-slate-800/50 rounded-xl p-8 border border-slate-700 text-center text-slate-400">
                <p>Run a <strong>Backtest</strong> from the Tracker tab to generate the historical return series needed for rolling metrics.</p>
              </div>
            )}
          </div>
        );
      };

      // ============================================================
      // TRADE JOURNAL TAB
      // ============================================================
      const TradeJournalTab = () => {
        const [journalFilter, setJournalFilter] = useState('all');
        const [journalTickerFilter, setJournalTickerFilter] = useState('');

        // Build enriched journal entries from changeLog
        const journalEntries = changeLog.map((entry, idx) => {
          // Find the next entry for same ticker to compute holding period return
          const laterEntries = changeLog.slice(idx + 1).filter(e => e.ticker === entry.ticker);
          const currentIdea = currentIdeas.find(i => i.ticker === entry.ticker);
          const currentPrice = currentIdea?.currentPrice || entry.price;

          // Compute P&L from entry price to current or to next action
          let exitPrice = currentPrice;
          let holdingReturn = 0;
          let isOpen = !!currentIdea;
          let status = isOpen ? 'OPEN' : 'CLOSED';

          if (entry.action === 'REMOVE') {
            status = 'CLOSED';
            isOpen = false;
            holdingReturn = 0;
          } else if (entry.price > 0) {
            holdingReturn = entry.direction === 'long'
              ? ((exitPrice - entry.price) / entry.price) * 100
              : ((entry.price - exitPrice) / entry.price) * 100;
          }

          // Find allocation at time of entry
          const alloc = currentIdea?.allocation || 0;
          const pnlDollar = entry.price > 0 && alloc > 0 ? (holdingReturn / 100) * alloc : 0;

          return {
            ...entry,
            exitPrice,
            holdingReturn,
            pnlDollar,
            status,
            isOpen,
            daysSince: Math.floor((new Date() - new Date(entry.date)) / (1000 * 60 * 60 * 24))
          };
        });

        // Filters
        const uniqueTickers = [...new Set(changeLog.map(e => e.ticker))].sort();
        let filtered = journalEntries;
        if (journalFilter !== 'all') filtered = filtered.filter(e => e.action.includes(journalFilter));
        if (journalTickerFilter) filtered = filtered.filter(e => e.ticker === journalTickerFilter);

        // Summary stats
        const adds = changeLog.filter(e => e.action === 'ADD');
        const removes = changeLog.filter(e => e.action === 'REMOVE');
        const edits = changeLog.filter(e => e.action !== 'ADD' && e.action !== 'REMOVE');
        const openTickers = [...new Set(currentIdeas.map(i => i.ticker))];
        const closedTickers = [...new Set(removes.map(r => r.ticker))].filter(t => !openTickers.includes(t));

        // Compute closed trade P&L (simplified: ADD -> REMOVE pairs)
        const closedTrades = [];
        const tickerAdds = {};
        changeLog.forEach(entry => {
          if (entry.action === 'ADD') {
            tickerAdds[entry.ticker] = entry;
          } else if (entry.action === 'REMOVE' && tickerAdds[entry.ticker]) {
            const add = tickerAdds[entry.ticker];
            const ret = add.direction === 'long'
              ? ((entry.price - add.price) / add.price) * 100
              : ((add.price - entry.price) / add.price) * 100;
            closedTrades.push({ ticker: entry.ticker, direction: add.direction, entryPrice: add.price, exitPrice: entry.price, ret, entryDate: add.date, exitDate: entry.date });
            delete tickerAdds[entry.ticker];
          }
        });

        const closedWins = closedTrades.filter(t => t.ret > 0);
        const closedLosses = closedTrades.filter(t => t.ret <= 0);
        const closedBattingAvg = closedTrades.length > 0 ? (closedWins.length / closedTrades.length) * 100 : 0;
        const avgClosedReturn = closedTrades.length > 0 ? closedTrades.reduce((s, t) => s + t.ret, 0) / closedTrades.length : 0;

        return (
          <div className="space-y-4">
            <div className="mt-0">
              <h2 className="text-xl font-bold text-white flex items-center gap-2 mb-2">ðŸ“’ Trade Journal</h2>
              <p className="text-sm text-slate-400 mb-4">Complete audit trail of every position change. Every add, edit, conviction change, and removal is logged automatically.</p>
            </div>

            {/* Journal Summary KPIs */}
            <div className="grid grid-cols-2 md:grid-cols-6 gap-3">
              <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                <span className="text-slate-400 text-xs uppercase">Total Events</span>
                <p className="text-2xl font-bold font-mono mt-1">{changeLog.length}</p>
              </div>
              <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                <span className="text-slate-400 text-xs uppercase">Positions Added</span>
                <p className="text-2xl font-bold font-mono mt-1 text-green-400">{adds.length}</p>
              </div>
              <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                <span className="text-slate-400 text-xs uppercase">Positions Closed</span>
                <p className="text-2xl font-bold font-mono mt-1 text-red-400">{removes.length}</p>
              </div>
              <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                <span className="text-slate-400 text-xs uppercase">Rating Changes</span>
                <p className="text-2xl font-bold font-mono mt-1 text-yellow-400">{edits.length}</p>
              </div>
              <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                <span className="text-slate-400 text-xs uppercase">Closed Batting Avg</span>
                <p className={`text-2xl font-bold font-mono mt-1 ${closedBattingAvg > 55 ? 'text-green-400' : closedBattingAvg > 45 ? 'text-yellow-400' : 'text-red-400'}`}>
                  {closedTrades.length > 0 ? closedBattingAvg.toFixed(0) + '%' : 'N/A'}
                </p>
              </div>
              <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50">
                <span className="text-slate-400 text-xs uppercase">Avg Closed Return</span>
                <p className={`text-2xl font-bold font-mono mt-1 ${avgClosedReturn >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                  {closedTrades.length > 0 ? `${avgClosedReturn >= 0 ? '+' : ''}${avgClosedReturn.toFixed(1)}%` : 'N/A'}
                </p>
              </div>
            </div>

            {/* Closed Trades Table */}
            {closedTrades.length > 0 && (
              <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
                <div className="px-4 py-3 bg-slate-700/50">
                  <h3 className="text-sm font-semibold text-slate-300">Closed Trades ({closedTrades.length})</h3>
                </div>
                <table className="w-full text-sm">
                  <thead className="bg-slate-700/30">
                    <tr>
                      <th className="px-4 py-2 text-left">Ticker</th>
                      <th className="px-4 py-2 text-left">Direction</th>
                      <th className="px-4 py-2 text-right">Entry</th>
                      <th className="px-4 py-2 text-right">Exit</th>
                      <th className="px-4 py-2 text-right">Return</th>
                      <th className="px-4 py-2 text-left">Entry Date</th>
                      <th className="px-4 py-2 text-left">Exit Date</th>
                      <th className="px-4 py-2 text-center">Result</th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-slate-700/50">
                    {[...closedTrades].reverse().map((t, i) => (
                      <tr key={i} className="hover:bg-slate-700/30">
                        <td className="px-4 py-2 font-mono font-bold">{t.ticker}</td>
                        <td className="px-4 py-2"><span className={t.direction === 'long' ? 'text-green-400' : 'text-red-400'}>{t.direction.toUpperCase()}</span></td>
                        <td className="px-4 py-2 text-right font-mono">${t.entryPrice.toFixed(2)}</td>
                        <td className="px-4 py-2 text-right font-mono">${t.exitPrice.toFixed(2)}</td>
                        <td className={`px-4 py-2 text-right font-mono font-bold ${t.ret >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {t.ret >= 0 ? '+' : ''}{t.ret.toFixed(1)}%
                        </td>
                        <td className="px-4 py-2 text-xs text-slate-400">{new Date(t.entryDate).toLocaleDateString()}</td>
                        <td className="px-4 py-2 text-xs text-slate-400">{new Date(t.exitDate).toLocaleDateString()}</td>
                        <td className="px-4 py-2 text-center">{t.ret >= 0 ? 'âœ…' : 'âŒ'}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}

            {/* Filters */}
            <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
              <div className="flex flex-wrap gap-3 items-center">
                <span className="text-sm text-slate-400">Filter:</span>
                <div className="flex gap-1 bg-slate-700/50 rounded-lg p-1">
                  {[
                    { key: 'all', label: 'All' },
                    { key: 'ADD', label: 'Adds' },
                    { key: 'REMOVE', label: 'Removes' },
                    { key: 'CONVICTION', label: 'Conv. Changes' },
                    { key: 'DIRECTION', label: 'Dir. Changes' },
                  ].map(f => (
                    <button
                      key={f.key}
                      onClick={() => setJournalFilter(f.key)}
                      className={`px-3 py-1 rounded-md text-xs font-semibold transition-all ${
                        journalFilter === f.key ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-600'
                      }`}
                    >
                      {f.label}
                    </button>
                  ))}
                </div>
                <select
                  value={journalTickerFilter}
                  onChange={(e) => setJournalTickerFilter(e.target.value)}
                  className="px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-xs"
                >
                  <option value="">All Tickers</option>
                  {uniqueTickers.map(t => <option key={t} value={t}>{t}</option>)}
                </select>
                <span className="text-xs text-slate-500">Showing {filtered.length} of {journalEntries.length}</span>
              </div>
            </div>

            {/* Full Journal Table */}
            <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
              <table className="w-full text-sm">
                <thead className="bg-slate-700">
                  <tr>
                    <th className="px-3 py-2.5 text-left">Date</th>
                    <th className="px-3 py-2.5 text-left">Ticker</th>
                    <th className="px-3 py-2.5 text-left">Action</th>
                    <th className="px-3 py-2.5 text-left">Direction</th>
                    <th className="px-3 py-2.5 text-right">Conv.</th>
                    <th className="px-3 py-2.5 text-right">Price</th>
                    <th className="px-3 py-2.5 text-right">Current</th>
                    <th className="px-3 py-2.5 text-right">Return</th>
                    <th className="px-3 py-2.5 text-left">Status</th>
                    <th className="px-3 py-2.5 text-right">Days</th>
                    <th className="px-3 py-2.5 text-left">Thesis</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-700/50">
                  {filtered.length === 0 ? (
                    <tr><td colSpan="11" className="px-4 py-8 text-center text-slate-500">No events recorded yet. Add positions and make changes to populate the journal.</td></tr>
                  ) : (
                    [...filtered].reverse().map((entry, i) => (
                      <tr key={i} className="hover:bg-slate-700/30">
                        <td className="px-3 py-2 font-mono text-xs text-slate-300">{new Date(entry.date).toLocaleDateString()}<br/><span className="text-slate-500">{new Date(entry.date).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</span></td>
                        <td className="px-3 py-2 font-mono font-bold">{entry.ticker}</td>
                        <td className="px-3 py-2">
                          <span className={`px-2 py-0.5 rounded-full text-xs font-bold ${
                            entry.action === 'ADD' ? 'bg-green-500/20 text-green-400' :
                            entry.action === 'REMOVE' ? 'bg-red-500/20 text-red-400' :
                            'bg-yellow-500/20 text-yellow-400'
                          }`}>
                            {entry.action.replace(/_/g, ' ')}
                          </span>
                        </td>
                        <td className="px-3 py-2"><span className={entry.direction === 'long' ? 'text-green-400' : 'text-red-400'}>{entry.direction?.toUpperCase()}</span></td>
                        <td className="px-3 py-2 text-right font-mono font-bold">
                          {entry.conviction}/5
                          {entry.prevConviction && entry.prevConviction !== entry.conviction && (
                            <span className="text-slate-500 font-normal text-xs ml-1">â†{entry.prevConviction}</span>
                          )}
                        </td>
                        <td className="px-3 py-2 text-right font-mono">${entry.price?.toFixed(2)}</td>
                        <td className="px-3 py-2 text-right font-mono">{entry.action !== 'REMOVE' ? `$${entry.exitPrice?.toFixed(2)}` : 'â€”'}</td>
                        <td className={`px-3 py-2 text-right font-mono ${entry.action === 'REMOVE' ? 'text-slate-500' : entry.holdingReturn >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {entry.action === 'REMOVE' ? 'â€”' : `${entry.holdingReturn >= 0 ? '+' : ''}${entry.holdingReturn.toFixed(1)}%`}
                        </td>
                        <td className="px-3 py-2">
                          <span className={`px-2 py-0.5 rounded-full text-xs ${entry.isOpen ? 'bg-blue-500/20 text-blue-400' : 'bg-slate-600/30 text-slate-400'}`}>
                            {entry.status}
                          </span>
                        </td>
                        <td className="px-3 py-2 text-right font-mono text-xs">{entry.daysSince}d</td>
                        <td className="px-3 py-2 text-xs text-slate-400 max-w-[200px] truncate" title={entry.thesis}>{entry.thesis || 'â€”'}</td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>
        );
      };


      // ============================================================
      // STOCK SCREENER TAB (Self-contained quantitative scoring)
      // ============================================================
      const [aiTicker, setAiTicker] = useState('');
      const [aiLoading, setAiLoading] = useState(false);
      const [aiResult, setAiResult] = useState(null);
      const [aiChartData, setAiChartData] = useState(null);
      const [aiError, setAiError] = useState('');
      const [showAllPortfolio, setShowAllPortfolio] = useState(false);
      const [screenerTab, setScreenerTab] = useState('overview');
      const [chartRange, setChartRange] = useState('6m');
      const [chatMessages, setChatMessages] = useState([]);
      const [chatInput, setChatInput] = useState('');
      const [portfolioChatMsgs, setPortfolioChatMsgs] = useState([]);
      const [portfolioChatInput, setPortfolioChatInput] = useState('');
      const [portfolioChatLoading, setPortfolioChatLoading] = useState(false);
      const [chatLoading, setChatLoading] = useState(false);
      const aiPriceChartRef = useRef(null);
      const aiPriceChart = useRef(null);
      const sentimentChartRef = useRef(null);
      const sentimentChart = useRef(null);
      const chatEndRef = useRef(null);
      const [sentimentRange, setSentimentRange] = useState('all');

      // Tooltip definitions for hover education
      const TIPS = {
        rsi: 'Relative Strength Index (0-100). Above 70=overbought. Below 30=oversold.',
        macd: 'MACD above signal line=bullish. Below=bearish.',
        ma50: '50-Day Moving Avg. Price above=uptrend.',
        ma200: '200-Day Moving Avg. Price above=long-term uptrend.',
        goldenCross: 'MA50 crosses above MA200. Strong bullish signal.',
        bollinger: 'Position in Bollinger Bands. 50%=midband.',
        vol30: '30d Annualized Volatility. Below 20%=stable. Above 40%=risky.',
        composite: 'Weighted: Tech 20% + Momentum 20% + Fund 25% + Vol 10% + Liq 10% + Trend 15%.',
        pe: 'Price/Earnings. Lower=cheaper. Above 30=expensive unless high-growth.',
        evEbitda: 'EV/EBITDA. Capital-neutral valuation. Below 10=cheap.',
        pb: 'Price/Book. Below 1=below asset value.',
        ps: 'Price/Sales. Below 2=cheap.',
        debtEquity: 'Debt/Equity. Below 50=conservative. Above 200=high leverage.',
        currentRatio: 'Current Assets/Liabilities. Above 1.5=healthy.',
        roe: 'Return on Equity. Above 15%=strong.',
        grossMargin: 'Gross Profit/Revenue. Above 50%=strong moat.',
        ebitdaMargin: 'EBITDA/Revenue. Above 20%=healthy.',
        revenueGrowth: 'YoY revenue growth. Above 20%=high growth.',
        cashMarketCap: 'Cash/Market Cap. Above 20%=significant cash cushion.',
        fcf: 'Free Cash Flow yield. Above 5%=strong cash generation.',
        beta: 'Market sensitivity. 1.0=market. Above 1.5=volatile.',
        shortInterest: '% float sold short. Above 10%=significant bearish bets.',
        sentiment: 'Social sentiment: -100 (bearish) to +100 (bullish).',
        techScore: 'Composite of MA position, golden cross, RSI, MACD, Bollinger. Higher=more bullish.',
        trendScore: 'Measures alignment of multi-timeframe returns + MA stacking.',
        liquidity: 'Based on avg daily dollar volume. Above $100M/day = highly liquid.',
        momentum: 'Multi-timeframe return consistency. More positive timeframes = stronger trend.',
      };

      // Hoverable tooltip component
      const Tip = ({ label, tipKey, children, className }) => {
        const tip = TIPS[tipKey];
        const [hov, setHov] = useState(false);
        if (!tip) return children || <span className="text-slate-400">{label}</span>;
        return (
          <span className={'relative inline-block ' + (className || '')} onMouseEnter={() => setHov(true)} onMouseLeave={() => setHov(false)} style={{ cursor: 'help' }}>
            {children || <span className="text-slate-400" style={{ borderBottom: '1px dotted #64748b' }}>{label}</span>}
            <span style={{ position: 'absolute', zIndex: 999, bottom: '100%', left: '50%', transform: 'translateX(-50%)', marginBottom: 8, width: 240, padding: '10px 12px', backgroundColor: '#0f172a', border: '1px solid #475569', borderRadius: 8, fontSize: 12, color: '#cbd5e1', lineHeight: 1.5, pointerEvents: 'none', display: hov ? 'block' : 'none', boxShadow: '0 4px 12px rgba(0,0,0,0.5)' }}>
              <span style={{ fontWeight: 700, color: '#fff', display: 'block', marginBottom: 3 }}>{label}</span>
              {tip}
            </span>
          </span>
        );
      };

      const runAIScreener = async (ticker) => {
        if (!ticker) return;
        setAiLoading(true);
        setAiError('');
        setAiResult(null);
        setAiChartData(null);
        setChatMessages([]);
        setScreenerTab('overview');
        const t = ticker.toUpperCase().trim();

        try {
          const fetchYF = async (url) => {
            const proxies = [
              `https://corsproxy.io/?${encodeURIComponent(url)}`,
              `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
              `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
            ];
            for (const proxy of proxies) {
              try {
                const res = await fetch(proxy, { signal: AbortSignal.timeout(8000) });
                if (!res.ok) continue;
                const text = await res.text();
                try { return JSON.parse(text); } catch { continue; }
              } catch { continue; }
            }
            throw new Error('All proxies failed for: ' + url.substring(0, 80));
          };

          // Fetch 2-year daily OHLCV
          const priceData = await fetchYF('https://query1.finance.yahoo.com/v8/finance/chart/' + t + '?range=2y&interval=1d');
          const priceResult = priceData.chart?.result?.[0];
          if (!priceResult) throw new Error('No data found for "' + t + '". Check the ticker symbol.');

          const timestamps = priceResult.timestamp || [];
          const q = priceResult.indicators?.quote?.[0] || {};
          const closes = q.close || [], volumes = q.volume || [], highArr = q.high || [], lowArr = q.low || [];
          const meta = priceResult.meta || {};

          const points = [];
          for (let i = 0; i < timestamps.length; i++) {
            if (closes[i] != null && closes[i] > 0) {
              points.push({ date: new Date(timestamps[i] * 1000), close: closes[i], volume: volumes[i] || 0, high: highArr[i] || closes[i], low: lowArr[i] || closes[i] });
            }
          }
          if (points.length < 30) throw new Error('Insufficient price data for ' + t + '.');

          // 2. Fetch sector + compute fundamentals from price data
          let fundamentals = {};
          try {
            const sr = await fetchYF('https://query1.finance.yahoo.com/v1/finance/search?q=' + t + '&quotesCount=1&newsCount=0');
            const sq = (sr?.quotes || [])[0];
            if (sq) {
              fundamentals.sector = sq.sector || null;
              fundamentals.industry = sq.industry || null;
              fundamentals.shortname = sq.shortname || null;
              fundamentals.longname = sq.longname || null;
            }
          } catch (e) { console.warn('Search failed:', e.message); }

          const priceArr = points.map(p => p.close);
          const volumeArr = points.map(p => p.volume);
          const totalDays = priceArr.length;
          const lastPrice = priceArr[totalDays - 1] || 0;
          const price1w = totalDays > 5 ? priceArr[totalDays - 6] : null;
          const price1m = totalDays > 21 ? priceArr[totalDays - 22] : null;
          const price3m = totalDays > 63 ? priceArr[totalDays - 64] : null;
          const price6m = totalDays > 126 ? priceArr[totalDays - 127] : null;
          const price1y = totalDays > 252 ? priceArr[totalDays - 253] : null;
          const priceYTD = points.length > 0 ? (() => {
            const jan1 = new Date(new Date().getFullYear(), 0, 1);
            const ytdPoint = points.find(p => p.date >= jan1);
            return ytdPoint ? ytdPoint.close : null;
          })() : null;
          fundamentals.return1w = price1w && lastPrice ? ((lastPrice - price1w) / price1w * 100) : null;
          fundamentals.return1m = price1m && lastPrice ? ((lastPrice - price1m) / price1m * 100) : null;
          fundamentals.return3m = price3m && lastPrice ? ((lastPrice - price3m) / price3m * 100) : null;
          fundamentals.return6m = price6m && lastPrice ? ((lastPrice - price6m) / price6m * 100) : null;
          fundamentals.return1y = price1y && lastPrice ? ((lastPrice - price1y) / price1y * 100) : null;
          fundamentals.returnYTD = priceYTD && lastPrice ? ((lastPrice - priceYTD) / priceYTD * 100) : null;
          const dailyReturns = [];
          for (let i = 1; i < priceArr.length; i++) {
            if (priceArr[i] > 0 && priceArr[i-1] > 0) dailyReturns.push(Math.log(priceArr[i] / priceArr[i-1]));
          }
          const avgReturn = dailyReturns.reduce((s,r) => s+r, 0) / dailyReturns.length;
          const variance = dailyReturns.reduce((s,r) => s + (r - avgReturn) ** 2, 0) / (dailyReturns.length - 1);
          fundamentals.annualVol = Math.sqrt(variance * 252) * 100;
          fundamentals.sharpeEst = dailyReturns.length > 50 ? (avgReturn * 252 - 0.05) / (Math.sqrt(variance * 252)) : null;
          let maxDD = 0, peak = priceArr[0];
          for (const p of priceArr) { peak = Math.max(peak, p); maxDD = Math.min(maxDD, (p - peak) / peak); }
          fundamentals.maxDrawdown = maxDD * 100;
          const recentVol = volumeArr.slice(-20);
          fundamentals.avgVolume20d = recentVol.reduce((s,v) => s+v, 0) / recentVol.length;
          fundamentals.avgVolume50d = volumeArr.slice(-50).reduce((s,v) => s+v, 0) / Math.min(50, volumeArr.length);
          const last50 = priceArr.slice(-50);
          const last200 = priceArr.slice(-200);
          const ma50est = last50.length >= 50 ? last50.reduce((s,v) => s+v, 0) / 50 : null;
          const ma200est = last200.length >= 200 ? last200.reduce((s,v) => s+v, 0) / 200 : null;
          fundamentals.relStrength200 = ma200est && lastPrice ? ((lastPrice / ma200est - 1) * 100) : null;
          fundamentals.relStrength50 = ma50est && lastPrice ? ((lastPrice / ma50est - 1) * 100) : null;
          fundamentals.beta = fundamentals.annualVol > 0 ? Math.round((fundamentals.annualVol / 16) * 100) / 100 : null;
          const prices1y = priceArr.slice(-252);
          const h52 = Math.max(...prices1y);
          const l52 = Math.min(...prices1y.filter(p => p > 0));
          fundamentals.range52wPct = h52 > l52 ? ((lastPrice - l52) / (h52 - l52) * 100) : null;


          // 3. Sector peer data
          const PEER_DATA = {
            'Technology': [
              {name:'CrowdStrike',r40:42,ps:18},{name:'Datadog',r40:38,ps:16},{name:'ServiceNow',r40:48,ps:17},
              {name:'Palantir',r40:30,ps:25},{name:'Cloudflare',r40:15,ps:15},{name:'MongoDB',r40:22,ps:11},
              {name:'Shopify',r40:28,ps:12},{name:'HubSpot',r40:30,ps:10},{name:'Twilio',r40:8,ps:3},
              {name:'Elastic',r40:20,ps:7},{name:'Confluent',r40:5,ps:7},{name:'Asana',r40:-35,ps:3},
              {name:'Zoom',r40:10,ps:4},{name:'DocuSign',r40:18,ps:5},{name:'Dropbox',r40:32,ps:4},
              {name:'Box',r40:22,ps:4},{name:'Fastly',r40:-15,ps:3},{name:'Unity',r40:-8,ps:5},
            ],
            'Financial Services': [
              {name:'Visa',r40:50,ps:16},{name:'Mastercard',r40:48,ps:15},{name:'PayPal',r40:18,ps:3},
              {name:'Block',r40:10,ps:2},{name:'Adyen',r40:52,ps:12},{name:'Nu Holdings',r40:65,ps:9},
              {name:'PagSeguro',r40:15,ps:1.5},{name:'StoneCo',r40:20,ps:2},{name:'Fiserv',r40:30,ps:5},
              {name:'FIS',r40:15,ps:3},{name:'GPN',r40:12,ps:3},{name:'Bill.com',r40:18,ps:6},
              {name:'Affirm',r40:-5,ps:4},{name:'SoFi',r40:25,ps:4},{name:'Coinbase',r40:45,ps:8},
              {name:'MercadoLibre',r40:50,ps:5},{name:'Flywire',r40:20,ps:5},{name:'Repay',r40:5,ps:2},
            ],
            'Financials': [
              {name:'Visa',r40:50,ps:16},{name:'Mastercard',r40:48,ps:15},{name:'PayPal',r40:18,ps:3},
              {name:'Block',r40:10,ps:2},{name:'Nu Holdings',r40:65,ps:9},{name:'PagSeguro',r40:15,ps:1.5},
              {name:'StoneCo',r40:20,ps:2},{name:'Fiserv',r40:30,ps:5},{name:'FIS',r40:15,ps:3},
              {name:'Affirm',r40:-5,ps:4},{name:'SoFi',r40:25,ps:4},{name:'Coinbase',r40:45,ps:8},
            ],
            'Healthcare': [
              {name:'Veeva',r40:40,ps:12},{name:'Doximity',r40:35,ps:14},{name:'Hims & Hers',r40:50,ps:5},
              {name:'Teladoc',r40:-10,ps:1.5},{name:'GoodRx',r40:5,ps:3},{name:'Phreesia',r40:10,ps:4},
              {name:'Certara',r40:15,ps:6},{name:'Evolent',r40:25,ps:2},{name:'agilon',r40:-5,ps:1},
            ],
            'Consumer Cyclical': [
              {name:'Amazon',r40:35,ps:3},{name:'Tesla',r40:20,ps:10},{name:'Airbnb',r40:30,ps:8},
              {name:'Uber',r40:25,ps:4},{name:'DoorDash',r40:15,ps:5},{name:'Booking',r40:35,ps:7},
              {name:'Etsy',r40:8,ps:3},{name:'Carvana',r40:40,ps:1.5},{name:'DraftKings',r40:20,ps:4},
              {name:'Chewy',r40:5,ps:0.7},{name:'Wayfair',r40:-5,ps:0.5},
            ],
            'Communication Services': [
              {name:'Meta',r40:55,ps:9},{name:'Google',r40:42,ps:6},{name:'Netflix',r40:40,ps:8},
              {name:'Spotify',r40:30,ps:4},{name:'Pinterest',r40:22,ps:7},{name:'Snap',r40:-5,ps:3},
              {name:'Roblox',r40:10,ps:6},{name:'Trade Desk',r40:35,ps:20},{name:'Roku',r40:5,ps:2.5},
            ],
            'Industrials': [
              {name:'Paycom',r40:35,ps:8},{name:'Paylocity',r40:32,ps:9},{name:'Procore',r40:15,ps:10},
              {name:'Samsara',r40:20,ps:14},{name:'Cintas',r40:30,ps:5},
            ],
            'Consumer Defensive': [
              {name:'Costco',r40:25,ps:1.5},{name:'Walmart',r40:20,ps:0.8},{name:'Procter & Gamble',r40:18,ps:5},
              {name:'Coca-Cola',r40:15,ps:6},{name:'PepsiCo',r40:12,ps:3},
            ],
            'Energy': [
              {name:'Exxon',r40:20,ps:1.2},{name:'Chevron',r40:15,ps:1.3},{name:'ConocoPhillips',r40:18,ps:2},
              {name:'SLB',r40:22,ps:2.5},{name:'Halliburton',r40:12,ps:1.5},
            ],
          };
          // Industry-specific peer groups for better comps
          const INDUSTRY_PEERS = {
            'Residential Construction': [
              {name:'D.R. Horton',r40:25,ps:1.3},{name:'Lennar',r40:22,ps:1.2},{name:'NVR',r40:20,ps:2.5},
              {name:'PulteGroup',r40:20,ps:1.1},{name:'Toll Brothers',r40:18,ps:0.9},{name:'Meritage',r40:18,ps:1.0},
              {name:'Taylor Morrison',r40:15,ps:0.8},{name:'Dream Finders',r40:30,ps:0.7},{name:'Smith Douglas',r40:25,ps:1.5},
              {name:'KB Home',r40:15,ps:0.7},{name:'MDC Holdings',r40:12,ps:0.8},{name:'Century',r40:10,ps:0.6},
            ],
            'Credit Services': [
              {name:'Visa',r40:50,ps:16},{name:'Mastercard',r40:48,ps:15},{name:'AMEX',r40:25,ps:3},
              {name:'Capital One',r40:10,ps:1.5},{name:'Discover',r40:12,ps:2.5},{name:'PayPal',r40:18,ps:3},
              {name:'Block',r40:10,ps:2},{name:'Affirm',r40:-5,ps:4},{name:'SoFi',r40:25,ps:4},
              {name:'Corpay',r40:15,ps:5},{name:'Sezzle',r40:40,ps:3},{name:'Shift4',r40:35,ps:4},
              {name:'Toast',r40:25,ps:3.5},{name:'Fiserv',r40:20,ps:4},{name:'Remitly',r40:15,ps:3},
            ],
            'Softwareâ€”Application': [
              {name:'Salesforce',r40:35,ps:8},{name:'ServiceNow',r40:48,ps:17},{name:'Workday',r40:30,ps:9},
              {name:'HubSpot',r40:30,ps:10},{name:'Datadog',r40:38,ps:16},{name:'MongoDB',r40:22,ps:11},
            ],
            'Softwareâ€”Infrastructure': [
              {name:'CrowdStrike',r40:42,ps:18},{name:'Cloudflare',r40:15,ps:15},{name:'Palantir',r40:30,ps:25},
              {name:'Elastic',r40:20,ps:7},{name:'Fastly',r40:-15,ps:3},{name:'Zscaler',r40:25,ps:14},
              {name:'SentinelOne',r40:-5,ps:8},{name:'Twilio',r40:8,ps:3},
            ],
            'Semiconductors': [
              {name:'NVIDIA',r40:80,ps:30},{name:'AMD',r40:35,ps:10},{name:'Broadcom',r40:40,ps:15},
              {name:'TSMC',r40:35,ps:10},{name:'Qualcomm',r40:15,ps:4},{name:'Marvell',r40:20,ps:12},
            ],
            'Drug Manufacturers': [
              {name:'Eli Lilly',r40:30,ps:18},{name:'Novo Nordisk',r40:35,ps:14},{name:'Merck',r40:12,ps:4},
              {name:'Pfizer',r40:-5,ps:2.5},{name:'AbbVie',r40:8,ps:5},
            ],
            'Restaurants': [
              {name:"McDonald's",r40:18,ps:8},{name:'Starbucks',r40:12,ps:3},{name:'Chipotle',r40:30,ps:7},
              {name:'Wingstop',r40:40,ps:15},{name:'CAVA',r40:45,ps:10},{name:'Shake Shack',r40:15,ps:3},
            ],
          };
          const INDUSTRY_OVERRIDES = {
            'CPAY': 'Credit Services', 'GPN': 'Credit Services',
            'SEZL': 'Credit Services', 'FOUR': 'Credit Services', 'TOST': 'Credit Services',
          };
          const industry = INDUSTRY_OVERRIDES[t] || fundamentals.industry || '';
          const industryKey = Object.keys(INDUSTRY_PEERS).find(k =>
            industry.toLowerCase().includes(k.toLowerCase()) || k.toLowerCase().includes(industry.toLowerCase())
          );
          const sectorKey = fundamentals.sector ? Object.keys(PEER_DATA).find(k =>
            fundamentals.sector.toLowerCase().includes(k.toLowerCase()) ||
            k.toLowerCase().includes(fundamentals.sector.toLowerCase())
          ) : null;
          const usedSector = industryKey ? industry : (sectorKey || 'Technology');
          fundamentals._usedSector = usedSector;
          let sectorPeers = (industryKey ? INDUSTRY_PEERS[industryKey] : (PEER_DATA[sectorKey || 'Technology'] || PEER_DATA['Technology']))
            .filter(p => p.name.toUpperCase().replace(/[^A-Z]/g,'') !== t.replace(/[^A-Z]/g,''));
          // 4. Fetch sentiment - StockTwits + web search for broader coverage
          let sentimentData = { current: 0, bullish: 0, bearish: 0, total: 0, history: [], sources: [] };
          // StockTwits
          try {
            const stData = await fetchYF('https://api.stocktwits.com/api/2/streams/symbol/' + t + '.json');
            if (stData?.messages) {
              const msgs = stData.messages;
              let bull = 0, bear = 0;
              const dailyS = {};
              msgs.forEach(m => {
                const day = m.created_at?.substring(0, 10);
                if (!dailyS[day]) dailyS[day] = { bull: 0, bear: 0, total: 0 };
                dailyS[day].total++;
                if (m.entities?.sentiment?.basic === 'Bullish') { bull++; dailyS[day].bull++; }
                else if (m.entities?.sentiment?.basic === 'Bearish') { bear++; dailyS[day].bear++; }
              });
              sentimentData.bullish += bull;
              sentimentData.bearish += bear;
              sentimentData.total += msgs.length;
              sentimentData.sources.push({ name: 'StockTwits', count: msgs.length, bullish: bull, bearish: bear });
              Object.entries(dailyS).forEach(([date, d]) => {
                const existing = sentimentData.history.find(h => h.date === date);
                if (existing) { existing.bull += d.bull; existing.bear += d.bear; existing.total += d.total; }
                else sentimentData.history.push({ date, bull: d.bull, bear: d.bear, total: d.total });
              });
            }
          } catch (e) { console.warn('StockTwits fetch failed:', e); }
          // Try Reddit/pushshift-style for broader coverage
          try {
            const redditData = await fetchYF('https://www.reddit.com/search.json?q=' + t + '+stock&sort=new&limit=50&t=week');
            if (redditData?.data?.children) {
              const posts = redditData.data.children;
              let rbull = 0, rbear = 0;
              const dailyR = {};
              posts.forEach(p => {
                const post = p.data;
                const day = new Date(post.created_utc * 1000).toISOString().substring(0, 10);
                if (!dailyR[day]) dailyR[day] = { bull: 0, bear: 0, total: 0 };
                dailyR[day].total++;
                const title = (post.title || '').toLowerCase();
                const bullWords = ['bull', 'buy', 'long', 'moon', 'rocket', 'calls', 'undervalued', 'breakout', 'growth'];
                const bearWords = ['bear', 'sell', 'short', 'puts', 'overvalued', 'crash', 'dump', 'bubble', 'decline'];
                const bScore = bullWords.filter(w => title.includes(w)).length;
                const sScore = bearWords.filter(w => title.includes(w)).length;
                if (bScore > sScore) { rbull++; dailyR[day].bull++; }
                else if (sScore > bScore) { rbear++; dailyR[day].bear++; }
              });
              sentimentData.bullish += rbull;
              sentimentData.bearish += rbear;
              sentimentData.total += posts.length;
              sentimentData.sources.push({ name: 'Reddit', count: posts.length, bullish: rbull, bearish: rbear });
              Object.entries(dailyR).forEach(([date, d]) => {
                const existing = sentimentData.history.find(h => h.date === date);
                if (existing) { existing.bull += d.bull; existing.bear += d.bear; existing.total += d.total; }
                else sentimentData.history.push({ date, bull: d.bull, bear: d.bear, total: d.total });
              });
            }
          } catch (e) { console.warn('Reddit fetch failed:', e); }
          // Finalize sentiment
          sentimentData.history.sort((a, b) => a.date.localeCompare(b.date));
          sentimentData.history = sentimentData.history.map(h => ({
            ...h, score: h.total > 0 ? Math.round(((h.bull - h.bear) / h.total) * 100) : 0
          }));
          sentimentData.current = sentimentData.total > 0 ? Math.round(((sentimentData.bullish - sentimentData.bearish) / sentimentData.total) * 100) : 0;

          // Moving averages
          const computeMA = (data, period) => data.map((p, i) => i < period - 1 ? null : data.slice(i - period + 1, i + 1).reduce((s, d) => s + d.close, 0) / period);
          const ma50 = computeMA(points, 50);
          const ma200 = computeMA(points, 200);

          const currentPrice = meta.regularMarketPrice || points[points.length - 1].close;
          const high52 = meta.fiftyTwoWeekHigh || Math.max(...points.slice(-252).map(p => p.high));
          const low52 = meta.fiftyTwoWeekLow || Math.min(...points.slice(-252).map(p => p.low));
          const latestMA50 = ma50.filter(v => v !== null).pop() || currentPrice;
          const latestMA200 = ma200.filter(v => v !== null).pop() || currentPrice;
          const goldenCross = latestMA50 > latestMA200;

          // Volume
          const avgVol20 = points.slice(-20).reduce((s, p) => s + p.volume, 0) / 20;
          const avgVol90 = points.slice(-Math.min(60, points.length)).reduce((s, p) => s + p.volume, 0) / Math.min(60, points.length);
          const volTrend = avgVol90 > 0 ? ((avgVol20 / avgVol90) - 1) * 100 : 0;

          // RSI (14)
          const rsiChanges = [];
          for (let i = Math.max(0, points.length - 15); i < points.length - 1; i++) rsiChanges.push(points[i + 1].close - points[i].close);
          const rsiGains = rsiChanges.filter(c => c > 0);
          const rsiLosses = rsiChanges.filter(c => c < 0).map(c => Math.abs(c));
          const avgG = rsiGains.length > 0 ? rsiGains.reduce((s, g) => s + g, 0) / 14 : 0;
          const avgL = rsiLosses.length > 0 ? rsiLosses.reduce((s, l) => s + l, 0) / 14 : 0.001;
          const rsi = 100 - (100 / (1 + avgG / avgL));

          // MACD (12, 26, 9)
          const emaCalc = (data, period) => { const k = 2 / (period + 1); let e = data[0]?.close || 0; return data.map(p => { e = p.close * k + e * (1 - k); return e; }); };
          const ema12 = emaCalc(points, 12), ema26 = emaCalc(points, 26);
          const macdLine = ema12.map((v, i) => v - ema26[i]);
          let mSig = macdLine[0] || 0; const mK = 2 / 10;
          const macdSignal = macdLine.map(v => { mSig = v * mK + mSig * (1 - mK); return mSig; });
          const macdBullish = macdLine[macdLine.length - 1] > macdSignal[macdSignal.length - 1];

          // Bollinger Bands (20, 2)
          const bb20 = points.slice(-20);
          const bbMean = bb20.reduce((s, p) => s + p.close, 0) / 20;
          const bbStd = Math.sqrt(bb20.reduce((s, p) => s + (p.close - bbMean) ** 2, 0) / 20);
          const bbUpper = bbMean + 2 * bbStd, bbLower = bbMean - 2 * bbStd;
          const bbPosition = bbStd > 0 ? (currentPrice - bbLower) / (bbUpper - bbLower) : 0.5;

          // Volatility
          const ret30 = [];
          for (let i = Math.max(0, points.length - 31); i < points.length - 1; i++) ret30.push((points[i + 1].close - points[i].close) / points[i].close);
          const vol30 = Math.sqrt(ret30.reduce((s, r) => s + r * r, 0) / Math.max(ret30.length, 1)) * Math.sqrt(252) * 100;

          // Performance returns
          const perfAt = (n) => points.length > n ? ((currentPrice - points[points.length - 1 - n].close) / points[points.length - 1 - n].close) * 100 : null;
          const ret1w = perfAt(5), ret1m = perfAt(21), ret3m = perfAt(63), ret6m = perfAt(126), ret1y = perfAt(252);

          const pctFromHigh = ((currentPrice - high52) / high52) * 100;
          const pctFromLow = ((currentPrice - low52) / low52) * 100;
          const rangePosition = high52 > low52 ? (currentPrice - low52) / (high52 - low52) : 0.5;

          // Support / Resistance from pivot points
          const findLevels = (data, isSupport) => {
            const pivots = [];
            for (let i = 5; i < data.length - 5; i++) {
              const val = isSupport ? data[i].low : data[i].high;
              const slice = data.slice(i - 5, i + 6);
              const check = isSupport ? slice.every(p => p.low >= val - 0.01) : slice.every(p => p.high <= val + 0.01);
              if (check) pivots.push(val);
            }
            return [...new Set(pivots.map(p => Math.round(p * 100) / 100))].sort((a, b) => isSupport ? a - b : b - a);
          };
          const supports = findLevels(points.slice(-120), true);
          const resistances = findLevels(points.slice(-120), false);
          const support1 = supports.filter(s => s < currentPrice).pop() || currentPrice * 0.95;
          const support2 = supports.filter(s => s < support1).pop() || currentPrice * 0.90;
          const resistance1 = resistances.filter(r => r > currentPrice)[0] || currentPrice * 1.05;
          const resistance2 = resistances.filter(r => r > resistance1)[0] || currentPrice * 1.10;

          // ===== SCORING ENGINE =====
          let techScore = 5;
          if (currentPrice > latestMA50) techScore += 1;
          if (currentPrice > latestMA200) techScore += 1;
          if (goldenCross) techScore += 0.5;
          if (macdBullish) techScore += 0.5;
          if (rsi > 30 && rsi < 70) techScore += 0.5;
          if (rsi < 30) techScore -= 1;
          if (rsi > 70) techScore -= 0.5;
          if (ret1m != null && ret1m > 0) techScore += 0.5;
          if (ret3m != null && ret3m > 0) techScore += 0.5;
          if (bbPosition > 0.3 && bbPosition < 0.7) techScore += 0.5;
          techScore = Math.max(1, Math.min(10, Math.round(techScore)));
          const techTrend = techScore >= 7 ? 'bullish' : techScore <= 4 ? 'bearish' : 'neutral';

          let momentumScore = 5;
          if (ret1m != null && ret1m > 5) momentumScore += 1; else if (ret1m != null && ret1m < -5) momentumScore -= 1;
          if (ret3m != null && ret3m > 10) momentumScore += 1.5; else if (ret3m != null && ret3m < -10) momentumScore -= 1.5;
          if (ret6m != null && ret6m > 15) momentumScore += 1; else if (ret6m != null && ret6m < -15) momentumScore -= 1;
          if (volTrend > 20) momentumScore += 0.5;
          momentumScore = Math.max(1, Math.min(10, Math.round(momentumScore)));

          let volScore = 5;
          if (vol30 < 20) volScore += 2; else if (vol30 < 30) volScore += 1; else if (vol30 > 50) volScore -= 2; else if (vol30 > 40) volScore -= 1;
          if (Math.abs(pctFromHigh) < 10) volScore += 1;
          if (pctFromHigh < -30) volScore -= 1;
          volScore = Math.max(1, Math.min(10, Math.round(volScore)));

          let liqScore = 5;
          const dollarVolume = avgVol20 * currentPrice;
          if (dollarVolume > 100e6) liqScore += 2; else if (dollarVolume > 10e6) liqScore += 1; else if (dollarVolume < 1e6) liqScore -= 2;
          if (avgVol20 > 500000) liqScore += 1; else if (avgVol20 < 50000) liqScore -= 1;
          liqScore = Math.max(1, Math.min(10, Math.round(liqScore)));

          let trendScore = 5;
          const trendChecks = [ret1w, ret1m, ret3m, ret6m, ret1y].filter(r => r !== null);
          const positiveCount = trendChecks.filter(r => r > 0).length;
          trendScore += (positiveCount - 2.5) * 1.2;
          if (currentPrice > latestMA50 && latestMA50 > latestMA200) trendScore += 1;
          trendScore = Math.max(1, Math.min(10, Math.round(trendScore)));

          // Fundamentals score
          let fundScore = 5;
          // Use price-computed metrics we actually have
          if (fundamentals.return1y != null && fundamentals.return1y > 10) fundScore += 1;
          if (fundamentals.return1y != null && fundamentals.return1y > 25) fundScore += 0.5;
          if (fundamentals.sharpeEst != null && fundamentals.sharpeEst > 0.5) fundScore += 1;
          if (fundamentals.sharpeEst != null && fundamentals.sharpeEst > 1.0) fundScore += 0.5;
          if (fundamentals.annualVol != null && fundamentals.annualVol < 30) fundScore += 0.5;
          if (fundamentals.maxDrawdown != null && fundamentals.maxDrawdown > -20) fundScore += 0.5;
          if (fundamentals.range52wPct != null && fundamentals.range52wPct > 60) fundScore += 0.5;
          // Penalize poor metrics
          if (fundamentals.return1y != null && fundamentals.return1y < -10) fundScore -= 1;
          if (fundamentals.maxDrawdown != null && fundamentals.maxDrawdown < -40) fundScore -= 1;
          if (fundamentals.annualVol != null && fundamentals.annualVol > 50) fundScore -= 0.5;
          fundScore = Math.max(1, Math.min(10, Math.round(fundScore)));

          const compositeScore = Math.round((techScore * 0.20 + momentumScore * 0.20 + volScore * 0.10 + liqScore * 0.10 + trendScore * 0.15 + fundScore * 0.25) * 10);

          // Price targets â€” use analyst target if available, else momentum + mean reversion
          const analystTarget = fundamentals.targetMeanPrice || null;
          const momentumTarget = ret3m != null ? currentPrice * (1 + (ret3m / 100) * 0.5) : currentPrice * 1.08;
          const meanRevTarget = latestMA200 * (1 + (goldenCross ? 0.10 : -0.02));

          let priceTarget;
          if (analystTarget && analystTarget > currentPrice * 0.5 && analystTarget < currentPrice * 3) {
            priceTarget = analystTarget * 0.5 + momentumTarget * 0.25 + meanRevTarget * 0.25;
          } else {
            priceTarget = momentumTarget * 0.6 + meanRevTarget * 0.4;
          }
          // Sanity: if not a SHORT setup, target must provide meaningful upside
          // Score-based minimum upside: score 50 â†’ +5%, score 70 â†’ +15%, score 90 â†’ +25%
          const minUpside = compositeScore >= 32 ? Math.max(0.05, (compositeScore - 30) / 200) : 0;
          const minTarget = currentPrice * (1 + minUpside);
          if (compositeScore >= 32 && priceTarget < minTarget) {
            priceTarget = minTarget;
          }
          priceTarget = Math.round(priceTarget * 100) / 100;

          // Stop loss â€” tighter, based on ATR-like volatility
          const atrEstimate = vol30 / 100 * currentPrice / Math.sqrt(252) * Math.sqrt(20);
          const volBasedStop = currentPrice - 1.5 * atrEstimate;
          const supportStop = support1 > currentPrice * 0.90 ? support1 * 0.99 : currentPrice * 0.93;
          let stopLoss = Math.round(Math.max(volBasedStop, supportStop, currentPrice * 0.90) * 100) / 100;
          if (compositeScore >= 32) stopLoss = Math.max(stopLoss, Math.round(currentPrice * 0.90 * 100) / 100);

          const entryLow = Math.min(currentPrice, support1 > currentPrice * 0.95 ? support1 * 1.005 : currentPrice * 0.98);
          const entryHigh = currentPrice * 1.005;
          const upside = ((priceTarget - currentPrice) / currentPrice * 100).toFixed(1);
          const downside = ((stopLoss - currentPrice) / currentPrice * 100).toFixed(1);
          const rrRatio = Math.abs(parseFloat(downside)) > 0.5 ? (Math.abs(parseFloat(upside)) / Math.abs(parseFloat(downside))).toFixed(1) : '0.0';

          // Action & conviction â€” score drives direction, R/R adjusts conviction
          let action, conviction;
          const rr = parseFloat(rrRatio);
          if (compositeScore >= 72) { action = 'LONG'; conviction = rr >= 2.0 ? 5 : rr >= 1.0 ? 4 : rr >= 0.5 ? 3 : 2; }
          else if (compositeScore >= 62) { action = 'LONG'; conviction = rr >= 1.5 ? 4 : rr >= 1.0 ? 3 : rr >= 0.5 ? 2 : 2; }
          else if (compositeScore >= 52) { action = rr >= 0.5 ? 'LONG' : 'HOLD'; conviction = rr >= 1.0 ? 3 : 2; }
          else if (compositeScore >= 42) { action = 'HOLD'; conviction = 2; }
          else if (compositeScore >= 32) { action = 'AVOID'; conviction = 1; }
          else { action = 'SHORT'; conviction = Math.min(5, Math.round((40 - compositeScore) / 8) + 3); }
          // R/R sanity: only downgrade to HOLD for moderate scores with terrible R/R
          if (rr < 0.5 && action === 'LONG' && compositeScore < 65) { action = 'HOLD'; conviction = Math.min(conviction, 2); }
          // Only AVOID for genuinely poor setups (low score AND bad R/R)
          if (compositeScore < 45 && rr < 0.3 && parseFloat(upside) < 3) { action = 'AVOID'; conviction = 1; }
          // Override for SHORT
          if (action === 'SHORT') {
            priceTarget = Math.round(Math.min(support1, currentPrice * 0.90) * 100) / 100;
          }

          const oneLiner = action === 'LONG'
            ? t + ' scores ' + compositeScore + '/100 with ' + upside + '% upside and ' + rrRatio + ':1 R/R' + (analystTarget ? ' (analyst target $' + analystTarget.toFixed(0) + ')' : '')
            : action === 'SHORT'
            ? t + ' bearish at ' + compositeScore + '/100 â€” below key MAs, RSI ' + rsi.toFixed(0)
            : action === 'HOLD'
            ? t + ' scores ' + compositeScore + '/100 but R/R of ' + rrRatio + ':1 is insufficient for a LONG â€” wait for better entry'
            : t + ' scores ' + compositeScore + '/100 â€” avoid until setup improves';

          const techSummary = 'Price is ' + (currentPrice > latestMA50 ? 'above' : 'below') + ' the 50-day MA ($' + latestMA50.toFixed(2) + ') and ' + (currentPrice > latestMA200 ? 'above' : 'below') + ' the 200-day MA ($' + latestMA200.toFixed(2) + '). RSI at ' + rsi.toFixed(0) + ' indicates ' + (rsi > 70 ? 'overbought' : rsi < 30 ? 'oversold' : 'neutral momentum') + '. MACD is ' + (macdBullish ? 'bullish (above signal)' : 'bearish (below signal)') + '. Bollinger position at ' + (bbPosition * 100).toFixed(0) + '%.';

          const existingPos = currentIdeas.find(p => p.ticker === t);

          const analysis = {
            action, conviction, currentPrice, priceTarget: Math.round(priceTarget * 100) / 100,
            stopLoss, entryZone: { low: Math.round(entryLow * 100) / 100, high: Math.round(entryHigh * 100) / 100 },
            timeframe: '3-6 months', upside: (parseFloat(upside) >= 0 ? '+' : '') + upside + '%',
            downside: downside + '%', riskReward: rrRatio + ':1', oneLiner,
            technicals: { score: techScore, trend: techTrend, summary: techSummary,
              keyLevels: { support1, support2, resistance1, resistance2 },
              rsi: rsi.toFixed(1), macd: macdBullish ? 'Bullish' : 'Bearish',
              aboveMA50: currentPrice > latestMA50, aboveMA200: currentPrice > latestMA200, goldenCross },
            momentum: { score: momentumScore, ret1w, ret1m, ret3m, ret6m, ret1y, volTrend: volTrend.toFixed(1) },
            volatility: { score: volScore, vol30: vol30.toFixed(1), bbPosition: (bbPosition * 100).toFixed(0), bbUpper: bbUpper.toFixed(2), bbLower: bbLower.toFixed(2) },
            liquidity: { score: liqScore, avgVol20: Math.round(avgVol20), dollarVolume: Math.round(dollarVolume),
              summary: 'Avg daily volume: ' + (avgVol20 / 1e6).toFixed(2) + 'M shares ($' + (dollarVolume / 1e6).toFixed(0) + 'M). ' + (volTrend > 15 ? 'Volume rising.' : volTrend < -15 ? 'Volume declining.' : 'Volume stable.') },
            trend: { score: trendScore },
            scores: { tech: { rsi, macdBullish } },
            fundamentals: { ...fundamentals, score: fundScore },
            sentiment: sentimentData,
            compositeScore, high52, low52, pctFromHigh: pctFromHigh.toFixed(1), pctFromLow: pctFromLow.toFixed(1), rangePosition,
            existingPosition: existingPos ? { direction: existingPos.direction, conviction: existingPos.conviction, entryPrice: existingPos.entryPrice, thesis: existingPos.thesis, catalyst: existingPos.catalyst } : null
          };

          setAiChartData({ points, ma50, ma200, meta, currentPrice, high52, low52, latestMA50, latestMA200, support1, support2, resistance1, resistance2, bbUpper, bbLower });
          setAiResult(analysis);
        } catch (err) {
          console.error('Screener error:', err);
          setAiError(err.message || 'Analysis failed. Check the ticker and try again.');
        }
        setAiLoading(false);
      };

      // Render screener price chart
      useEffect(() => {
        if (activeTab !== 'screener' || !aiChartData || !aiResult || screenerTab !== 'overview') return;
        const timer = setTimeout(() => {
          if (!aiPriceChartRef.current) return;
          const ctx = aiPriceChartRef.current.getContext('2d');
          if (aiPriceChart.current) aiPriceChart.current.destroy();

          const { points, ma50, ma200 } = aiChartData;
          const rangeDays = { '1m': 21, '3m': 63, '6m': 126, '1y': 252, '2y': 504 };
          const ds = Math.max(0, points.length - (rangeDays[chartRange] || 126));
          const dp = points.slice(ds), dm50 = ma50.slice(ds), dm200 = ma200.slice(ds);
          const labels = dp.map(p => p.date.toLocaleDateString([], { month: 'short', day: 'numeric' }));

          const fLabels = [], fTarget = [], fBull = [], fBear = [];
          if (aiResult) {
            const last = dp[dp.length - 1]?.date || new Date();
            const tgt = aiResult.priceTarget || aiChartData.currentPrice;
            const stp = aiResult.stopLoss || aiChartData.currentPrice * 0.9;
            for (let i = 1; i <= 30; i++) {
              const d = new Date(last); d.setDate(d.getDate() + i * 3);
              fLabels.push(d.toLocaleDateString([], { month: 'short', day: 'numeric' }));
              const p = 1 - Math.pow(1 - i / 30, 2);
              fTarget.push(aiChartData.currentPrice + (tgt - aiChartData.currentPrice) * p);
              fBull.push(aiChartData.currentPrice + (tgt * 1.05 - aiChartData.currentPrice) * p);
              fBear.push(aiChartData.currentPrice + (stp - aiChartData.currentPrice) * p);
            }
          }

          const all = [...labels, ...fLabels];
          const pad = new Array(fLabels.length).fill(null);
          const pre = new Array(labels.length - 1).fill(null);
          const isUp = aiResult && aiResult.priceTarget > aiChartData.currentPrice;
          const suppLine = all.map(() => aiChartData.support1);
          const resLine = all.map(() => aiChartData.resistance1);

          aiPriceChart.current = new Chart(ctx, {
            type: 'line',
            data: { labels: all, datasets: [
              { label: aiTicker.toUpperCase(), data: [...dp.map(p => p.close), ...pad], borderColor: '#3b82f6', borderWidth: 2.5, tension: 0.3, pointRadius: 0, fill: false },
              { label: 'MA50', data: [...dm50, ...pad], borderColor: '#f59e0b', borderWidth: 1.5, borderDash: [5, 3], pointRadius: 0, fill: false, tension: 0.3 },
              { label: 'MA200', data: [...dm200, ...pad], borderColor: '#8b5cf6', borderWidth: 1.5, borderDash: [8, 4], pointRadius: 0, fill: false, tension: 0.3 },
              { label: 'Support', data: suppLine, borderColor: 'rgba(16, 185, 129, 0.3)', borderWidth: 1, borderDash: [2, 4], pointRadius: 0, fill: false },
              { label: 'Resistance', data: resLine, borderColor: 'rgba(239, 68, 68, 0.3)', borderWidth: 1, borderDash: [2, 4], pointRadius: 0, fill: false },
              ...(aiResult ? [
                { label: 'Target', data: [...pre, aiChartData.currentPrice, ...fTarget], borderColor: isUp ? '#10b981' : '#ef4444', borderWidth: 2.5, borderDash: [6, 3], pointRadius: 0, fill: false, tension: 0.3 },
                { label: 'Bull Case', data: [...pre, aiChartData.currentPrice, ...fBull], borderColor: 'rgba(16, 185, 129, 0.25)', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false, tension: 0.3 },
                { label: 'Stop Loss', data: [...pre, aiChartData.currentPrice, ...fBear], borderColor: 'rgba(239, 68, 68, 0.25)', borderWidth: 1, borderDash: [3, 3], pointRadius: 0, fill: false, tension: 0.3 },
              ] : [])
            ]},
            options: {
              responsive: true, maintainAspectRatio: false,
              interaction: { mode: 'index', intersect: false },
              scales: {
                y: { ticks: { color: '#94a3b8', callback: v => '$' + v.toFixed(0) }, grid: { color: '#1e293b' } },
                x: { ticks: { color: '#94a3b8', maxTicksLimit: 12, maxRotation: 0 }, grid: { display: false } }
              },
              plugins: { legend: { labels: { color: '#cbd5e1', usePointStyle: true, filter: item => !['Support','Resistance'].includes(item.text) } }, tooltip: { callbacks: { label: c => c.dataset.label + ': $' + (c.parsed.y?.toFixed(2) || '') } } }
            }
          });
        }, 300);
        return () => { clearTimeout(timer); if (aiPriceChart.current) { aiPriceChart.current.destroy(); aiPriceChart.current = null; } };
      }, [activeTab, aiChartData, aiResult, screenerTab, chartRange]);

      // Claude Chat
      // Local stock analysis engine (works without API)
      const generateLocalAnalysis = (ticker, result, question) => {
        const q = question.toLowerCase();
        const f = result.fundamentals || {};
        const price = result.currentPrice?.toFixed(2);
        const score = result.compositeScore;
        const direction = result.direction;
        const target = result.priceTarget?.toFixed(2);
        const stop = result.stopLoss?.toFixed(2);
        const rsi = result.scores?.tech?.rsi;
        const vol = f.annualVol?.toFixed(1);
        const dd = f.maxDrawdown?.toFixed(1);
        const sharpe = f.sharpeEst?.toFixed(2);
        const ret1m = f.return1m?.toFixed(1);
        const ret3m = f.return3m?.toFixed(1);
        const ret1y = f.return1y?.toFixed(1);
        const sector = f.sector || 'Unknown';
        const industry = f.industry || 'Unknown';
        const upside = target && price ? ((target - price) / price * 100).toFixed(1) : null;
        const downside = stop && price ? ((stop - price) / price * 100).toFixed(1) : null;

        if (q.includes('buy') || q.includes('should i') || q.includes('recommend')) {
          return `${ticker} scores ${score}/100 â†’ ${direction?.toUpperCase()} signal. Target: $${target} (${upside > 0 ? '+' : ''}${upside}%), Stop: $${stop} (${downside}%). RSI at ${rsi?.toFixed(0)} ${rsi > 70 ? '(overbought â€” consider waiting for pullback)' : rsi < 30 ? '(oversold â€” potential entry)' : '(neutral zone)'}. Annual vol is ${vol}% with max drawdown of ${dd}%. ${score >= 65 ? 'Strong setup â€” high conviction.' : score >= 45 ? 'Moderate setup â€” manage position size carefully.' : 'Weak setup â€” consider smaller position or pass.'}`;
        }
        if (q.includes('risk') || q.includes('downside') || q.includes('stop')) {
          return `Risk profile for ${ticker}: Annual volatility ${vol}%, max drawdown ${dd}%, estimated beta ${f.beta?.toFixed(1) || 'N/A'}. Stop loss at $${stop} (${downside}% from current). ${parseFloat(vol) > 35 ? 'HIGH volatility name â€” use smaller position size.' : parseFloat(vol) > 20 ? 'Moderate volatility â€” standard sizing appropriate.' : 'Lower volatility â€” can size up if conviction is high.'}${sharpe ? ' Sharpe estimate: ' + sharpe + (parseFloat(sharpe) > 0.5 ? ' (favorable risk/reward).' : ' (risk/reward needs monitoring).') : ''}`;
        }
        if (q.includes('technical') || q.includes('chart') || q.includes('momentum')) {
          return `${ticker} technicals: RSI ${rsi?.toFixed(0)} ${rsi > 70 ? 'ðŸ”´ overbought' : rsi < 30 ? 'ðŸŸ¢ oversold' : 'ðŸŸ¡ neutral'}. ${result.scores?.tech?.macdBullish ? 'MACD bullish' : 'MACD bearish'}. vs 50-DMA: ${f.relStrength50 ? (f.relStrength50 > 0 ? '+' : '') + f.relStrength50.toFixed(1) + '%' : 'N/A'}. vs 200-DMA: ${f.relStrength200 ? (f.relStrength200 > 0 ? '+' : '') + f.relStrength200.toFixed(1) + '%' : 'N/A'}. ${f.relStrength50 > 0 && f.relStrength200 > 0 ? 'Trading above both MAs â€” bullish structure.' : f.relStrength50 < 0 && f.relStrength200 < 0 ? 'Below both MAs â€” bearish structure.' : 'Mixed signals â€” trend transitioning.'}`;
        }
        if (q.includes('return') || q.includes('performance') || q.includes('how has')) {
          return `${ticker} performance: 1M ${ret1m ? (ret1m > 0 ? '+' : '') + ret1m + '%' : 'N/A'}, 3M ${ret3m ? (ret3m > 0 ? '+' : '') + ret3m + '%' : 'N/A'}, 1Y ${ret1y ? (ret1y > 0 ? '+' : '') + ret1y + '%' : 'N/A'}. 52-week range position: ${f.range52wPct?.toFixed(0) || 'N/A'}%. ${f.range52wPct > 80 ? 'Near 52-week highs â€” strong momentum but watch for resistance.' : f.range52wPct < 20 ? 'Near 52-week lows â€” potential value but confirm not a value trap.' : 'Mid-range â€” no extreme positioning.'}`;
        }
        if (q.includes('sector') || q.includes('industry') || q.includes('peers')) {
          return `${ticker} operates in ${sector} / ${industry}. The screener uses industry-specific peer comparisons for analysis. ${sector === 'Technology' ? 'Tech names typically command higher multiples but face higher vol.' : sector === 'Financial Services' ? 'Financials are rate-sensitive â€” monitor Fed policy.' : sector === 'Consumer Cyclical' ? 'Consumer cyclicals are GDP-sensitive â€” strong in expansions, weak in recessions.' : 'Sector dynamics vary â€” check Yahoo Finance links in Fundamentals tab for detailed comparisons.'}`;
        }
        // Default comprehensive summary
        return `${ticker} at $${price} | Score: ${score}/100 â†’ ${direction?.toUpperCase()}. Target $${target} (${upside > 0 ? '+' : ''}${upside}%), Stop $${stop} (${downside}%). Sector: ${sector}. RSI: ${rsi?.toFixed(0)}, Vol: ${vol}%, MaxDD: ${dd}%, Sharpe: ${sharpe || 'N/A'}. Returns â€” 1M: ${ret1m || 'N/A'}%, 3M: ${ret3m || 'N/A'}%, 1Y: ${ret1y || 'N/A'}%. ${score >= 65 ? 'Strong conviction setup.' : score >= 45 ? 'Moderate conviction â€” manage size.' : 'Low conviction â€” proceed with caution.'} Ask me about risk, technicals, performance, or whether to buy.`;
      };

      const sendChatMessage = async () => {
        if (!chatInput.trim() || !aiResult || chatLoading) return;
        const userMsg = chatInput.trim();
        setChatInput('');
        setChatMessages(prev => [...prev, { role: 'user', content: userMsg }]);
        setChatLoading(true);
        try {
          const ctx = 'Stock: ' + aiTicker + '. Price: $' + aiResult.currentPrice?.toFixed(2) + '. Score: ' + aiResult.compositeScore + '/100. RSI: ' + aiResult.scores?.tech?.rsi?.toFixed(0) + '. Vol: ' + (aiResult.fundamentals?.annualVol?.toFixed(1) || 'N/A') + '%. Beta: ' + (aiResult.fundamentals?.beta?.toFixed(2) || 'N/A') + '.';
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ model: "claude-sonnet-4-20250514", max_tokens: 1000,
              messages: [{ role: 'user', content: 'You are a senior equity analyst. Answer concisely about ' + aiTicker + '. Data: ' + ctx + ' Keep under 150 words. Question: ' + userMsg }] })
          });
          const data = await response.json();
          const reply = data.content?.map(c => c.text || '').join('') || 'Unable to get response.';
          setChatMessages(prev => [...prev, { role: 'assistant', content: reply }]);
        } catch (err) {
          // Fallback to local analysis engine
          const reply = generateLocalAnalysis(aiTicker, aiResult, userMsg);
          setChatMessages(prev => [...prev, { role: 'assistant', content: reply }]);
        }
        setChatLoading(false);
      };

      // Portfolio advisor - local analysis engine
      const sendPortfolioChat = async (msg) => {
        if (!msg.trim() || portfolioChatLoading) return;
        setPortfolioChatInput('');
        const newMsgs = [...portfolioChatMsgs, { role: 'user', content: msg }];
        setPortfolioChatMsgs(newMsgs);
        setPortfolioChatLoading(true);
        const a = analytics;
        const q = msg.toLowerCase();
        let reply = '';
        if (!a || !a.positions) {
          reply = 'Add some positions to your portfolio first, then I can analyze it.';
        } else {
          const topHoldings = a.positions.sort((x,y) => (y.allocation||0) - (x.allocation||0)).slice(0, 5).map(p => p.ticker + ' (' + (p.calcWeight * 100).toFixed(1) + '%)').join(', ');
          const sectors = a.sectorBreakdown ? Object.entries(a.sectorBreakdown).sort((x,y) => y[1] - x[1]).map(([s,w]) => s + ': ' + w.toFixed(0) + '%').join(', ') : 'N/A';
          const hasHist = a.sharpe != null && !isNaN(a.sharpe);
          if (q.includes('sharpe') || q.includes('risk-adjust') || q.includes('risk adjust')) {
            reply = hasHist ? `Your Sharpe ratio is ${a.sharpe.toFixed(2)}. ${a.sharpe > 1.0 ? 'Excellent â€” above 1.0 means strong risk-adjusted returns.' : a.sharpe > 0.5 ? 'Decent but room to improve.' : 'Below average.'} To improve: ${a.volatility > 0.15 ? 'Reduce position sizes in high-vol names to lower portfolio volatility.' : ''} ${a.positions.length < 8 ? 'Add more uncorrelated positions to diversify.' : ''} Consider trimming your most volatile holdings and adding more consistent performers.` : 'Run a backtest first to compute your Sharpe ratio. Go to the Tracker tab and click "Run Backtest."';
          } else if (q.includes('concentrat') || q.includes('diversif')) {
            const hhi = a.positions.reduce((s, p) => s + (p.calcWeight * 100) ** 2, 0);
            reply = `Your portfolio has ${a.positions.length} positions. Top 5: ${topHoldings}. HHI (concentration): ${hhi.toFixed(0)}. ${hhi > 1500 ? 'HIGH concentration â€” consider spreading capital more evenly.' : hhi > 800 ? 'Moderate concentration â€” reasonable if high conviction.' : 'Well diversified.'} ${a.positions.some(p => p.calcWeight > 0.15) ? 'Warning: some positions exceed 15% â€” single-name risk is elevated.' : 'No position dominates â€” good risk management.'}`;
          } else if (q.includes('sector') || q.includes('overweight') || q.includes('allocation')) {
            reply = `Sector allocation: ${sectors}. ${a.longExposure ? 'Long exposure: $' + (a.longExposure / 1e6).toFixed(1) + 'M, Short: $' + ((a.shortExposure || 0) / 1e6).toFixed(1) + 'M.' : ''} ${Object.values(a.sectorBreakdown || {}).some(v => v > 40) ? 'Warning: over 40% in one sector â€” you have significant sector concentration risk.' : 'Sector diversification looks reasonable.'}`;
          } else if (q.includes('drawdown') || q.includes('worst') || q.includes('loss')) {
            reply = hasHist ? `Max drawdown: ${a.maxDrawdown.toFixed(1)}%. ${a.maxDrawdown > -15 ? 'Well contained â€” strong risk management.' : a.maxDrawdown > -25 ? 'Moderate â€” acceptable for an equity portfolio.' : 'Significant drawdown â€” consider tighter stops or reducing position sizes.'} VaR 95%: ${a.var95.toFixed(1)}%. To reduce drawdown risk: use stop-losses, maintain cash reserves (5-10%), and avoid >10% in any single name.` : 'Run a backtest to compute drawdown metrics.';
          } else if (q.includes('winner') || q.includes('loser') || q.includes('best') || q.includes('worst')) {
            const sorted = [...a.positions].sort((x,y) => y.ret - x.ret);
            const winners = sorted.slice(0, 3).map(p => p.ticker + ' (' + (p.ret > 0 ? '+' : '') + (p.ret * 100).toFixed(1) + '%)').join(', ');
            const losers = sorted.slice(-3).reverse().map(p => p.ticker + ' (' + (p.ret * 100).toFixed(1) + '%)').join(', ');
            reply = `Top performers: ${winners}. Worst performers: ${losers}. Win rate: ${a.positions.filter(p => p.ret > 0).length}/${a.positions.length} positions profitable. ${a.positions.filter(p => p.ret < -0.1).length > 0 ? 'Consider cutting losers exceeding -10% to preserve capital.' : 'No major losses â€” portfolio is healthy.'}`;
          } else {
            reply = `Portfolio: ${a.positions.length} positions (${a.longs.length}L/${a.shorts.length}S). Return: ${a.portfolioReturn >= 0 ? '+' : ''}${a.portfolioReturn.toFixed(2)}%. P&L: $${(a.totalPnL / 1000).toFixed(1)}K. Top holdings: ${topHoldings}. ${hasHist ? 'Sharpe: ' + a.sharpe.toFixed(2) + ', Sortino: ' + a.sortino.toFixed(2) + ', MaxDD: ' + a.maxDrawdown.toFixed(1) + '%, Win Rate: ' + a.winRate.toFixed(0) + '%.' : 'Run a backtest for risk metrics.'} Ask about: risk, concentration, sectors, drawdown, winners/losers, or Sharpe ratio.`;
          }
        }
        // Try API first, fall back to local
        try {
          const ctx = a ? 'Portfolio: ' + a.positions.length + ' positions. Return: ' + a.portfolioReturn.toFixed(1) + '%. Top: ' + a.positions.slice(0,5).map(p => p.ticker).join(',') : '';
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST", headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ model: "claude-sonnet-4-20250514", max_tokens: 1000,
              messages: [{ role: 'user', content: 'Portfolio advisor. Data: ' + ctx + ' Question: ' + msg + '. Brief actionable advice under 100 words.' }] })
          });
          const data = await response.json();
          const apiReply = data.content?.map(c => c.text || '').join('');
          if (apiReply) reply = apiReply;
        } catch (e) { /* Use local reply */ }
        setPortfolioChatMsgs([...newMsgs, { role: 'assistant', content: reply }]);
        setPortfolioChatLoading(false);
      };

      // ============================================================
      // NEWS TAB FUNCTIONS
      // ============================================================
      const fetchNews = async () => {
        if (currentIdeas.length === 0) return;
        setNewsLoading(true);
        const tickers = currentIdeas.map(i => i.ticker);
        const allNews = [];
        const highPriorityKeywords = ['earnings', 'revenue', 'quarterly', 'Q1', 'Q2', 'Q3', 'Q4', 'acquisition', 'merger', 'IPO', 'FDA', 'SEC', 'lawsuit', 'guidance', 'forecast', 'beat', 'miss', 'upgrade', 'downgrade', 'outperform', 'underperform', 'overweight', 'underweight', 'price target', 'rating', 'initiated', 'dividend', 'buyback', 'restructur', 'layoff', 'CEO', 'CFO', 'partnership', 'contract', 'antitrust', 'offering'];

        // CORS proxy helper â€” same method the AI screener uses successfully
        const fetchViaProxy = async (url) => {
          const proxies = [
            'https://corsproxy.io/?' + encodeURIComponent(url),
            'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
            'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(url),
          ];
          for (const proxy of proxies) {
            try {
              const res = await fetch(proxy, { signal: AbortSignal.timeout(8000) });
              if (!res.ok) continue;
              return await res.json();
            } catch { continue; }
          }
          return null;
        };

        const fetchTextViaProxy = async (url) => {
          const proxies = [
            'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
            'https://corsproxy.io/?' + encodeURIComponent(url),
          ];
          for (const proxy of proxies) {
            try {
              const res = await fetch(proxy, { signal: AbortSignal.timeout(6000) });
              if (!res.ok) continue;
              return await res.text();
            } catch { continue; }
          }
          return null;
        };

        // PRIMARY: Yahoo Finance v1/search with newsCount (via CORS proxy, proven to work)
        for (const ticker of tickers) {
          try {
            const data = await fetchViaProxy('https://query1.finance.yahoo.com/v1/finance/search?q=' + ticker + '&newsCount=8&quotesCount=0');
            if (data && data.news) {
              data.news.forEach(article => {
                const title = article.title || '';
                if (!title || title.length < 10) return;
                const isHP = highPriorityKeywords.some(kw => title.toLowerCase().includes(kw.toLowerCase()));
                allNews.push({
                  id: article.uuid || Math.random().toString(36).substr(2, 9),
                  ticker,
                  title,
                  publisher: article.publisher || 'Unknown',
                  link: article.link || '#',
                  timestamp: article.providerPublishTime ? article.providerPublishTime * 1000 : Date.now(),
                  thumbnail: article.thumbnail?.resolutions?.[0]?.url || null,
                  isHighPriority: isHP,
                  relatedTickers: article.relatedTickers || [ticker],
                });
              });
            }
          } catch (e) { /* skip ticker */ }
        }

        // SUPPLEMENT: Google News RSS for tickers with few results
        const underserved = tickers.filter(t => allNews.filter(n => n.ticker === t).length < 2);
        for (const ticker of underserved.slice(0, 10)) {
          try {
            const rssUrl = 'https://news.google.com/rss/search?q=' + ticker + '+stock+when:7d&hl=en-US&gl=US&ceid=US:en';
            const xml = await fetchTextViaProxy(rssUrl);
            if (xml) {
              const items = xml.match(/<item>[\s\S]*?<\/item>/g) || [];
              items.slice(0, 4).forEach(item => {
                const getTag = (tag) => { const m = item.match(new RegExp('<' + tag + '>(.*?)</' + tag + '>')); return m ? m[1].replace(/<!\[CDATA\[(.*)\]\]>/g, '$1') : ''; };
                const title = getTag('title');
                const link = getTag('link');
                const pubDate = getTag('pubDate');
                const source = getTag('source') || 'Google News';
                if (title && title.length > 10) {
                  const cleanTitle = title.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                  const isHP = highPriorityKeywords.some(kw => cleanTitle.toLowerCase().includes(kw.toLowerCase()));
                  allNews.push({
                    id: Math.random().toString(36).substr(2, 9),
                    ticker,
                    title: cleanTitle,
                    publisher: source.replace(/&amp;/g, '&'),
                    link: link || '#',
                    timestamp: pubDate ? new Date(pubDate).getTime() : Date.now(),
                    thumbnail: null,
                    isHighPriority: isHP,
                    relatedTickers: [ticker],
                  });
                }
              });
            }
          } catch (e) { /* skip */ }
        }

        // FINAL FALLBACK: direct links
        if (allNews.length === 0) {
          tickers.forEach(t => {
            allNews.push(
              { id: 'inv-' + t, ticker: t, title: t + ' â€” latest analyst ratings, price targets & news', publisher: 'Investing.com', link: 'https://www.investing.com/equities/' + t.toLowerCase() + '-news', timestamp: Date.now(), thumbnail: null, isHighPriority: false, relatedTickers: [t] },
              { id: 'yf-' + t, ticker: t, title: t + ' â€” earnings, headlines & SEC filings', publisher: 'Yahoo Finance', link: 'https://finance.yahoo.com/quote/' + t + '/news/', timestamp: Date.now(), thumbnail: null, isHighPriority: false, relatedTickers: [t] },
              { id: 'sa-' + t, ticker: t, title: t + ' â€” deep analysis & Wall Street research', publisher: 'Seeking Alpha', link: 'https://seekingalpha.com/symbol/' + t + '/news', timestamp: Date.now(), thumbnail: null, isHighPriority: false, relatedTickers: [t] }
            );
          });
        }

        // Dedupe
        const seen = new Set();
        const deduped = allNews.filter(n => {
          const key = n.title.substring(0, 50).toLowerCase();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });

        // Sort: high priority first, then by time desc
        deduped.sort((a, b) => {
          if (a.isHighPriority && !b.isHighPriority) return -1;
          if (!a.isHighPriority && b.isHighPriority) return 1;
          return b.timestamp - a.timestamp;
        });

        setNewsItems(deduped);
        setNewsLastFetch(new Date());
        setNewsLoading(false);
      };
      // Auto-fetch news when switching to news tab
      useEffect(() => {
        if (activeTab === 'news' && newsItems.length === 0 && !newsLoading && currentIdeas.length > 0) {
          fetchNews();
        }
      }, [activeTab]);

      // Generate PM note
      // ============================================================
      // WATCHLIST FUNCTIONS
      // ============================================================
      const wlFetchPrices = async (tickers) => {
        if (!tickers || tickers.length === 0) return;
        setWlLoading(true);
        const proxies = [
          (u) => 'https://corsproxy.io/?' + encodeURIComponent(u),
          (u) => 'https://api.allorigins.win/raw?url=' + encodeURIComponent(u),
        ];
        const results = { ...wlPrices };

        for (const ticker of tickers) {
          try {
            const url = 'https://query1.finance.yahoo.com/v8/finance/chart/' + ticker + '?range=1y&interval=1d';
            let data = null;
            for (const mkProxy of proxies) {
              try {
                const res = await fetch(mkProxy(url), { signal: AbortSignal.timeout(8000) });
                if (!res.ok) continue;
                data = await res.json();
                break;
              } catch { continue; }
            }
            if (!data?.chart?.result?.[0]) continue;
            const r = data.chart.result[0];
            const meta = r.meta || {};
            const closes = r.indicators?.quote?.[0]?.close || [];
            const timestamps = r.timestamp || [];

            // Build clean price series with timestamps
            const series = [];
            for (let i = 0; i < closes.length; i++) {
              if (closes[i] != null && closes[i] > 0 && timestamps[i]) {
                series.push({ date: new Date(timestamps[i] * 1000), close: closes[i] });
              }
            }
            if (series.length < 2) continue;

            const last = series[series.length - 1].close;
            const prevClose = series.length >= 2 ? series[series.length - 2].close : last;
            const chg = last - prevClose;
            const chgPct = prevClose > 0 ? (chg / prevClose) * 100 : 0;

            // Find price closest to a target date
            const priceAt = (targetDate) => {
              for (let i = series.length - 1; i >= 0; i--) {
                if (series[i].date <= targetDate) return series[i].close;
              }
              return series[0].close;
            };

            const retFrom = (targetDate) => {
              const old = priceAt(targetDate);
              return old > 0 ? ((last - old) / old) * 100 : null;
            };

            const now = new Date();
            const dayOfWeek = now.getDay();
            const mondayOffset = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
            const lastMonday = new Date(now); lastMonday.setDate(now.getDate() - mondayOffset); lastMonday.setHours(0,0,0,0);
            const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const mo1Ago = new Date(now); mo1Ago.setMonth(mo1Ago.getMonth() - 1);
            const mo3Ago = new Date(now); mo3Ago.setMonth(mo3Ago.getMonth() - 3);
            const yearStart = new Date(now.getFullYear(), 0, 1);
            const mo12Ago = new Date(now); mo12Ago.setFullYear(mo12Ago.getFullYear() - 1);

            results[ticker] = {
              name: meta.shortName || meta.longName || ticker,
              last, chg, chgPct,
              wtd: retFrom(lastMonday),
              mo1: retFrom(mo1Ago),
              mtd: retFrom(monthStart),
              mo3: retFrom(mo3Ago),
              ytd: retFrom(yearStart),
              mo12: retFrom(mo12Ago),
            };
          } catch (e) { /* skip ticker */ }
        }

        setWlPrices(results);
        setWlLoading(false);
      };

      // Auto-fetch prices when switching to watchlist tab
      useEffect(() => {
        if (activeTab === 'watchlist' && watchlist.length > 0 && Object.keys(wlPrices).length === 0) {
          wlFetchPrices(watchlist);
        }
      }, [activeTab]);

      const wlAddTickers = async (tickers) => {
        const newTickers = tickers.filter(t => t && !watchlist.includes(t.toUpperCase())).map(t => t.toUpperCase());
        if (newTickers.length === 0) return;
        setWatchlist(prev => [...prev, ...newTickers]);
        await wlFetchPrices([...watchlist, ...newTickers]);
      };

      const wlRemoveTicker = (ticker) => {
        setWatchlist(prev => prev.filter(t => t !== ticker));
        const newSectors = { ...wlSectors };
        delete newSectors[ticker];
        setWlSectors(newSectors);
      };

      const wlImportFromPortfolio = async () => {
        const portfolioTickers = currentIdeas.map(i => i.ticker);
        await wlAddTickers(portfolioTickers);
      };

      const wlClassifySectors = async () => {
        setWlClassifying(true);
        const unclassified = watchlist.filter(t => !wlSectors[t] || wlSectors[t] === 'Uncategorized');
        if (unclassified.length === 0) { setWlClassifying(false); return; }

        const tickerInfo = unclassified.map(t => {
          const p = wlPrices[t];
          return t + (p?.name ? ' (' + p.name + ')' : '');
        }).join(', ');

        // Try Claude API first
        let classified = false;
        try {
          const response = await fetch("https://api.anthropic.com/v1/messages", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              model: "claude-sonnet-4-20250514",
              max_tokens: 2000,
              messages: [{ role: 'user', content: 'Classify these stocks into subsector groups. Return ONLY a JSON object mapping ticker to subsector name. Keep subsector names short (2-4 words). Group similar companies together.\n\nStocks: ' + tickerInfo + '\n\nExample: {"AAPL":"Consumer Electronics","MSFT":"Enterprise Software"}\n\nReturn ONLY the JSON, no markdown, no explanation.' }]
            })
          });
          const data = await response.json();
          const text = (data.content || []).map(c => c.text || '').join('');
          const jsonMatch = text.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const sectors = JSON.parse(jsonMatch[0]);
            if (Object.keys(sectors).length > 0) {
              setWlSectors(prev => ({ ...prev, ...sectors }));
              classified = true;
            }
          }
        } catch (e) { /* continue to fallback */ }

        // Fallback: use Yahoo search API to get industry for each ticker
        if (!classified) {
          const proxyFetch = async (url) => {
            const proxies = [
              'https://corsproxy.io/?' + encodeURIComponent(url),
              'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
            ];
            for (const proxy of proxies) {
              try {
                const res = await fetch(proxy, { signal: AbortSignal.timeout(6000) });
                if (!res.ok) continue;
                return await res.json();
              } catch { continue; }
            }
            return null;
          };

          const newSectors = {};
          for (const t of unclassified) {
            try {
              const data = await proxyFetch('https://query1.finance.yahoo.com/v1/finance/search?q=' + t + '&quotesCount=1&newsCount=0');
              const quote = data?.quotes?.[0];
              if (quote?.industry) {
                newSectors[t] = quote.industry;
              } else if (quote?.sector) {
                newSectors[t] = quote.sector;
              } else {
                newSectors[t] = 'Other';
              }
            } catch { newSectors[t] = 'Other'; }
          }
          setWlSectors(prev => ({ ...prev, ...newSectors }));
        }
        setWlClassifying(false);
      };

      // Sentiment chart with time range filtering
      useEffect(() => {
        if (activeTab !== 'screener' || screenerTab !== 'sentiment' || !aiResult?.sentiment?.history?.length || !sentimentChartRef.current) return;
        const timer = setTimeout(() => {
          if (!sentimentChartRef.current) return;
          const sctx = sentimentChartRef.current.getContext('2d');
          if (sentimentChart.current) sentimentChart.current.destroy();
          let hist = aiResult.sentiment.history;
          // Apply time range filter
          if (sentimentRange !== 'all' && sentimentRange !== 'custom') {
            const daysMap = { '1w': 7, '1m': 30, '3m': 90, '6m': 180, '1y': 365 };
            const days = daysMap[sentimentRange] || 9999;
            const cutoff = new Date(); cutoff.setDate(cutoff.getDate() - days);
            const cutStr = cutoff.toISOString().substring(0, 10);
            hist = hist.filter(h => h.date >= cutStr);
          }
          if (hist.length === 0) hist = aiResult.sentiment.history;
          sentimentChart.current = new Chart(sctx, {
            type: 'line',
            data: { labels: hist.map(h => h.date.substring(5)),
              datasets: [
                { label: 'Sentiment', data: hist.map(h => h.score),
                  borderColor: '#3b82f6', borderWidth: 2, backgroundColor: 'rgba(59,130,246,0.1)', fill: true, tension: 0.4, pointRadius: 3, pointBackgroundColor: hist.map(h => h.score > 0 ? '#10b981' : h.score < 0 ? '#ef4444' : '#94a3b8') },
                { label: 'Zero', data: hist.map(() => 0), borderColor: '#475569', borderWidth: 1, borderDash: [4, 4], pointRadius: 0, fill: false }
              ] },
            options: { responsive: true, maintainAspectRatio: false,
              scales: { y: { min: -100, max: 100, ticks: { color: '#94a3b8' }, grid: { color: '#1e293b' } }, x: { ticks: { color: '#94a3b8', maxRotation: 45 }, grid: { display: false } } },
              plugins: { legend: { display: false } } }
          });
        }, 200);
        return () => { clearTimeout(timer); if (sentimentChart.current) { sentimentChart.current.destroy(); sentimentChart.current = null; } };
      }, [activeTab, screenerTab, aiResult, sentimentRange]);


      useEffect(() => { chatEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [chatMessages]);

      const AIScreenerTab = () => {
        const sc = (s, max = 10) => { const p = s / max; return p >= 0.7 ? 'text-green-400' : p >= 0.4 ? 'text-yellow-400' : 'text-red-400'; };
        const sbar = (s, max = 10) => { const pct = (s / max) * 100; const c = pct >= 70 ? '#10b981' : pct >= 40 ? '#f59e0b' : '#ef4444'; return <div className="w-full bg-slate-700 rounded-full h-2 mt-1"><div className="h-2 rounded-full" style={{ width: pct + '%', backgroundColor: c }}></div></div>; };
        const fmtB = (n) => n == null ? 'N/A' : n >= 1e12 ? '$' + (n / 1e12).toFixed(1) + 'T' : n >= 1e9 ? '$' + (n / 1e9).toFixed(1) + 'B' : n >= 1e6 ? '$' + (n / 1e6).toFixed(0) + 'M' : '$' + n.toFixed(0);
        const fmtPct = (n) => n == null ? 'N/A' : (n * 100).toFixed(1) + '%';
        const portfolioTickers = showAllPortfolio ? positionsWithSizes : positionsWithSizes.slice(0, 20);
        const yfLink = 'https://finance.yahoo.com/quote/' + aiTicker;
        const MR = ({ label, tipKey, value, vc, page }) => (
          <div className="flex justify-between items-center py-1.5 border-b border-slate-700/30">
            <Tip label={label} tipKey={tipKey} />
            <a href={page ? (yfLink + '/' + page) : yfLink} target="_blank" rel="noopener noreferrer" className={'font-mono font-bold text-sm hover:underline ' + (vc || 'text-white')} title="View on Yahoo Finance">{value}</a>
          </div>
        );

        return (
          <div className="space-y-4">
            <div><h2 className="text-xl font-bold text-white flex items-center gap-2 mb-2">ðŸ¤– Stock Screener</h2>
              <p className="text-sm text-slate-400 mb-4">Live data + fundamentals + sentiment + AI chat. Hover any metric for definitions.</p></div>

            {/* Input */}
            <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
              <div className="flex flex-wrap gap-3 items-end">
                <div><label className="text-xs text-slate-400 block mb-1">Ticker</label>
                  <input value={aiTicker} onChange={(e) => setAiTicker(e.target.value.toUpperCase())} onKeyDown={(e) => e.key === 'Enter' && runAIScreener(aiTicker)} placeholder="AAPL" className="px-4 py-2.5 bg-slate-700 text-white rounded-lg border border-slate-600 font-mono text-lg w-32" /></div>
                <button onClick={() => runAIScreener(aiTicker)} disabled={aiLoading || !aiTicker} className="px-6 py-2.5 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-500 hover:to-purple-500 rounded-lg font-bold transition-all disabled:opacity-50 shadow-lg shadow-blue-600/20">
                  {aiLoading ? 'â³ Analyzing...' : 'ðŸ” Analyze'}</button>
                <div className="flex-1 min-w-0"><label className="text-xs text-slate-400 block mb-1">Quick Select from Portfolio</label>
                  <div className="flex flex-wrap gap-1.5">
                    {portfolioTickers.map(p => (
                      <button key={p.id} onClick={() => { setAiTicker(p.ticker); runAIScreener(p.ticker); }} className={`px-2 py-1 rounded text-xs font-mono transition-all ${aiTicker === p.ticker ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}>{p.ticker}</button>
                    ))}
                    {positionsWithSizes.length > 20 && (
                      <button onClick={() => setShowAllPortfolio(!showAllPortfolio)} className="px-2 py-1 rounded text-xs font-mono bg-slate-600 text-blue-300 hover:bg-slate-500 transition-all">
                        {showAllPortfolio ? 'âˆ’ Show less' : '+ ' + (positionsWithSizes.length - 20) + ' more'}</button>
                    )}
                  </div>
                </div>
              </div>
            </div>

            {aiError && <div className="bg-red-500/10 border border-red-500/30 rounded-xl p-4 text-red-400 text-sm">{aiError}</div>}

            {aiLoading && (
              <div className="bg-slate-800/80 rounded-xl p-16 border border-slate-700 flex flex-col items-center gap-4">
                <div className="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                <p className="text-slate-300 font-medium">Analyzing {aiTicker}...</p>
                <p className="text-slate-500 text-sm">Fetching 2 years of data, computing technicals, scoring...</p>
              </div>
            )}

            {aiResult && !aiLoading && (<>
              {/* HERO */}
              <div className={`rounded-xl p-6 border-2 ${aiResult.action === 'LONG' ? 'bg-green-500/5 border-green-500/30' : aiResult.action === 'SHORT' ? 'bg-red-500/5 border-red-500/30' : 'bg-slate-800 border-slate-600'}`}>
                <div className="flex flex-wrap justify-between items-start gap-4">
                  <div>
                    <div className="flex items-center gap-3 mb-2">
                      <span className="text-4xl font-black font-mono">{aiTicker}</span>
                      <span className={`px-4 py-2 rounded-lg text-lg font-black ${aiResult.action === 'LONG' ? 'bg-green-500/20 text-green-400' : aiResult.action === 'SHORT' ? 'bg-red-500/20 text-red-400' : aiResult.action === 'HOLD' ? 'bg-yellow-500/20 text-yellow-400' : 'bg-slate-600 text-slate-300'}`}>
                        {aiResult.action === 'LONG' ? 'â†—' : aiResult.action === 'SHORT' ? 'â†˜' : 'â†’'} {aiResult.action}</span>
                      <span className="text-2xl font-bold" style={{ color: ['#94a3b8','#64748b','#3b82f6','#f59e0b','#ef4444'][aiResult.conviction - 1] }}>{aiResult.conviction}/5</span>
                    </div>
                    <p className="text-lg text-slate-300 italic mb-3">"{aiResult.oneLiner}"</p>
                    <div className="flex flex-wrap gap-6 text-sm">
                      <div><span className="text-slate-400">Current</span><p className="text-xl font-bold font-mono">${aiResult.currentPrice?.toFixed(2)}</p></div>
                      <div><span className="text-slate-400">Target</span><p className={`text-xl font-bold font-mono ${aiResult.priceTarget > aiResult.currentPrice ? 'text-green-400' : 'text-red-400'}`}>${aiResult.priceTarget?.toFixed(2)}</p></div>
                      <div><span className="text-slate-400">Stop Loss</span><p className="text-xl font-bold font-mono text-red-400">${aiResult.stopLoss?.toFixed(2)}</p></div>
                      <div><span className="text-slate-400">Entry Zone</span><p className="text-xl font-bold font-mono">${aiResult.entryZone?.low?.toFixed(2)} â€” ${aiResult.entryZone?.high?.toFixed(2)}</p></div>
                    </div>
                  </div>
                  <div className="text-right">
                    <div className="text-xs text-slate-400 uppercase mb-1">Composite Score</div>
                    <div className={`text-5xl font-black font-mono ${sc(aiResult.compositeScore, 100)}`}>{aiResult.compositeScore}</div>
                    <div className="text-xs text-slate-500">/100</div>
                    <div className="flex gap-3 mt-2 text-sm">
                      <div><span className="text-slate-400">Upside</span><p className="text-green-400 font-bold">{aiResult.upside}</p></div>
                      <div><span className="text-slate-400">Downside</span><p className="text-red-400 font-bold">{aiResult.downside}</p></div>
                      <div><span className="text-slate-400">R:R</span><p className={`font-bold ${parseFloat(aiResult.riskReward) >= 2 ? 'text-green-400' : parseFloat(aiResult.riskReward) >= 1 ? 'text-yellow-400' : 'text-red-400'}`}>{aiResult.riskReward}</p></div>
                    </div>
                    <div className="text-xs text-slate-500 mt-1">Timeframe: {aiResult.timeframe}</div>
                  </div>
                </div>
              </div>

              {/* Existing position */}
              {aiResult.existingPosition && (
                <div className="bg-blue-500/10 border border-blue-500/30 rounded-xl p-4">
                  <h4 className="text-sm font-bold text-blue-400 mb-1">ðŸ“Œ Existing Position</h4>
                  <p className="text-sm text-slate-300">{aiResult.existingPosition.direction.toUpperCase()} at ${aiResult.existingPosition.entryPrice?.toFixed(2)}, conviction {aiResult.existingPosition.conviction}/5{aiResult.existingPosition.thesis ? '. Thesis: ' + aiResult.existingPosition.thesis : ''}</p>
                </div>
              )}

              {/* Sub-tabs */}
              <div className="flex gap-1 bg-slate-800 rounded-lg p-1 border border-slate-700 flex-wrap">
                {[['overview','ðŸ“ˆ Overview'],['fundamentals','ðŸ“Š Fundamentals'],['sentiment','ðŸ—£ï¸ Sentiment'],['chat','ðŸ’¬ Ask Claude']].map(([key, label]) => (
                  <button key={key} onClick={() => setScreenerTab(key)} className={'px-4 py-2 rounded-md text-xs font-semibold transition-all ' + (screenerTab === key ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-700')}>{label}</button>
                ))}
              </div>

              {/* === OVERVIEW === */}
              {screenerTab === 'overview' && (<>
              {/* Chart */}
              <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                <h3 className="text-sm font-semibold text-slate-300 mb-3">ðŸ“ˆ Price Chart with Target Projection</h3>
                <div className="flex items-center justify-between mb-2">
                  <span className="text-xs text-slate-400">Price Chart with Projections</span>
                  <div className="flex gap-1">
                    {['1m','3m','6m','1y','2y'].map(r => (
                      <button key={r} onClick={() => setChartRange(r)} className={'px-2 py-0.5 text-xs rounded ' + (chartRange === r ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600')}>{r.toUpperCase()}</button>
                    ))}
                  </div>
                </div>
                <div style={{ height: '350px' }}><canvas ref={aiPriceChartRef}></canvas></div>
                <div className="flex flex-wrap gap-4 mt-3 text-xs">
                  <span className="text-green-400">S1: ${aiResult.technicals.keyLevels.support1.toFixed(2)} | S2: ${aiResult.technicals.keyLevels.support2.toFixed(2)}</span>
                  <span className="text-red-400">R1: ${aiResult.technicals.keyLevels.resistance1.toFixed(2)} | R2: ${aiResult.technicals.keyLevels.resistance2.toFixed(2)}</span>
                </div>
              </div>

              {/* Score cards */}
              <div className="grid grid-cols-2 md:grid-cols-6 gap-3">
                {[
                  { label: 'Technicals', score: aiResult.technicals?.score, icon: 'ðŸ“ˆ', tipKey: 'techScore' },
                  { label: 'Momentum', score: aiResult.momentum?.score, icon: 'ðŸš€', tipKey: 'momentum' },
                  { label: 'Fundamentals', score: aiResult.fundamentals?.score, icon: 'ðŸ“Š', tipKey: 'pe' },
                  { label: 'Volatility', score: aiResult.volatility?.score, icon: 'ðŸ“‰', tipKey: 'vol30' },
                  { label: 'Liquidity', score: aiResult.liquidity?.score, icon: 'ðŸ’§', tipKey: 'liquidity' },
                  { label: 'Trend', score: aiResult.trend?.score, icon: 'ðŸ“', tipKey: 'trendScore' },
                ].map(item => (
                  <Tip key={item.label} label={item.label} tipKey={item.tipKey}>
                    <div className="bg-slate-800/80 rounded-xl p-4 border border-slate-700/50 cursor-help">
                      <div className="flex items-center gap-2 mb-1"><span>{item.icon}</span><span className="text-xs text-slate-400">{item.label}</span></div>
                      <p className={`text-2xl font-bold font-mono ${sc(item.score || 0)}`}>{item.score || 'N/A'}<span className="text-xs text-slate-500">/10</span></p>
                      {item.score && sbar(item.score)}
                    </div>
                  </Tip>
                ))}
              </div>

              {/* Detail panels */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Technicals */}
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <h3 className="text-sm font-semibold text-slate-300 mb-3 flex items-center gap-2">ðŸ“ˆ Technical Analysis <span className={`font-mono ${sc(aiResult.technicals?.score)}`}>{aiResult.technicals?.score}/10</span></h3>
                  <p className="text-sm text-slate-300 mb-3">{aiResult.technicals?.summary}</p>
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    {[
                      ['RSI (14)', 'rsi', aiResult.technicals.rsi, parseFloat(aiResult.technicals.rsi) > 70 ? 'text-red-400' : parseFloat(aiResult.technicals.rsi) < 30 ? 'text-green-400' : 'text-white'],
                      ['MACD', 'macd', aiResult.technicals.macd, aiResult.technicals.macd === 'Bullish' ? 'text-green-400' : 'text-red-400'],
                      ['Above MA50', 'ma50', aiResult.technicals.aboveMA50 ? 'âœ“' : 'âœ—', aiResult.technicals.aboveMA50 ? 'text-green-400' : 'text-red-400'],
                      ['Above MA200', 'ma200', aiResult.technicals.aboveMA200 ? 'âœ“' : 'âœ—', aiResult.technicals.aboveMA200 ? 'text-green-400' : 'text-red-400'],
                      ['Golden Cross', 'goldenCross', aiResult.technicals.goldenCross ? 'âœ“' : 'âœ—', aiResult.technicals.goldenCross ? 'text-green-400' : 'text-red-400'],
                      ['Bollinger Pos', 'bollinger', aiResult.technicals.bbPosition + '%', 'text-white'],
                    ].map(([label, tk, val, color]) => (
                      <div key={label} className="bg-slate-700/30 rounded p-2"><Tip label={label} tipKey={tk} /><span className={`float-right font-bold ${color}`}>{val}</span></div>
                    ))}
                  </div>
                </div>

                {/* Momentum */}
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <h3 className="text-sm font-semibold text-slate-300 mb-3 flex items-center gap-2">ðŸš€ Momentum <span className={`font-mono ${sc(aiResult.momentum?.score)}`}>{aiResult.momentum?.score}/10</span></h3>
                  <div className="space-y-2">
                    {[['1 Week', aiResult.momentum.ret1w], ['1 Month', aiResult.momentum.ret1m], ['3 Months', aiResult.momentum.ret3m], ['6 Months', aiResult.momentum.ret6m], ['1 Year', aiResult.momentum.ret1y]].map(([label, val]) => val !== null && (
                      <div key={label} className="flex items-center justify-between text-sm">
                        <span className="text-slate-400">{label}</span>
                        <div className="flex items-center gap-2">
                          <div className="w-20 bg-slate-700 rounded-full h-1.5"><div className={`h-1.5 rounded-full ${val >= 0 ? 'bg-green-500' : 'bg-red-500'}`} style={{ width: Math.min(100, Math.abs(val) * 2) + '%', marginLeft: val < 0 ? 'auto' : 0 }}></div></div>
                          <span className={`font-mono font-bold w-16 text-right ${val >= 0 ? 'text-green-400' : 'text-red-400'}`}>{val >= 0 ? '+' : ''}{val.toFixed(1)}%</span>
                        </div>
                      </div>
                    ))}
                    <div className="flex items-center justify-between text-sm mt-2 pt-2 border-t border-slate-700">
                      <span className="text-slate-400">Volume Trend (20d vs 90d)</span>
                      <span className={`font-mono font-bold ${parseFloat(aiResult.momentum.volTrend) > 0 ? 'text-green-400' : 'text-red-400'}`}>{parseFloat(aiResult.momentum.volTrend) > 0 ? '+' : ''}{aiResult.momentum.volTrend}%</span>
                    </div>
                  </div>
                </div>

                {/* Volatility */}
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <h3 className="text-sm font-semibold text-slate-300 mb-3 flex items-center gap-2">ðŸ“Š Volatility & Range <span className={`font-mono ${sc(aiResult.volatility?.score)}`}>{aiResult.volatility?.score}/10</span></h3>
                  <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="bg-slate-700/30 rounded-lg p-3"><span className="text-xs text-slate-400">30-Day Vol (Ann.)</span><p className="text-lg font-bold font-mono">{aiResult.volatility.vol30}%</p></div>
                    <div className="bg-slate-700/30 rounded-lg p-3"><span className="text-xs text-slate-400">BB Position</span><p className="text-lg font-bold font-mono">{aiResult.volatility.bbPosition}%</p></div>
                    <div className="bg-slate-700/30 rounded-lg p-3"><span className="text-xs text-slate-400">From 52w High</span><p className={`text-lg font-bold font-mono ${parseFloat(aiResult.pctFromHigh) > -5 ? 'text-green-400' : 'text-red-400'}`}>{aiResult.pctFromHigh}%</p></div>
                    <div className="bg-slate-700/30 rounded-lg p-3"><span className="text-xs text-slate-400">From 52w Low</span><p className="text-lg font-bold font-mono text-green-400">+{aiResult.pctFromLow}%</p></div>
                  </div>
                  <div className="mt-3"><div className="flex justify-between text-xs text-slate-500 mb-1"><span>${aiResult.low52.toFixed(2)}</span><span>${aiResult.high52.toFixed(2)}</span></div>
                    <div className="w-full bg-slate-700 rounded-full h-2.5 relative">
                      <div className="absolute h-2.5 rounded-full bg-gradient-to-r from-red-500/30 via-yellow-500/30 to-green-500/30" style={{ width: '100%' }}></div>
                      <div className="absolute w-3 h-3 bg-blue-400 rounded-full shadow-lg border border-white" style={{ left: (aiResult.rangePosition * 100) + '%', transform: 'translateX(-50%)', top: '-1px' }}></div>
                    </div>
                  </div>
                </div>

                {/* Liquidity */}
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <h3 className="text-sm font-semibold text-slate-300 mb-3 flex items-center gap-2">ðŸ’§ Liquidity <span className={`font-mono ${sc(aiResult.liquidity?.score)}`}>{aiResult.liquidity?.score}/10</span></h3>
                  <p className="text-sm text-slate-300 mb-3">{aiResult.liquidity.summary}</p>
                  <div className="grid grid-cols-2 gap-3 text-sm">
                    <div className="bg-slate-700/30 rounded-lg p-3"><span className="text-xs text-slate-400">Avg Volume (20d)</span><p className="text-lg font-bold font-mono">{(aiResult.liquidity.avgVol20 / 1e6).toFixed(2)}M</p></div>
                    <div className="bg-slate-700/30 rounded-lg p-3"><span className="text-xs text-slate-400">Dollar Volume</span><p className="text-lg font-bold font-mono">${(aiResult.liquidity.dollarVolume / 1e6).toFixed(0)}M</p></div>
                  </div>
                </div>
              </div>
              </>)}

              {/* === FUNDAMENTALS === */}
              {screenerTab === 'fundamentals' && aiResult.fundamentals && (<>
                <div className="bg-slate-800 rounded-xl p-4 border border-slate-700 mb-4">
                  <div className="flex items-center justify-between flex-wrap gap-2">
                    <h3 className="text-sm font-semibold text-slate-300">ðŸ“Š {aiResult.fundamentals.longname || aiResult.fundamentals.shortname || aiTicker} â€” {aiResult.fundamentals.sector || 'N/A'} / {aiResult.fundamentals.industry || 'N/A'}</h3>
                    <div className="flex gap-2">
                      {['Summary', 'Financials', 'Key Statistics'].map(page => {
                        const slug = page === 'Summary' ? '' : page === 'Key Statistics' ? 'key-statistics' : page.toLowerCase();
                        return <a key={page} href={'https://finance.yahoo.com/quote/' + aiTicker + (slug ? '/' + slug + '/' : '/')} target="_blank" rel="noopener noreferrer" className="px-2 py-1 text-xs bg-slate-700 hover:bg-slate-600 text-blue-300 rounded">{page} â†—</a>;
                      })}
                    </div>
                  </div>
                  <p className="text-xs text-slate-500 mt-1">Metrics computed from 2 years of price data. Click links above for full financial statements.</p>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">ðŸ“ˆ Price Returns</h3>
                    <div className="space-y-1">
                      {[['1 Week', aiResult.fundamentals.return1w], ['1 Month', aiResult.fundamentals.return1m], ['3 Months', aiResult.fundamentals.return3m], ['6 Months', aiResult.fundamentals.return6m], ['1 Year', aiResult.fundamentals.return1y], ['YTD', aiResult.fundamentals.returnYTD]].map(([label, val]) => (
                        <div key={label} className="flex justify-between items-center py-0.5">
                          <span className="text-xs text-slate-400">{label}</span>
                          <span className={'text-sm font-mono font-bold ' + (val > 0 ? 'text-green-400' : val < 0 ? 'text-red-400' : 'text-slate-400')}>
                            {val != null ? (val > 0 ? '+' : '') + val.toFixed(1) + '%' : 'N/A'}
                          </span>
                        </div>
                      ))}
                    </div>
                  </div>
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">âš¡ Volatility & Risk</h3>
                    <div className="space-y-1">
                      {[['Annual Volatility', aiResult.fundamentals.annualVol, '%'], ['Beta (est)', aiResult.fundamentals.beta, ''], ['Max Drawdown', aiResult.fundamentals.maxDrawdown, '%'], ['Sharpe (est)', aiResult.fundamentals.sharpeEst, ''], ['52W Range', aiResult.fundamentals.range52wPct, '%']].map(([label, val, suffix]) => (
                        <div key={label} className="flex justify-between items-center py-0.5">
                          <span className="text-xs text-slate-400">{label}</span>
                          <span className={'text-sm font-mono font-bold ' + (label === 'Max Drawdown' ? 'text-red-400' : val > 0 ? 'text-green-400' : 'text-slate-400')}>
                            {val != null ? val.toFixed(1) + suffix : 'N/A'}
                          </span>
                        </div>
                      ))}
                    </div>
                  </div>
                  <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300 mb-3">ðŸŽ¯ Technical Position</h3>
                    <div className="space-y-1">
                      {[['vs 50-day MA', aiResult.fundamentals.relStrength50, '%'], ['vs 200-day MA', aiResult.fundamentals.relStrength200, '%'], ['RSI', aiResult.scores?.tech?.rsi, ''], ['Avg Vol (20d)', aiResult.fundamentals.avgVolume20d, '']].map(([label, val, suffix]) => (
                        <div key={label} className="flex justify-between items-center py-0.5">
                          <span className="text-xs text-slate-400">{label}</span>
                          <span className={'text-sm font-mono font-bold ' + (val != null && val > 0 ? 'text-green-400' : val != null && val < 0 ? 'text-red-400' : 'text-slate-400')}>
                            {label === 'Avg Vol (20d)' && val ? (val >= 1e6 ? (val/1e6).toFixed(1) + 'M' : (val/1e3).toFixed(0) + 'K') :
                             val != null ? val.toFixed(1) + suffix : 'N/A'}
                          </span>
                        </div>
                      ))}
                      <div className="flex justify-between items-center py-0.5">
                        <span className="text-xs text-slate-400">MACD Signal</span>
                        <span className={'text-sm font-bold ' + (aiResult.scores?.tech?.macdBullish ? 'text-green-400' : 'text-red-400')}>
                          {aiResult.scores?.tech?.macdBullish ? 'ðŸŸ¢ Bullish' : 'ðŸ”´ Bearish'}
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </>)}


              {/* === SENTIMENT === */}
              {screenerTab === 'sentiment' && (<>
                <div className="bg-slate-800 rounded-xl p-5 border border-slate-700">
                  <h3 className="text-sm font-semibold text-slate-300 mb-4">ðŸ—£ï¸ Social Sentiment â€” {aiTicker}</h3>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div className="bg-slate-700/30 rounded-lg p-4 text-center">
                      <Tip label="Sentiment Score" tipKey="sentiment"><span className="text-xs text-slate-400 cursor-help">Current Score</span></Tip>
                      <p className={'text-3xl font-bold font-mono mt-2 ' + (aiResult.sentiment?.current > 20 ? 'text-green-400' : aiResult.sentiment?.current < -20 ? 'text-red-400' : 'text-yellow-400')}>
                        {aiResult.sentiment?.current > 0 ? '+' : ''}{aiResult.sentiment?.current || 0}
                      </p>
                    </div>
                    <div className="bg-green-500/10 rounded-lg p-4 text-center"><span className="text-xs text-green-400">Bullish</span><p className="text-2xl font-bold font-mono text-green-400 mt-2">{aiResult.sentiment?.bullish || 0}</p></div>
                    <div className="bg-red-500/10 rounded-lg p-4 text-center"><span className="text-xs text-red-400">Bearish</span><p className="text-2xl font-bold font-mono text-red-400 mt-2">{aiResult.sentiment?.bearish || 0}</p></div>
                    <div className="bg-slate-700/30 rounded-lg p-4 text-center"><span className="text-xs text-slate-400">Total Posts</span><p className="text-2xl font-bold font-mono mt-2">{aiResult.sentiment?.total || 0}</p></div>
                  </div>
                  <div className="mb-6"><div className="flex justify-between text-xs text-slate-500 mb-1"><span>Extreme Bearish</span><span>Neutral</span><span>Extreme Bullish</span></div>
                    <div className="w-full h-4 rounded-full bg-gradient-to-r from-red-600 via-yellow-500 to-green-600 relative">
                      <div className="absolute w-4 h-6 bg-white rounded-full shadow-lg border-2 border-slate-900" style={{ left: (((aiResult.sentiment?.current || 0) + 100) / 200 * 100) + '%', transform: 'translateX(-50%)', top: '-4px' }}></div>
                    </div>
                  </div>
                  {aiResult.sentiment?.history?.length > 0 ? (
                    <div>
                      <div className="flex items-center justify-between mb-2">
                        <h4 className="text-xs text-slate-400">Sentiment Over Time</h4>
                        <div className="flex gap-1 bg-slate-700/50 rounded-lg p-0.5">
                          {[['1w','1W'],['1m','1M'],['3m','3M'],['6m','6M'],['1y','1Y'],['all','All']].map(([k,l]) => (
                            <button key={k} onClick={() => setSentimentRange(k)} className={'px-2.5 py-1 rounded-md text-xs font-semibold transition-all ' + (sentimentRange === k ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white hover:bg-slate-600')}>{l}</button>
                          ))}
                        </div>
                      </div>
                      <div style={{ height: '250px' }}><canvas ref={sentimentChartRef}></canvas></div>
                    </div>
                  ) : (
                    <div className="text-center py-8 text-slate-500"><p className="text-sm">No historical sentiment data available.</p><p className="text-xs mt-1">Try more popular tickers (AAPL, TSLA, NVDA).</p></div>
                  )}
                  <div className="mt-4 p-3 bg-slate-700/30 rounded-lg">
                    <p className="text-xs text-slate-400 font-semibold mb-2">ðŸ“ Sources Aggregated:</p>
                    {aiResult.sentiment?.sources?.length > 0 ? (
                      <div className="flex flex-wrap gap-3 mb-2">
                        {aiResult.sentiment.sources.map(s => {
                          const urls = {
                            'StockTwits': 'https://stocktwits.com/symbol/' + aiTicker,
                            'Reddit': 'https://www.reddit.com/search/?q=' + aiTicker + '+stock&sort=new',
                          };
                          return (
                            <a key={s.name} href={urls[s.name] || '#'} target="_blank" rel="noopener noreferrer" className="flex items-center gap-1.5 px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-slate-200 hover:bg-slate-600 transition-all">
                              <span className="font-semibold">{s.name}</span>
                              <span className="text-slate-400">{s.count} posts</span>
                              <span className="text-green-400">{s.bullish}â†‘</span>
                              <span className="text-red-400">{s.bearish}â†“</span>
                              <span className="text-blue-400 ml-1">â†—</span>
                            </a>
                          );
                        })}
                      </div>
                    ) : <p className="text-xs text-slate-500 mb-2">No data returned from sources.</p>}
                    <p className="text-xs text-slate-400 font-semibold mb-1">ðŸ“° Additional Research:</p>
                    <div className="flex flex-wrap gap-2">
                      <a href={'https://seekingalpha.com/symbol/' + aiTicker} target="_blank" rel="noopener noreferrer" className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-orange-300 hover:bg-slate-600">Seeking Alpha â†—</a>
                      <a href={'https://substack.com/search/' + aiTicker} target="_blank" rel="noopener noreferrer" className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-orange-300 hover:bg-slate-600">Substack â†—</a>
                      <a href={'https://valueinvestorsclub.com/ideas?search=' + aiTicker} target="_blank" rel="noopener noreferrer" className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-orange-300 hover:bg-slate-600">VIC â†—</a>
                      <a href={'https://finance.yahoo.com/quote/' + aiTicker + '/community/'} target="_blank" rel="noopener noreferrer" className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-orange-300 hover:bg-slate-600">Yahoo Finance â†—</a>
                      <a href={'https://twitter.com/search?q=%24' + aiTicker + '&f=live'} target="_blank" rel="noopener noreferrer" className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-orange-300 hover:bg-slate-600">X/Twitter â†—</a>
                      <a href={'https://www.google.com/finance/quote/' + aiTicker + ':NASDAQ'} target="_blank" rel="noopener noreferrer" className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-orange-300 hover:bg-slate-600">Google Finance â†—</a>
                    </div>
                  </div>
                </div>
              </>)}

              {/* === CLAUDE CHAT === */}
              {screenerTab === 'chat' && (
                <div className="bg-slate-800 rounded-xl border border-slate-700 flex flex-col" style={{ height: '500px' }}>
                  <div className="p-4 border-b border-slate-700">
                    <h3 className="text-sm font-semibold text-slate-300">ðŸ’¬ Ask Claude about {aiTicker}</h3>
                    <p className="text-xs text-slate-500 mt-1">Claude has context on price, fundamentals, technicals, and sentiment.</p>
                  </div>
                  <div className="flex-1 overflow-y-auto p-4 space-y-3">
                    {chatMessages.length === 0 && (
                      <div className="text-center py-8 text-slate-500"><p className="text-sm mb-3">Try asking:</p>
                        <div className="flex flex-wrap justify-center gap-2">
                          {['Is this overvalued?', 'Key risks?', 'Compare to competitors', 'Should I add more?', 'What catalysts ahead?'].map(q => (
                            <button key={q} onClick={() => setChatInput(q)} className="px-3 py-1.5 bg-slate-700 rounded-lg text-xs text-slate-300 hover:bg-slate-600">{q}</button>
                          ))}
                        </div>
                      </div>
                    )}
                    {chatMessages.map((msg, i) => (
                      <div key={i} className={'flex ' + (msg.role === 'user' ? 'justify-end' : 'justify-start')}>
                        <div className={'max-w-[80%] p-3 rounded-xl text-sm ' + (msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-slate-700 text-slate-200')}>
                          <p className="whitespace-pre-wrap">{msg.content}</p>
                        </div>
                      </div>
                    ))}
                    {chatLoading && <div className="flex justify-start"><div className="bg-slate-700 rounded-xl p-3 text-slate-400 text-sm">Thinking...</div></div>}
                    <div ref={chatEndRef}></div>
                  </div>
                  <div className="p-4 border-t border-slate-700 flex gap-2">
                    <input value={chatInput} onChange={e => setChatInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && sendChatMessage()} placeholder={'Ask about ' + aiTicker + '...'} className="flex-1 px-4 py-2.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm" />
                    <button onClick={sendChatMessage} disabled={chatLoading || !chatInput.trim()} className="px-5 py-2.5 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold text-sm disabled:opacity-50">Send</button>
                  </div>
                </div>
              )}
            </>)}

            {!aiResult && !aiLoading && !aiError && (
              <div className="flex flex-col items-center justify-center py-24 text-slate-400">
                <div className="text-6xl mb-6">ðŸ¤–</div>
                <h2 className="text-2xl font-bold text-slate-300 mb-2">Stock Screener</h2>
                <p className="text-sm mb-4">Enter a ticker above and click Analyze for a quantitative stock score</p>
                <p className="text-xs text-slate-500">Computes technicals, momentum, volatility, liquidity, and trend from live market data</p>
              </div>
            )}
          </div>
        );
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white p-6">
          <div className="max-w-7xl mx-auto">
            {/* Header */}
            <div className="mb-8">
              <div className="flex justify-between items-center mb-2 flex-wrap gap-3">
                <h1 className="text-4xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                  Idea Tracker
                </h1>
                <div className="flex gap-3 flex-wrap">
                  <button
                    onClick={saveToFile}
                    className="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded-lg font-medium transition-colors flex items-center gap-2"
                    title="Download save file"
                  >
                    ðŸ’¾ Save
                  </button>
                  <button
                    onClick={loadFromFile}
                    className="px-4 py-2 bg-cyan-600 hover:bg-cyan-700 rounded-lg font-medium transition-colors flex items-center gap-2"
                    title="Load from save file"
                  >
                    ðŸ“‚ Load
                  </button>
                  <span className="border-l border-slate-600 mx-1"></span>
                  <button
                    onClick={runBacktest}
                    disabled={loading || currentIdeas.length === 0}
                    className="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg font-medium transition-colors flex items-center gap-2 disabled:opacity-50"
                  >
                    â® Backtest
                  </button>
                  <button
                    onClick={exportToExcel}
                    className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-medium transition-colors flex items-center gap-2"
                  >
                    <FileSpreadsheet /> Excel
                  </button>
                  <button
                    onClick={exportToJPEG}
                    className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-medium transition-colors flex items-center gap-2"
                  >
                    <ImageIcon /> JPEG
                  </button>
                  <button
                    onClick={refreshPrices}
                    disabled={loading}
                    className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg font-medium transition-colors disabled:opacity-50"
                  >
                    {loading ? 'Updating...' : 'Refresh'}
                  </button>
                  <span className="border-l border-slate-600 mx-1"></span>
                  {currentUser ? (
                    <div className="flex items-center gap-2">
                      <span className="text-sm text-slate-300">ðŸ‘¤ {currentUser.name}</span>
                      <button onClick={handleLogout} className="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-xs text-slate-400">Logout</button>
                    </div>
                  ) : (
                    <button onClick={() => setShowAuthModal(true)} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm font-medium flex items-center gap-1">ðŸ‘¤ Sign In</button>
                  )}
                </div>
              </div>
              
              {/* Portfolio and Settings Controls */}
              <div className="flex flex-wrap gap-4 items-center mb-3">
                <div className="flex items-center gap-2">
                  <label className="text-slate-400 text-sm font-semibold">GMV ($M):</label>
                  <input
                    type="number"
                    value={(portfolioGMV / 1000000).toFixed(0)}
                    onChange={(e) => {
                      const gmv = parseFloat(e.target.value) * 1000000;
                      setPortfolioGMV(gmv || 0);
                    }}
                    className="w-24 px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm font-mono"
                    placeholder="1000"
                  />
                </div>

                <div className="flex items-center gap-2">
                  <label className="text-slate-400 text-sm">Portfolio:</label>
                  <select
                    value={currentPortfolio}
                    onChange={(e) => setCurrentPortfolio(e.target.value)}
                    className="px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                  >
                    {Object.keys(portfolios).map(name => (
                      <option key={name} value={name}>{name}</option>
                    ))}
                  </select>
                  {showNewPortfolio ? (
                    <div className="flex gap-2">
                      <input
                        type="text"
                        placeholder="Portfolio name"
                        value={newPortfolioName}
                        onChange={(e) => setNewPortfolioName(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && addPortfolio()}
                        className="px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm w-32"
                      />
                      <button onClick={addPortfolio} className="px-3 py-1.5 bg-green-600 hover:bg-green-700 rounded-lg text-sm">Add</button>
                      <button onClick={() => setShowNewPortfolio(false)} className="px-3 py-1.5 bg-slate-600 hover:bg-slate-700 rounded-lg text-sm">âœ•</button>
                    </div>
                  ) : (
                    <button
                      onClick={() => setShowNewPortfolio(true)}
                      className="px-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm"
                    >
                      + New
                    </button>
                  )}
                  {currentPortfolio !== 'All Positions' && (
                    <>
                      <button
                        onClick={() => renamePortfolio(currentPortfolio)}
                        className="px-3 py-1.5 bg-blue-600/20 hover:bg-blue-600/30 text-blue-400 rounded-lg text-sm"
                      >
                        Rename
                      </button>
                      <button
                        onClick={() => deletePortfolio(currentPortfolio)}
                        className="px-3 py-1.5 bg-red-600/20 hover:bg-red-600/30 text-red-400 rounded-lg text-sm"
                      >
                        Delete
                      </button>
                    </>
                  )}
                </div>

                <div className="flex items-center gap-2">
                  <label className="text-slate-400 text-sm">Override Unit:</label>
                  <select
                    value={sizingMode}
                    onChange={(e) => setSizingMode(e.target.value)}
                    className="px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                  >
                    <option value="dollars">$ Value</option>
                    <option value="shares"># Shares</option>
                  </select>
                </div>

                <div className="flex items-center gap-2">
                  <label className="text-slate-400 text-sm">Track Since:</label>
                  <input
                    type="date"
                    value={trackingStartDate}
                    onChange={(e) => setTrackingStartDate(e.target.value)}
                    className="px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm"
                  />
                </div>
              </div>

              {/* Tab Navigation */}
              <div className="flex flex-wrap gap-1 mb-4 bg-slate-800/50 rounded-xl p-1 border border-slate-700">
                <button
                  onClick={() => setActiveTab('tracker')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'tracker' 
                      ? 'bg-blue-600 text-white shadow-lg shadow-blue-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ“‹ Position Tracker
                </button>
                <button
                  onClick={() => setActiveTab('analytics')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'analytics' 
                      ? 'bg-purple-600 text-white shadow-lg shadow-purple-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ“Š Deep Analytics
                </button>
                <button
                  onClick={() => setActiveTab('singlename')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'singlename' 
                      ? 'bg-emerald-600 text-white shadow-lg shadow-emerald-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ“ˆ Single Name
                </button>
                <button
                  onClick={() => setActiveTab('corrrolling')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'corrrolling' 
                      ? 'bg-orange-600 text-white shadow-lg shadow-orange-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ”— Correlation
                </button>
                <button
                  onClick={() => setActiveTab('journal')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'journal' 
                      ? 'bg-rose-600 text-white shadow-lg shadow-rose-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ“’ Journal
                </button>
                <button
                  onClick={() => setActiveTab('screener')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'screener' 
                      ? 'bg-cyan-600 text-white shadow-lg shadow-cyan-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ¤– AI Screener
                </button>
                <button
                  onClick={() => setActiveTab('news')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'news' 
                      ? 'bg-amber-600 text-white shadow-lg shadow-amber-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ“° News
                </button>
                <button
                  onClick={() => setActiveTab('watchlist')}
                  className={`px-4 py-2 rounded-lg text-xs font-semibold transition-all ${
                    activeTab === 'watchlist' 
                      ? 'bg-green-600 text-white shadow-lg shadow-green-600/25' 
                      : 'text-slate-400 hover:text-white hover:bg-slate-700'
                  }`}
                >
                  ðŸ“º Watchlist
                </button>
              </div>

              <div className="flex justify-between items-center">
                <p className="text-slate-400 text-sm">
                  Last updated: {lastUpdate.toLocaleTimeString()} | SPY: ${marketData.spy.toFixed(2)} | Portfolio GMV: ${(portfolioGMV / 1000000).toFixed(0)}M
                </p>
                <div className="flex items-center gap-3">
                  <span className="text-xs text-slate-500 flex items-center gap-1.5">
                    <span className={`inline-block w-2 h-2 rounded-full ${saveStatus === 'saved' ? 'bg-green-400' : 'bg-yellow-400 animate-pulse'}`}></span>
                    {saveStatus === 'saved' ? 'Auto-saved' : 'Saving...'}
                    {lastSavedTime && <span className="text-slate-600">({new Date(lastSavedTime).toLocaleTimeString()})</span>}
                  </span>
                  <button
                    onClick={clearAllData}
                    className="text-xs text-slate-600 hover:text-red-400 transition-colors"
                    title="Clear all saved data"
                  >
                    Reset All
                  </button>
                </div>
              </div>
            </div>

            <div ref={dashboardRef}>
            {activeTab === 'tracker' ? (
            <>
            {/* Metrics */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Gross Exposure</span>
                <p className="text-2xl font-bold">${fmt(metrics.grossExposure)}M</p>
                <p className="text-xs text-slate-500 mt-1">Longs + Shorts</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Net Exposure</span>
                <p className="text-2xl font-bold">{metrics.netExposurePercent > 0 ? '+' : ''}{metrics.netExposurePercent}%</p>
                <p className="text-xs text-slate-500 mt-1">${fmt(metrics.netExposure)}M</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Batting Average</span>
                <p className="text-2xl font-bold">{metrics.battingAverage}%</p>
                <p className="text-xs text-slate-500 mt-1">Win Rate</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Portfolio Alpha</span>
                <p className={`text-2xl font-bold ${parseFloat(metrics.portfolioAlpha) >= 0 ? 'text-green-400' : 'text-red-400'}`}>{metrics.portfolioAlpha > 0 ? '+' : ''}${fmt(metrics.portfolioAlpha)}K</p>
                <p className="text-xs text-slate-500 mt-1">vs Market</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Total P&L</span>
                <p className={`text-2xl font-bold ${parseFloat(metrics.totalPnL) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                  {parseFloat(metrics.totalPnL) >= 0 ? '+' : ''}${fmt(metrics.totalPnL)}K
                </p>
                <p className="text-xs text-slate-500 mt-1">Total</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Sharpe Ratio</span>
                <p className="text-2xl font-bold">{metrics.sharpe}</p>
                <p className="text-xs text-slate-500 mt-1">Risk-Adj</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Portfolio Beta</span>
                <p className="text-2xl font-bold">{metrics.beta}</p>
                <p className="text-xs text-slate-500 mt-1">Market</p>
              </div>
              <div className="bg-slate-800 rounded-xl p-4 border border-slate-700">
                <span className="text-slate-400 text-sm">Active Ideas</span>
                <p className="text-2xl font-bold">{currentIdeas.length}</p>
                <p className="text-xs text-slate-500 mt-1">Positions</p>
              </div>
            </div>

            {/* Charts */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
              <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                <h3 className="text-lg font-semibold mb-4">Exposure Breakdown</h3>
                <div style={{ height: '250px' }}><canvas ref={pieChartRef}></canvas></div>
              </div>
              <div className="bg-slate-800 rounded-xl p-6 border border-slate-700">
                <h3 className="text-lg font-semibold mb-4">Conviction Distribution</h3>
                <div style={{ height: '250px' }}><canvas ref={barChartRef}></canvas></div>
              </div>
            </div>

            {/* Performance Chart */}
            {performanceHistory.length > 1 && (
              <div className="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-8">
                <h3 className="text-lg font-semibold mb-4">Performance vs Market (Since {new Date(trackingStartDate).toLocaleDateString()})</h3>
                <div style={{ height: '300px' }}><canvas ref={performanceChartRef}></canvas></div>
              </div>
            )}

            {/* Add New */}
            <div className="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-8">
              <h3 className="text-lg font-semibold mb-4">Add New Idea</h3>
              <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-4">
                <input
                  type="text"
                  placeholder="Ticker"
                  value={newIdea.ticker}
                  onChange={(e) => setNewIdea({ ...newIdea, ticker: e.target.value.toUpperCase() })}
                  className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600 focus:border-blue-500 focus:outline-none"
                />
                <select
                  value={newIdea.direction}
                  onChange={(e) => setNewIdea({ ...newIdea, direction: e.target.value })}
                  className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600"
                >
                  <option value="long">Long</option>
                  <option value="short">Short</option>
                </select>
                <select
                  value={newIdea.conviction}
                  onChange={(e) => setNewIdea({ ...newIdea, conviction: Number(e.target.value) })}
                  className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600"
                >
                  <option value={1}>Conviction: 1</option>
                  <option value={2}>Conviction: 2</option>
                  <option value={3}>Conviction: 3</option>
                  <option value={4}>Conviction: 4</option>
                  <option value={5}>Conviction: 5 (Table-Pound)</option>
                </select>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <input
                  type="text"
                  placeholder="Investment Thesis"
                  value={newIdea.thesis}
                  onChange={(e) => setNewIdea({ ...newIdea, thesis: e.target.value })}
                  className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600"
                />
                <input
                  type="text"
                  placeholder="Catalyst"
                  value={newIdea.catalyst}
                  onChange={(e) => setNewIdea({ ...newIdea, catalyst: e.target.value })}
                  className="px-4 py-2 bg-slate-700 text-white rounded-lg border border-slate-600"
                />
              </div>
              <button
                onClick={addIdea}
                className="px-6 py-2 bg-green-600 hover:bg-green-700 rounded-lg font-medium"
              >
                Add Position
              </button>
            </div>

            {/* Conviction Grid - Drag & Drop */}
            {currentIdeas.length > 0 && (
            <div className="bg-gradient-to-br from-slate-800 to-slate-800/80 rounded-xl border border-slate-700/60 p-5 mb-8 shadow-lg">
              <div className="flex items-center justify-between mb-4">
                <div>
                  <h3 className="text-lg font-bold text-white flex items-center gap-2">Conviction Grid <InfoTip text={"Drag stocks between cells to change direction or conviction.\nColumns: Long (bullish) vs Short (bearish)\nRows: Conviction 1 (lowest) to 5 (highest)\n\nðŸ“ Highest conviction = largest position size"} /></h3>
                  <p className="text-xs text-slate-500 mt-0.5">Drag to reclassify â€¢ Hover for returns</p>
                </div>
                <div className="flex gap-4 text-xs text-slate-500">
                  <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-green-400"></span> Profitable</span>
                  <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-red-400"></span> Underwater</span>
                </div>
              </div>
              <div className="grid grid-cols-[60px_1fr_1fr] gap-0 rounded-lg overflow-hidden" style={{border:'1px solid rgba(71,85,105,0.5)'}}>
                {/* Header row */}
                <div className="bg-slate-700/80 px-2 py-3 flex items-center justify-center" style={{borderRight:'1px solid rgba(71,85,105,0.5)',borderBottom:'1px solid rgba(71,85,105,0.5)'}}>
                  <span className="text-[10px] text-slate-400 font-medium uppercase tracking-wider">Conv.</span>
                </div>
                <div className="bg-slate-700/80 px-3 py-3 text-center font-bold text-sm" style={{borderRight:'1px solid rgba(71,85,105,0.5)',borderBottom:'1px solid rgba(71,85,105,0.5)'}}>
                  <span className="bg-gradient-to-r from-green-400 to-emerald-300 bg-clip-text text-transparent">â–² LONG</span>
                </div>
                <div className="bg-slate-700/80 px-3 py-3 text-center font-bold text-sm" style={{borderBottom:'1px solid rgba(71,85,105,0.5)'}}>
                  <span className="bg-gradient-to-r from-red-400 to-rose-300 bg-clip-text text-transparent">â–¼ SHORT</span>
                </div>
                {/* Rows for each conviction level */}
                {[5, 4, 3, 2, 1].map((conv, rowIdx) => {
                  const longs = currentIdeas.filter(i => i.direction === 'long' && Number(i.conviction) === conv);
                  const shorts = currentIdeas.filter(i => i.direction === 'short' && Number(i.conviction) === conv);
                  const rowOpacity = conv === 5 ? 'bg-slate-700/30' : conv === 4 ? 'bg-slate-700/20' : conv === 3 ? 'bg-slate-700/10' : 'bg-transparent';
                  const isLast = conv === 1;
                  return (
                    <React.Fragment key={conv}>
                      <div className={`${rowOpacity} px-2 py-2.5 flex flex-col items-center justify-center gap-0.5`} style={{borderRight:'1px solid rgba(71,85,105,0.5)',borderBottom:isLast?'none':'1px solid rgba(71,85,105,0.3)'}}>
                        <span className="text-sm font-bold text-white">{conv}</span>
                        <span className="text-[9px] text-slate-500">{conv === 5 ? 'MAX' : conv === 4 ? 'HIGH' : conv === 3 ? 'MED' : conv === 2 ? 'LOW' : 'MIN'}</span>
                      </div>
                      {['long', 'short'].map(dir => (
                        <div
                          key={dir}
                          className={'min-h-[52px] px-2 py-2 flex flex-wrap gap-1.5 items-start content-start transition-all duration-200 hover:bg-slate-600/10'}
                          style={{borderRight: dir === 'long' ? '1px solid rgba(71,85,105,0.5)' : 'none', borderBottom:isLast?'none':'1px solid rgba(71,85,105,0.3)'}}
                          onDragOver={(e) => { e.preventDefault(); e.currentTarget.style.background = 'rgba(59,130,246,0.08)'; }}
                          onDragLeave={(e) => { e.currentTarget.style.background = ''; }}
                          onDrop={(e) => {
                            e.preventDefault();
                            e.currentTarget.style.background = '';
                            const id = e.dataTransfer.getData('text/plain');
                            if (!id) return;
                            const updated = currentIdeas.map(i => {
                              if (String(i.id) === id) {
                                const oldDir = i.direction;
                                const oldConv = i.conviction;
                                if (oldDir !== dir || Number(oldConv) !== conv) {
                                  logChange('EDIT', { ...i, direction: dir, conviction: conv }, { prevDirection: oldDir, prevConviction: oldConv });
                                  return { ...i, direction: dir, conviction: conv };
                                }
                              }
                              return i;
                            });
                            updateIdeas(updated);
                          }}
                        >
                          {(dir === 'long' ? longs : shorts).map(idea => {
                            const ep = idea.entryPrice || 100;
                            const cp = idea.currentPrice || ep;
                            const ret = idea.direction === 'long' ? (cp - ep) / ep : (ep - cp) / ep;
                            const retPct = (ret * 100);
                            return (
                              <div
                                key={idea.id}
                                draggable
                                onDragStart={(e) => { e.dataTransfer.setData('text/plain', String(idea.id)); e.dataTransfer.effectAllowed = 'move'; }}
                                className={'group relative cursor-grab active:cursor-grabbing rounded-md text-xs font-mono font-bold transition-all duration-150 select-none shadow-sm hover:shadow-md hover:scale-105 ' + (ret >= 0 ? 'bg-green-500/15 text-green-300 hover:bg-green-500/25 shadow-green-900/20' : 'bg-red-500/15 text-red-300 hover:bg-red-500/25 shadow-red-900/20')}
                                style={{padding:'5px 10px', border: `1px solid ${ret >= 0 ? 'rgba(16,185,129,0.25)' : 'rgba(239,68,68,0.25)'}`}}
                                title={`${idea.ticker}: ${ret >= 0 ? '+' : ''}${retPct.toFixed(1)}% | ${idea.thesis || 'No thesis'}`}
                              >
                                <span>{idea.ticker}</span>
                                <span className={'ml-1.5 text-[10px] font-semibold ' + (ret >= 0 ? 'text-green-400/80' : 'text-red-400/80')}>{ret >= 0 ? '+' : ''}{retPct.toFixed(0)}%</span>
                              </div>
                            );
                          })}
                          {(dir === 'long' ? longs : shorts).length === 0 && (
                            <span className="text-[10px] text-slate-600 italic py-2 w-full text-center">Drop here</span>
                          )}
                        </div>
                      ))}
                    </React.Fragment>
                  );
                })}
              </div>
            </div>
            )}

            {/* Detailed Position Table */}
            <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
              <table className="w-full">
                <thead className="bg-slate-700">
                  <tr>
                    <th className="px-2 py-2.5 text-left text-xs">Conv</th>
                    <th className="px-2 py-2.5 text-right text-xs">Wt%</th>
                    <th className="px-2 py-2.5 text-left text-xs">Ticker</th>
                    <th className="px-2 py-2.5 text-left text-xs">Dir</th>
                    <th className="px-2 py-2.5 text-right text-xs">Alloc</th>
                    <th className="px-2 py-2.5 text-right text-xs">Shares</th>
                    <th className="px-2 py-2.5 text-right text-xs">Override</th>
                    <th className="px-2 py-2.5 text-right text-xs">Entry</th>
                    <th className="px-2 py-2.5 text-right text-xs">Current</th>
                    <th className="px-2 py-2.5 text-right text-xs">P&L</th>
                    <th className="px-2 py-2.5 text-right text-xs">Ret%</th>
                    <th className="px-2 py-2.5 text-center text-xs w-16"></th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-slate-700">
                  {positionsWithSizes.map((idea) => {
                    const currentPrice = idea.currentPrice || idea.entryPrice || 100;
                    const entryPrice = idea.entryPrice || 100;
                    const allocation = idea.allocation || 0;
                    
                    const pnl = idea.direction === 'long'
                      ? ((currentPrice - entryPrice) / entryPrice) * allocation
                      : ((entryPrice - currentPrice) / entryPrice) * allocation;
                    const returns = idea.direction === 'long'
                      ? ((currentPrice - entryPrice) / entryPrice) * 100
                      : ((entryPrice - currentPrice) / entryPrice) * 100;

                    return (
                      <tr 
                        key={idea.id} 
                        className="hover:bg-slate-700/50"
                      >
                        {editingId === idea.id ? (
                          // EDIT MODE
                          <>
                            <td className="px-2 py-2">
                              <select
                                value={editForm.conviction}
                                onChange={(e) => setEditForm({ ...editForm, conviction: e.target.value })}
                                className="px-2 py-1 bg-slate-700 text-white rounded border border-slate-600 text-sm"
                              >
                                <option value={1}>1</option>
                                <option value={2}>2</option>
                                <option value={3}>3</option>
                                <option value={4}>4</option>
                                <option value={5}>5</option>
                              </select>
                            </td>
                            <td className="px-2 py-2 text-right font-mono">{(idea.weight * 100).toFixed(1)}%</td>
                            <td className="px-2 py-2">
                              <input
                                type="text"
                                value={editForm.ticker}
                                onChange={(e) => setEditForm({ ...editForm, ticker: e.target.value })}
                                className="w-20 px-2 py-1 bg-slate-700 text-white rounded border border-slate-600 text-sm font-mono"
                              />
                            </td>
                            <td className="px-2 py-2">
                              <select
                                value={editForm.direction}
                                onChange={(e) => setEditForm({ ...editForm, direction: e.target.value })}
                                className="px-2 py-1 bg-slate-700 text-white rounded border border-slate-600 text-sm"
                              >
                                <option value="long">LONG</option>
                                <option value="short">SHORT</option>
                              </select>
                            </td>
                            <td className="px-2 py-2 text-right font-mono text-sm">${(allocation / 1000000).toFixed(1)}M</td>
                            <td className="px-2 py-2 text-right font-mono text-sm text-slate-400">{fmt(Math.round(idea.shares || 0))}</td>
                            <td className="px-2 py-2">
                              <input
                                type="number"
                                value={editForm.overrideValue}
                                onChange={(e) => setEditForm({ ...editForm, overrideValue: e.target.value })}
                                placeholder={sizingMode === 'shares' ? '# shares' : '$M'}
                                className="w-24 px-2 py-1 bg-slate-700 text-white rounded border border-blue-500/50 text-sm text-right"
                              />
                            </td>
                            <td className="px-2 py-2 text-right font-mono text-sm">${entryPrice.toFixed(2)}</td>
                            <td className="px-2 py-2 text-right font-mono text-sm">${currentPrice.toFixed(2)}</td>
                            <td className="px-2 py-2 text-right font-mono text-sm">${fmt((pnl / 1000).toFixed(2))}K</td>
                            <td className="px-2 py-2 text-right font-mono text-sm">{returns.toFixed(1)}%</td>
                            <td className="px-1 py-2 text-center">
                              <div className="flex gap-0.5 justify-center">
                                <button onClick={saveEdit} className="p-1 bg-green-600/20 hover:bg-green-600/30 text-green-400 rounded text-xs">âœ“</button>
                                <button onClick={cancelEdit} className="p-1 bg-slate-600/20 hover:bg-slate-600/30 text-slate-400 rounded text-xs">âœ•</button>
                              </div>
                            </td>
                          </>
                        ) : (
                          // VIEW MODE
                          <>
                            <td className="px-4 py-3">
                              <span 
                                className="inline-flex px-2.5 py-1 rounded-full text-xs font-bold"
                                style={{ backgroundColor: COLORS[idea.conviction] + '20', color: COLORS[idea.conviction] }}
                              >
                                {idea.conviction}/5
                              </span>
                            </td>
                            <td className={`px-2 py-2 text-right font-mono text-sm ${idea.isOverridden ? 'text-blue-400' : ''}`}>{(idea.weight * 100).toFixed(1)}%</td>
                            <td className="px-2 py-2 font-mono font-bold text-sm group relative cursor-help">
                              {idea.ticker}
                              {idea.thesis && (
                                <div className="absolute z-50 bottom-full left-0 mb-1 w-64 bg-slate-900 border border-slate-600 rounded-lg p-3 shadow-xl opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity text-xs text-slate-300 font-normal">
                                  <span className="text-slate-500 font-semibold">Thesis:</span> {idea.thesis}
                                  {idea.catalyst && <span><br/><span className="text-slate-500 font-semibold mt-1">Catalyst:</span> {idea.catalyst}</span>}
                                </div>
                              )}
                            </td>
                            <td className="px-2 py-2">
                              <span className={`inline-flex items-center gap-0.5 px-1.5 py-0.5 rounded text-xs font-bold ${
                                idea.direction === 'long' ? 'bg-green-500/15 text-green-400' : 'bg-red-500/15 text-red-400'
                              }`}>
                                {idea.direction === 'long' ? 'â†—' : 'â†˜'} {idea.direction.toUpperCase()}
                              </span>
                            </td>
                            <td className="px-4 py-3 text-right font-mono">${(allocation / 1000000).toFixed(1)}M</td>
                            <td className="px-4 py-3 text-right font-mono text-slate-400">{fmt(Math.round(idea.shares || 0))}</td>
                            <td className="px-2 py-2">
                              <div className="flex items-center justify-end gap-1">
                                <input
                                  type="number"
                                  value={(() => {
                                    const ov = idea.sizeOverride;
                                    if (!ov || !ov.value) return '';
                                    if (sizingMode === 'shares') return ov.type === 'shares' ? ov.value : '';
                                    return ov.type === 'dollars' ? (ov.value / 1000000).toFixed(1) : '';
                                  })()}
                                  onChange={(e) => {
                                    const raw = e.target.value;
                                    let newOverride = null;
                                    if (raw && parseFloat(raw) > 0) {
                                      if (sizingMode === 'shares') {
                                        newOverride = { type: 'shares', value: parseFloat(raw) };
                                      } else {
                                        newOverride = { type: 'dollars', value: parseFloat(raw) * 1000000 };
                                      }
                                    }
                                    const updatedIdeas = currentIdeas.map(i =>
                                      i.id === idea.id ? { ...i, sizeOverride: newOverride } : i
                                    );
                                    updateIdeas(updatedIdeas);
                                  }}
                                  placeholder={idea.isOverridden ? '' : 'auto'}
                                  className={`w-16 px-1.5 py-1 rounded border text-xs text-right font-mono ${
                                    idea.isOverridden 
                                      ? 'bg-blue-900/30 text-blue-300 border-blue-500/50' 
                                      : 'bg-slate-700/50 text-slate-500 border-slate-600/50'
                                  }`}
                                />
                                {idea.isOverridden && (
                                  <button
                                    onClick={() => {
                                      const updatedIdeas = currentIdeas.map(i =>
                                        i.id === idea.id ? { ...i, sizeOverride: null } : i
                                      );
                                      updateIdeas(updatedIdeas);
                                    }}
                                    className="text-xs text-slate-500 hover:text-red-400 p-0.5"
                                    title="Clear override, return to conviction sizing"
                                  >âœ•</button>
                                )}
                              </div>
                            </td>
                            <td className="px-4 py-3 text-right font-mono">${entryPrice.toFixed(2)}</td>
                            <td className="px-2 py-2 text-right font-mono text-sm font-bold">${currentPrice.toFixed(2)}</td>
                            <td className={`px-2 py-2 text-right font-mono text-sm font-bold ${pnl >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                              {pnl >= 0 ? '+' : ''}${fmt((pnl / 1000).toFixed(2))}K
                            </td>
                            <td className={`px-2 py-2 text-right font-mono text-sm ${returns >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                              {returns >= 0 ? '+' : ''}{returns.toFixed(1)}%
                            </td>
                            <td className="px-1 py-2 text-center">
                              <div className="flex gap-0.5 justify-center">
                                <button onClick={() => startEdit(idea)} className="p-1 hover:bg-blue-600/20 rounded text-blue-400 text-xs" title="Edit">âœŽ</button>
                                <button onClick={() => { logChange('REMOVE', idea); updateIdeas(currentIdeas.filter(i => i.id !== idea.id)); }} className="p-1 hover:bg-red-600/20 rounded text-red-400 text-xs" title="Delete">âœ•</button>
                              </div>
                            </td>
                          </>
                        )}
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>

            {/* Footer */}
            <div className="mt-8 bg-slate-800/50 rounded-xl p-6 border border-slate-700">
              <h3 className="text-sm font-semibold mb-3">ðŸ“Š How Top Funds Use Idea Trackers:</h3>
              <ul className="text-sm text-slate-400 space-y-2">
                <li>â€¢ <strong>Conviction-Based Sizing:</strong> 5/5 ideas get 2-3x the capital of 3/5 ideas</li>
                <li>â€¢ <strong>Alpha Isolation:</strong> Track idiosyncratic return vs beta. Hedge with SPY puts</li>
                <li>â€¢ <strong>Hit Rate &gt; 60%:</strong> Top PM batting averages range 60-75%</li>
                <li>â€¢ <strong>Risk Management:</strong> Pods get cut at -5% to -8% drawdown</li>
                <li>â€¢ <strong>Catalyst-Driven:</strong> Every idea needs a specific catalyst</li>
              </ul>
            </div>
            </>
            ) : activeTab === 'analytics' ? (
              <AnalyticsTab />
            ) : activeTab === 'singlename' ? (
              <SingleNameTab />
            ) : activeTab === 'corrrolling' ? (
              <CorrelationRollingTab />
            ) : activeTab === 'journal' ? (
              <TradeJournalTab />
            ) : activeTab === 'screener' ? (
              <div>{AIScreenerTab()}</div>
            ) : activeTab === 'news' ? (
              <div>
                {/* News Header */}
                <div className="flex items-center justify-between mb-3 flex-wrap gap-3">
                  <h2 className="text-2xl font-bold text-white">ðŸ“° Portfolio News Feed</h2>
                  <div className="flex items-center gap-2">
                    <div className="relative">
                      <input
                        type="text"
                        placeholder="Search ticker..."
                        value={newsFilter || ''}
                        onChange={(e) => setNewsFilter(e.target.value.toUpperCase() || null)}
                        className="px-3 py-1.5 bg-slate-700 text-white rounded-lg border border-slate-600 text-sm font-mono w-36 placeholder-slate-500"
                      />
                      {newsFilter && <button onClick={() => setNewsFilter(null)} className="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 hover:text-white text-xs">âœ•</button>}
                    </div>
                    <button onClick={fetchNews} disabled={newsLoading} className="px-4 py-1.5 bg-amber-600 hover:bg-amber-700 rounded-lg text-sm font-medium disabled:opacity-50">
                      {newsLoading ? 'Fetching...' : 'ðŸ”„ Refresh'}
                    </button>
                  </div>
                </div>

                {/* Ticker Filter */}
                <div className="flex flex-wrap gap-1 mb-3">
                  <button onClick={() => setNewsFilter(null)} className={'px-2.5 py-1 rounded text-xs font-bold transition-all ' + (!newsFilter ? 'bg-amber-600 text-white' : 'bg-slate-700 text-slate-400 hover:bg-slate-600')}>All</button>
                  {[...new Set(currentIdeas.map(i => i.ticker))].map(t => {
                    const count = newsItems.filter(n => n.ticker === t || n.relatedTickers?.includes(t)).length;
                    return <button key={t} onClick={() => setNewsFilter(newsFilter === t ? null : t)} className={'px-2 py-1 rounded text-xs font-mono font-bold transition-all ' + (newsFilter === t ? 'bg-amber-600 text-white' : 'bg-slate-700/80 text-slate-400 hover:bg-slate-600')}>{t}</button>;
                  })}
                </div>

                {/* News List */}
                {newsLoading && newsItems.length === 0 ? (
                  <div className="text-center py-12 text-slate-400">
                    <div className="text-3xl mb-3 animate-pulse">ðŸ“°</div>
                    <p className="text-sm">Fetching news for {currentIdeas.length} positions...</p>
                  </div>
                ) : newsItems.length === 0 ? (
                  <div className="text-center py-12 text-slate-400">
                    <div className="text-3xl mb-3">ðŸ“°</div>
                    <p className="text-sm">No news yet. Add positions and click Refresh News.</p>
                  </div>
                ) : (
                  <div className="bg-slate-800 rounded-xl border border-slate-700 overflow-hidden mb-6">
                    <div className="max-h-[600px] overflow-y-auto">
                      <table className="w-full">
                        <thead className="bg-slate-700 sticky top-0 z-10">
                          <tr>
                            <th className="px-3 py-2 text-left text-xs text-slate-400 w-16">Ticker</th>
                            <th className="px-3 py-2 text-left text-xs text-slate-400">Headline</th>
                            <th className="px-3 py-2 text-left text-xs text-slate-400 w-28 hidden md:table-cell">Source</th>
                            <th className="px-3 py-2 text-right text-xs text-slate-400 w-24 hidden md:table-cell">Date</th>
                          </tr>
                        </thead>
                        <tbody className="divide-y divide-slate-700/50">
                          {newsItems
                            .filter(n => !newsFilter || n.ticker.includes(newsFilter) || (n.relatedTickers || []).some(rt => rt.includes(newsFilter)))
                            .map(article => (
                            <tr key={article.id} className={'hover:bg-slate-700/40 cursor-pointer transition-colors' + (article.isHighPriority ? ' bg-amber-500/5' : '')} onClick={() => window.open(article.link, '_blank')}>
                              <td className="px-3 py-2">
                                <div className="flex items-center gap-1.5">
                                  {article.isHighPriority && <span className="w-1.5 h-1.5 rounded-full bg-amber-400 flex-shrink-0"></span>}
                                  <span className="text-xs font-mono font-bold text-blue-300">{article.ticker}</span>
                                </div>
                              </td>
                              <td className="px-3 py-2">
                                <span className="text-sm text-slate-200 leading-tight line-clamp-1">{article.title}</span>
                              </td>
                              <td className="px-3 py-2 hidden md:table-cell">
                                <span className="text-xs text-slate-500 truncate block max-w-[120px]">{article.publisher}</span>
                              </td>
                              <td className="px-3 py-2 text-right hidden md:table-cell">
                                <span className="text-xs text-slate-600 whitespace-nowrap">{new Date(article.timestamp).toLocaleDateString([], {month: 'short', day: 'numeric'})}</span>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                    <div className="bg-slate-700/50 px-3 py-1.5 text-xs text-slate-500 flex justify-between">
                      <span>{newsItems.filter(n => !newsFilter || n.ticker.includes(newsFilter) || (n.relatedTickers || []).some(rt => rt.includes(newsFilter))).length} articles{newsFilter ? ' for ' + newsFilter : ''}</span>
                      <span>ðŸŸ¡ = high priority (earnings, ratings, M&A)</span>
                    </div>
                  </div>
                )}

                {newsLastFetch && <p className="text-xs text-slate-600 text-center">Last fetched: {newsLastFetch.toLocaleTimeString()}</p>}
              </div>
            ) : activeTab === 'watchlist' ? (
              <div>
                {/* Watchlist Header */}
                <div className="flex items-center justify-between mb-3 flex-wrap gap-2">
                  <h2 className="text-2xl font-bold text-white">ðŸ“º Watchlist</h2>
                  <div className="flex items-center gap-2">
                    <input value={wlAddTicker} onChange={e => setWlAddTicker(e.target.value.toUpperCase())}
                      onKeyDown={e => { if (e.key === 'Enter' && wlAddTicker) { wlAddTickers(wlAddTicker.split(',').map(s => s.trim())); setWlAddTicker(''); }}}
                      placeholder="Add ticker(s)..." className="px-3 py-1.5 bg-slate-700 text-white rounded border border-slate-600 text-xs font-mono w-40 placeholder-slate-500" />
                    <button onClick={() => { if (wlAddTicker) { wlAddTickers(wlAddTicker.split(',').map(s => s.trim())); setWlAddTicker(''); }}} className="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded text-xs font-medium">+ Add</button>
                    <button onClick={wlImportFromPortfolio} className="px-3 py-1.5 bg-emerald-600 hover:bg-emerald-700 rounded text-xs font-medium">ðŸ“‹ Import Portfolio</button>
                    <button onClick={wlClassifySectors} disabled={wlClassifying} className="px-3 py-1.5 bg-purple-600 hover:bg-purple-700 rounded text-xs font-medium disabled:opacity-50">
                      {wlClassifying ? 'â³ Classifying...' : 'ðŸ¤– Auto-Group Sectors'}
                    </button>
                    <button onClick={() => wlFetchPrices(watchlist)} disabled={wlLoading} className="px-3 py-1.5 bg-amber-600 hover:bg-amber-700 rounded text-xs font-medium disabled:opacity-50">
                      {wlLoading ? 'â³ Loading...' : 'ðŸ”„ Refresh'}
                    </button>
                  </div>
                </div>

                {watchlist.length === 0 ? (
                  <div className="text-center py-16 text-slate-400">
                    <div className="text-3xl mb-3">ðŸ“º</div>
                    <p className="text-sm mb-3">No tickers in watchlist. Add tickers or import from your portfolio.</p>
                    <button onClick={wlImportFromPortfolio} className="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 rounded-lg text-sm font-medium">ðŸ“‹ Import from Portfolio</button>
                  </div>
                ) : (
                  <div>
                    {/* Sector Management Bar */}
                    <div className="flex items-center gap-2 mb-2 flex-wrap">
                      <span className="text-xs text-slate-500">Sectors:</span>
                      {[...new Set(Object.values(wlSectors))].filter(Boolean).sort().map(sec => (
                        <span key={sec} className="inline-flex items-center gap-1 px-2 py-0.5 bg-slate-800 rounded text-xs border border-slate-700 group"
                          onDragOver={e => { e.preventDefault(); e.currentTarget.classList.add('border-blue-500'); }}
                          onDragLeave={e => e.currentTarget.classList.remove('border-blue-500')}
                          onDrop={e => { e.preventDefault(); e.currentTarget.classList.remove('border-blue-500'); const t = e.dataTransfer.getData('text/plain'); if (t) { setWlSectors(prev => ({...prev, [t]: sec})); } }}>
                          {wlRenameSector?.old === sec ? (
                            <input autoFocus value={wlRenameSector.value} onChange={e => setWlRenameSector({...wlRenameSector, value: e.target.value})}
                              onKeyDown={e => { if (e.key === 'Enter' && wlRenameSector.value) { const updated = {...wlSectors}; Object.keys(updated).forEach(k => { if (updated[k] === sec) updated[k] = wlRenameSector.value; }); setWlSectors(updated); setWlRenameSector(null); } if (e.key === 'Escape') setWlRenameSector(null); }}
                              onBlur={() => { if (wlRenameSector?.value) { const updated = {...wlSectors}; Object.keys(updated).forEach(k => { if (updated[k] === sec) updated[k] = wlRenameSector.value; }); setWlSectors(updated); } setWlRenameSector(null); }}
                              className="bg-slate-700 text-white px-1 rounded text-xs w-24 border border-blue-500" />
                          ) : (
                            <span className="text-yellow-400 cursor-pointer" onDoubleClick={() => setWlRenameSector({old: sec, value: sec})}>{sec}</span>
                          )}
                          <button onClick={() => { const updated = {...wlSectors}; Object.keys(updated).forEach(k => { if (updated[k] === sec) delete updated[k]; }); setWlSectors(updated); }} className="text-slate-600 hover:text-red-400 text-xs opacity-0 group-hover:opacity-100 ml-0.5">âœ•</button>
                        </span>
                      ))}
                      <div className="inline-flex items-center gap-1">
                        <input value={wlNewSector} onChange={e => setWlNewSector(e.target.value)} placeholder="+ New sector" className="px-2 py-0.5 bg-slate-800 text-white rounded text-xs border border-slate-700 w-24 placeholder-slate-600"
                          onKeyDown={e => { if (e.key === 'Enter' && wlNewSector.trim()) { setWlNewSector(''); }}} />
                      </div>
                    </div>

                    <div className="bg-black rounded-xl border border-slate-700 overflow-hidden">
                      <div className="max-h-[75vh] overflow-y-auto" style={{scrollbarWidth: 'thin'}}>
                        <table className="w-full text-xs" style={{borderCollapse: 'collapse'}}>
                          <thead className="sticky top-0 z-10">
                            <tr className="bg-slate-800 border-b border-slate-600">
                              <th className="px-1 py-1.5 w-5"></th>
                              <th className="px-1.5 py-1.5 text-left text-slate-400 font-medium w-14 cursor-pointer select-none" onDoubleClick={() => setWlSort(s => ({col:'ticker', dir: s.col==='ticker' && s.dir==='asc' ? 'desc' : 'asc'}))}>Ticker {wlSort.col==='ticker' ? (wlSort.dir==='asc'?'â–²':'â–¼') : ''}</th>
                              <th className="px-1.5 py-1.5 text-left text-slate-400 font-medium">Security Name</th>
                              {[['last','Last'],['chg','Chg'],['chgPct','%Chg'],['wtd','WTD %'],['mo1','1Mo %'],['mtd','MTD %'],['mo3','3Mo %'],['ytd','YTD %'],['mo12','12Mo %']].map(([key,label]) => (
                                <th key={key} className="px-1.5 py-1.5 text-right text-slate-400 font-medium w-14 cursor-pointer select-none" onDoubleClick={() => setWlSort(s => ({col:key, dir: s.col===key && s.dir==='desc' ? 'asc' : 'desc'}))}>
                                  {label} {wlSort.col===key ? (wlSort.dir==='asc'?'â–²':'â–¼') : ''}
                                </th>
                              ))}
                              <th className="px-1 py-1.5 w-5">âœ•</th>
                            </tr>
                          </thead>
                          <tbody>
                            {(() => {
                              const sectorGroups = {};
                              watchlist.forEach(t => {
                                const sector = wlSectors[t] || 'Uncategorized';
                                if (!sectorGroups[sector]) sectorGroups[sector] = [];
                                sectorGroups[sector].push(t);
                              });

                              // Sort tickers within each group
                              if (wlSort.col) {
                                Object.values(sectorGroups).forEach(arr => {
                                  arr.sort((a, b) => {
                                    const pa = wlPrices[a]; const pb = wlPrices[b];
                                    let va, vb;
                                    if (wlSort.col === 'ticker') { va = a; vb = b; return wlSort.dir === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va); }
                                    va = pa?.[wlSort.col] ?? -Infinity;
                                    vb = pb?.[wlSort.col] ?? -Infinity;
                                    return wlSort.dir === 'desc' ? vb - va : va - vb;
                                  });
                                });
                              }

                              const sortedSectors = Object.keys(sectorGroups).sort((a, b) => a === 'Uncategorized' ? 1 : b === 'Uncategorized' ? -1 : a.localeCompare(b));
                              const hasSectors = Object.keys(wlSectors).length > 0;
                              const rows = [];
                              sortedSectors.forEach(sector => {
                                if (hasSectors) {
                                  rows.push(
                                    <tr key={'sec-' + sector} className="bg-slate-900/80"
                                      onDragOver={e => e.preventDefault()}
                                      onDrop={e => { e.preventDefault(); const t = e.dataTransfer.getData('text/plain'); if (t) setWlSectors(prev => ({...prev, [t]: sector})); }}>
                                      <td colSpan={13} className="px-2 py-1 border-b border-slate-700/50">
                                        <span className="text-yellow-400 font-bold text-xs">{'â€” ' + sector}</span>
                                        <span className="text-slate-600 text-xs ml-2">({sectorGroups[sector].length})</span>
                                      </td>
                                    </tr>
                                  );
                                }
                                sectorGroups[sector].forEach(ticker => {
                                  const p = wlPrices[ticker];
                                  const rc = (v) => v == null ? 'text-slate-600' : v >= 0 ? 'text-green-400' : 'text-red-400';
                                  const fmt = (v) => v == null ? 'â€”' : (v >= 0 ? '+' : '') + v.toFixed(2);
                                  const isEditing = wlEditSector?.ticker === ticker;
                                  rows.push(
                                    <tr key={ticker} className="border-b border-slate-800/50 hover:bg-slate-800/40 transition-colors cursor-grab active:cursor-grabbing"
                                      draggable onDragStart={e => { e.dataTransfer.setData('text/plain', ticker); e.dataTransfer.effectAllowed = 'move'; setWlDragTicker(ticker); }}
                                      onDragEnd={() => setWlDragTicker(null)}>
                                      <td className="px-1 py-1 text-center">
                                        <button onClick={() => setWlEditSector(isEditing ? null : { ticker, value: wlSectors[ticker] || '' })} className="text-slate-600 hover:text-slate-300 text-xs" title="Edit sector">âœŽ</button>
                                      </td>
                                      <td className="px-1.5 py-1 font-mono font-bold text-amber-300">{ticker}</td>
                                      <td className="px-1.5 py-1 text-slate-300 truncate max-w-[180px]">
                                        {isEditing ? (
                                          <input autoFocus value={wlEditSector.value} onChange={e => setWlEditSector({ ...wlEditSector, value: e.target.value })}
                                            onKeyDown={e => { if (e.key === 'Enter') { setWlSectors(prev => ({ ...prev, [ticker]: wlEditSector.value })); setWlEditSector(null); } if (e.key === 'Escape') setWlEditSector(null); }}
                                            onBlur={() => { setWlSectors(prev => ({ ...prev, [ticker]: wlEditSector.value })); setWlEditSector(null); }}
                                            className="bg-slate-700 text-white px-1 py-0.5 rounded text-xs w-full border border-blue-500" placeholder="Sector name..." />
                                        ) : (
                                          <span>{p?.name || '...'}</span>
                                        )}
                                      </td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + (p ? 'text-white' : 'text-slate-600')}>{p ? p.last.toFixed(2) : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.chg)}>{p ? fmt(p.chg) : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.chgPct)}>{p ? fmt(p.chgPct) + '%' : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.wtd)}>{p?.wtd != null ? fmt(p.wtd) + '%' : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.mo1)}>{p?.mo1 != null ? fmt(p.mo1) + '%' : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.mtd)}>{p?.mtd != null ? fmt(p.mtd) + '%' : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.mo3)}>{p?.mo3 != null ? fmt(p.mo3) + '%' : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.ytd)}>{p?.ytd != null ? fmt(p.ytd) + '%' : 'â€”'}</td>
                                      <td className={'px-1.5 py-1 text-right font-mono ' + rc(p?.mo12)}>{p?.mo12 != null ? fmt(p.mo12) + '%' : 'â€”'}</td>
                                      <td className="px-1 py-1 text-center">
                                        <button onClick={() => wlRemoveTicker(ticker)} className="text-slate-700 hover:text-red-400 transition-colors">âœ•</button>
                                      </td>
                                    </tr>
                                  );
                                });
                              });
                              return rows;
                            })()}
                          </tbody>
                        </table>
                      </div>
                      <div className="bg-slate-800 px-3 py-1.5 text-xs text-slate-500 flex justify-between border-t border-slate-700">
                        <span>{watchlist.length} securities | {[...new Set(Object.values(wlSectors))].filter(s => s && s !== 'Uncategorized').length || 0} sectors</span>
                        <span className="text-slate-600">{wlLoading ? 'â³ Loading...' : wlSort.col ? 'Sorted by ' + wlSort.col + ' ' + wlSort.dir : 'Double-click headers to sort'}</span>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <SingleNameTab />
            )}
            </div> {/* End dashboard ref wrapper */}

          {/* Auth Modal */}
          {showAuthModal && (
            <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60" onClick={() => setShowAuthModal(false)}>
              <div className="bg-slate-800 rounded-2xl border border-slate-600 p-8 w-full max-w-sm shadow-2xl" onClick={e => e.stopPropagation()}>
                <h2 className="text-2xl font-bold text-white mb-1">{authMode === 'login' ? 'Welcome Back' : 'Create Account'}</h2>
                <p className="text-sm text-slate-400 mb-6">{authMode === 'login' ? 'Sign in to your portfolio' : 'Start tracking your ideas'}</p>
                {authError && <div className="bg-red-500/10 border border-red-500/30 text-red-400 text-sm rounded-lg px-4 py-2 mb-4">{authError}</div>}
                {authMode === 'signup' && (
                  <input type="text" placeholder="Full Name" value={authForm.name} onChange={e => setAuthForm({...authForm, name: e.target.value})} className="w-full px-4 py-2.5 bg-slate-700 text-white rounded-lg border border-slate-600 mb-3 text-sm" />
                )}
                <input type="email" placeholder="Email" value={authForm.email} onChange={e => setAuthForm({...authForm, email: e.target.value})} className="w-full px-4 py-2.5 bg-slate-700 text-white rounded-lg border border-slate-600 mb-3 text-sm" />
                <input type="password" placeholder="Password" value={authForm.password} onChange={e => setAuthForm({...authForm, password: e.target.value})} onKeyDown={e => e.key === 'Enter' && handleAuth()} className="w-full px-4 py-2.5 bg-slate-700 text-white rounded-lg border border-slate-600 mb-4 text-sm" />
                <button onClick={handleAuth} className="w-full py-2.5 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-sm transition-colors">{authMode === 'login' ? 'Sign In' : 'Create Account'}</button>
                <p className="text-center text-sm text-slate-500 mt-4">
                  {authMode === 'login' ? "Don't have an account? " : 'Already have an account? '}
                  <button onClick={() => { setAuthMode(authMode === 'login' ? 'signup' : 'login'); setAuthError(''); }} className="text-blue-400 hover:text-blue-300">{authMode === 'login' ? 'Sign Up' : 'Sign In'}</button>
                </p>
              </div>
            </div>
          )}
          </div>
        </div>
      );
    };

    // Hide loading screen
    const loadingEl = document.getElementById('loading-screen');
    if (loadingEl) loadingEl.style.display = 'none';
    ReactDOM.render(<IdeaTracker />, document.getElementById('root'));
  </script>
</body>
</html>
